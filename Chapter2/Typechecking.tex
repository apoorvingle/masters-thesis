\chapter{Implementing Typechecking in Quill}


\section{Basic Definitions}

We go over the definitions of the base language and some conventions that we would
follow thorough out this thesis.

\section{Language Syntax and Types}

Language will be a pumped up version of simply typed lambda calculus with kind support

\begin{figure}[h]
  \begin{framed}
      \begin{flalign*}
      \text{Term Variables}\ \ \      x, y, z         &\in \text{Var} \nonumber  \\
      \text{Type Variables}\ \ \      t, u, v         &\in \text{TVar}  \nonumber\\
      \text{Kinds}\ \ \               \kappa          &::= * \mid \kappa \rightarrow \kappa \nonumber\\
      \text{Types}\ \ \               \tau^{\kappa}    &::= t \mid C^{\kappa} \mid \tau^{\kappa \rightarrow \kappa \rightarrow \kappa}\nonumber\\
      \text{Type constructors}\ \ \   C^{\kappa}       &::= C^{* \rightarrow * \rightarrow *} | \overset{!}{\sepimp} | \sepimp | \xrightarrow{!} | \rightarrow \nonumber\\
      \text{Predicates}\ \ \          \pi             &::= \texttt{Un}\ \tau \mid \texttt{SeFun}\ \tau \mid \texttt{ShFun}\ \tau \mid \tau \geq \tau' \nonumber\\
      \text{Qualified Types}\ \ \     \rho            &::= \tau^{*} \mid \pi \Rightarrow \rho \nonumber\\
      \text{Type schemes}\ \ \        \sigma          &::= \rho \mid \forall t. \sigma \nonumber\\
      \text{Environments}\ \ \      \Gamma,\Delta     &::= \epsilon \mid x:\sigma \mid \Gamma, \Delta \mid \Gamma; \Delta \nonumber\\
      \text{Environment Context}\ \ \ H               &::= H,H' \mid H;H' \mid \fbox{$\phantom{5}$} \nonumber\\ %\text{what is this how is it different from Environment?}
      \text{Expressions}\ \ \         M, N            &::= x \mid \lambda^{*}x. M \mid \lambda^{\alpha}x. M \mid M N\nonumber\\
                                                      &      \mid \texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N\nonumber\\
                                                      &      \mid \texttt{case}\ M\ \texttt{of}\ \{K_i\ x_{1i}\ x_{2i}\ \ldots\ x_{ji}\}_i\nonumber
    \end{flalign*}

% TODO work on this

\end{framed}
\caption{Language Syntax}
\label{fig:language-syntax}
\end{figure}


\section{Conventions and Notations}
$\Gamma_{x}$ is the typing environment excluding the type variable $x$. $TV(\Gamma)$ are the free
variables in the environment $\Gamma$.
%\begin{itemize}
% \item $\Pi$ varies over predicates
% \item $\Rightarrow$ qualified types
% \item $\Gamma$ and $\Delta$ are typing environments
% \item $,$ is a separating concatination of environment
% \item $;$ is a sharing concatination of environment
% \item $SeFun$ is a predicate of separating functions
% \item $\sepimp$ for separating function application
% \item $ShFun$ is a predicate of sharing functions
% \item $\rightarrow$ is for sharing function application
% \item $\geq$ lesser restricting
% \end{itemize}

\section{Syntax Directed Typing Judgements}

\begin{figure}[h]
  \begin{framed}
    % var
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{} \RightLabel{$[VAR]$}
        \UnaryInfC{$\Pi \mid x : \sigma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Pi \mid \Gamma \vdash M : \sigma \ \ \ \ \
          \Pi' \mid \Gamma_{x}, x: \sigma \vdash N: \tau$} \RightLabel{$[LET]$}
        \UnaryInfC{$\Pi \cup \Pi' \mid \Gamma \vdash \texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N: \tau$}
      \end{prooftree}
    \end{minipage}
    % => I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Pi, \pi \mid \Gamma \vdash M : \rho$} \RightLabel{$[\Rightarrow I]$}
        \UnaryInfC{$\Pi \mid \Gamma \vdash M : \pi \Rightarrow \rho$}
      \end{prooftree}
    \end{minipage}
    % => E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Pi \mid \Gamma \vdash M : \pi \Rightarrow \rho \ \ \ \ \
          \Pi \Rightarrow \pi$} \RightLabel{$[\Rightarrow E]$}
        \UnaryInfC{$\Pi \mid \Gamma \vdash M: \rho$}
      \end{prooftree}
    \end{minipage}

    % forall I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Pi \mid \Gamma \vdash M: \sigma \ \ \ \ \ \
          t \notin TV(\Gamma) \cup TV(\Pi)$}\RightLabel{$[\forall I]$}
        \UnaryInfC{$\Pi \mid \Gamma \vdash M: \forall t. \sigma$}
      \end{prooftree}
    \end{minipage}
    % forall E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Pi \mid \Gamma \vdash M: \forall t.\sigma$}\RightLabel{$[\forall E]$}
        \UnaryInfC{$\Pi \mid \Gamma \vdash M: [\tau / t] \sigma $}
      \end{prooftree}
    \end{minipage}

    % -&> I
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$\Pi \mid \Gamma_{x};x: \tau \vdash M : \tau' \ \ \ \ \
          \Pi \Rightarrow \texttt{ShFun} \phi \ \ \ \
          \Pi \vdash \Gamma \geq \phi$} \RightLabel{$[\rightarrow I]$}
        \UnaryInfC{$\Pi \mid \Gamma \vdash \lambda^{\alpha}x. M \tau : \phi \tau \tau'$}
      \end{prooftree}
    \end{minipage}
    % -&> E
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$\Pi \mid \Gamma \vdash M : \phi \tau \tau' \ \ \ \ \
          \Pi \mid \Delta \vdash N : \tau' \ \ \ \ \
          \Pi \Rightarrow \texttt{ShFun} \phi \ \ \ \
          \Pi \vdash \Gamma \geq \phi$} \RightLabel{$[\sepimp E]$}
        \UnaryInfC{$\Pi \mid \Gamma,\Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}

    % -*> I
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$\Pi \mid \Gamma_{x},x: \tau \vdash M : \tau' \ \ \ \ \
          \Pi \Rightarrow \texttt{SeFun} \phi \ \ \ \
          \Pi \vdash \Gamma \geq \phi$} \RightLabel{$[\sepimp I]$}
        \UnaryInfC{$\Pi \mid \Gamma \vdash \lambda^{*}x. M : \phi \tau \tau'$}
      \end{prooftree}
    \end{minipage}
    % -*> E
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$\Pi \mid \Gamma \vdash M : \phi \tau \tau' \ \ \ \ \
          \Pi \mid \Delta \vdash N : \tau \ \ \ \ \
          \Pi \Rightarrow \texttt{ShFun} \phi \ \ \ \
          \Pi \vdash \Gamma \geq \phi$} \RightLabel{$[\rightarrow E]$}
        \UnaryInfC{$\Pi \mid \Gamma;\Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
    % user defined type constructor I
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$\Pi \mid \Gamma \vdash M: \tau       \ \ \ \ \ \
          \{\vdash K_i:\bar{x}_i \rightsquigarrow H    \ \ \ \ \ \
          \Delta \cdot H \vdash M: v \}_i$}\RightLabel{$[K_i I]$}
        \UnaryInfC{$\Pi \mid \Gamma \cdot \Delta \vdash \texttt{case}\ M\ \texttt{of}\ \{K_i\ x_{1i}\ x_{2i} \ldots\ x_{ji} \rightarrow N_i\}_i : v $}
      \end{prooftree}
    \end{minipage}
    % user defined type constructor E
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$\Pi \mid \Gamma \cdot \Delta \vdash \texttt{case}\ M\ \texttt{of}\ \{K_i\ x_{1i}\ x_{2i} \ldots\ x_{ji} \rightarrow N_i\}_i : v $}\RightLabel{$[K_i E]$}
        \UnaryInfC{$Elemenation TODO!$}
      \end{prooftree}
    \end{minipage}

    \caption{Typing Rules}
    \label{fig:typing-rules}
  \end{framed}
\end{figure}


Here is how the naive recursive algorithm works

For Lambda
\begin{enumerate}
\item Get the bound variable
\item Assign a new type for bound variable
\item assign a new type variable for the body
\item Evaluate type of the body and assign it to the body type varialbe
\item return the type as (type of var) -> (type of body)
\end{enumerate}

Body can be made up of another lambda. In this case the same 5 steps will be triggered
or it is an application of 2 or more variables
In case of application 2 new type variable:
\begin{enumerate}
\item introduce type variables for left expression and right expression
    left expression a type $A \rightarrow B$ right expression gets the type $A$
\item recursively type check both of them
\item return the type of the complete application as $B$ if the type checking in previous step is successfull
\end{enumerate}


In Quill there are 2 kinds of lambdas:
\begin{enumerate}
\item Sharing Lambda $\lambda^{\alpha}$
\item Separating Lambda $\lambda^{*}$
\end{enumerate}
This helps us specify if the 2 variables are separated or have sharing
of resources between them.
The church encoding of a sharing pair will be represented as\\
$shPair = \lambda^{*} x \rightarrow \lambda^{\alpha} y \rightarrow \lambda^{*} sh \rightarrow sh\ x\ y$\\
This means that x and y may share resources
A sparating pair is represented as\\
$sePair = \lambda^{*} x \rightarrow \lambda^{*}y \rightarrow \lambda^{*}se \rightarrow se\ x\ y$\\
This means that x and y do not share resources.
%By default we may assume that resources are always separating unless explicitly specified
%that they are sharing.

\section{Typing environment}

The typing environment in standard Milner-Damas algorithm
is a pair of identifier and its type.
We need to modify the typing envrionment so that it describes sharing.
% There can be many different ways of doing it.
In the current implmenetation we have
extended the typing environment to hold 2 more entities along with the
type of the indentifier, a list of list of identifiers --- that describes the sharing of variables,
a scope tag---that identifies if the variable is global in the complete module or local to the definition.
Global variables can be used anywhere in the file or other code file if it is imported
All function names will be defaulted to global scope.
Local variables can be used only after they have been bound in the typing environment.
The new typing envionment can be realized as:
\begin{minted}{haskell}
  type Env = Map Id (Type, [[Id]], Scope)
\end{minted}

% how is the list of list of ids help in identifying sharing

% how do you define a closure

% What do you mean by having a break in the closure

% The used field in the typechecker state

\section{Modification to Typechecking Algorithm}

To incorporate the sharing, we have to modify the typechecking algorithm.
The main reason to do that is to avoid adding $Un$ predicates to
shared variables that are not used. Take an example of $fst$ function
that returns the first argument of a shared pair
\begin{verbatim}
fst = \x -> \&y -> x
\end{verbatim}
In this case y should not be assigend an $Un$ predicate because
it is shared with x and x is indeed used.

The type checking algorithm has to be tweeked so that we keep track
of what all variables are shared and which ones are separate.

When we encounter an Alpha Lambda
\begin{enumerate}
\item Get the bound variable
\item Assign a new type for bound variable
\item Assign a new type variable for the body
\item add the variable in a sharing context
\item Evaluate type of the body and assign it to the body type variable
\item return the type as (type of var) -> (type of body)
\end{enumerate}


% The main problem is that we do not know when a sharing variable should be kept in scope
% or removed. In some cases we may need to keep it around for introducing the (>:=) predicates
% Some cases are 2 types:
% 1) The variable is used
% 2) The variable is not used

The type checking calls occur from left to right recursively.
While going down the recursion we keep on adding variables to the envionment
We stop recursing at application. where we compute whether we have complete sharing to assign ShFun or SeFun.

While folding out of of the recursion we do 2 things:
1) keep track of the used variables (including implicitly used variables due to sharing)
2) generate new goals
   a) depending on whether the the introduced variable was used
      or its sharing member was used. Assign Un predicates and weaken if it is not used at all
   b) introduce lesser-restricted predicates
3) Generate other new assumptions

We cannot determine when to get rid of the complete bunch.
\begin{verbatim}
\z -> \*x -> \&y -> y
\end{verbatim}
hence, when we are folding out of the final recursive but 1 call ie. for Lambda bound variable x


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "Typechecking"
%%% End:
