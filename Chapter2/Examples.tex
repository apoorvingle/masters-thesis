\chapter{Programming in \qub{}}
In this chapter, we illustrate using examples how \qub{} is different
from other functional languages and how a powerful type system based on logic of \BI
would be used to track resources. The examples show how the resources use
can be tracked at compile time and resource leaks can be avoided.

\section{File Handles}\label{sec:file-handle-example}
In modern languages file handles are treated as normal variables
and it is the programmer's responsiblity to check that that files are not closed twice
and that there are no files that remain open when the program exits. This seemingly trivial
responsibility becomes tedious and error prone as soon as the programming logic gets complex.
Modern functional languages such as Haskell enforces the file input/output to be wrapped in a IO Monad.
This is more declarative than imperative languages, but the type system is not powerful enough
to detect whether a file handle is closed twice or is not closed at all.
Consider the functions for file handling as shown in \cref{fig:file-handling-function}. A simple program in Hasell that opens a file and reads
a line from it and then closes the file handle is shown in \cref{fig:file-read-close}.

\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
openFile :: FilePath -*> IO FileHandle
closeFile :: FileHandle -*> IO ()
readLine :: FileHandle -*> IO (String, FileHandle)
writeFile :: String -*> FileHandle -> IO ((), FileHandle)
    \end{minted}
  \end{framed}
  \caption{File Handling functions}
  \label{fig:file-handling-function}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
do f  <- openFile "sample.txt"
   (s, f)  <- readLine f
   () <- closeFile f
    \end{minted}
  \end{framed}
  \caption{Reading from a file in Haskell}
  \label{fig:file-read-close}
\end{figure}

Consider an incorrect version of the above program where the file handle is closed twice after reading a line from it \cref{fig:file-read-close-2times}.
It may not be a problem in a single threaded environment, but in a multithreaded environment
the second close may accidently close the file handle that may have been reused in the background by another thread.
When another thread tries to write on this closed file handle, it would throw an exception.
Haskell's type system would happily accept this program but it might generate a runtime exception.
\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
do f  <- openFile "sample.txt"
   (s, f)  <- readLine f
   () <- closeFile f
   () <- closeFile f
    \end{minted}
  \end{framed}
  \caption{Reading from a file and closing it twice}
  \label{fig:file-read-close-2times}
\end{figure}

Another example of incorrect way of using file handle is by not closing the file handle after using it shown in \cref{fig:file-read-noclose}.
In a short lived process, when the program exits, file handles that are not closed are freed by the operating system.
But if it is a long running process it would run out of file handles and the whole process would crash with an error that
it cannot open any more file handles. Abnormal exit from the process would interfere in the write process
and the operating system would close the file handle without waiting for the buffer to be completely
written on the file system.
\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
do f <- openFile "sample.txt"
   (s, f)  <- readLine f
   return s
    \end{minted}
  \end{framed}
  \caption{Reading from a file and not closing file handle}
  \label{fig:file-read-noclose}
\end{figure}
We take a deeper dive into this problem by seeing the desugared version of the ``do'' notation.
Both the programs would be translated into bind ($>>=$) operations . Recall that type signature of bind function is given as
\mintinline{haskell}{(>>=) :: (Monad m) => m t -> (t -> m u) -> m u}. Desugared version of \cref{fig:file-read-close-2times}
would look like as shown in \cref{fig:file-read-close-2times-desugared}
and the desugared version of \cref{fig:file-read-noclose} would look like \cref{fig:file-read-noclose-desugared}.

\begin{figure}[h]
  \begin{framed}
    \begin{minted}[escapeinside=||,mathescape=true]{haskell}
(>>=|$_1$|) (openFile "sample.txt") (\f ->
            (>>=|$_2$|) (readFile f) (\ (s, f) ->
                        (>>=|$_3$|) (close f) (\_ -> closeFile f)))
    \end{minted}
  \end{framed}
  \caption{Reading from a file in Haskell and closing twice}
  \label{fig:file-read-close-2times-desugared}
\end{figure}

\begin{figure}[h]
  \begin{framed}
\begin{minted}{haskell}
(>>=) (openFile "sample.txt" ReadMode) (\ f ->
       >>= (closeFile f) (\ (s, f) -> return s)
\end{minted}
  \end{framed}
  \caption{Reading from a file in Haskell and not closing it}
  \label{fig:file-read-noclose-desugared}
\end{figure}

In both the cases, the types of the programs would be computed by haskell compiler as \mintinline{haskell}{IO ()}
This well typed looking program should be flagged by the compiler as it would cause problems at runtime.
To overcome this, we introduce the concept of unrestrictedness and sharing and separation of resources.

The $\rightarrow$ constructor now has 2 meanings---shared or separated---we are
forced to describe the bind operator in terms of $\sepimp$ or $\rightarrow$. In Quill the bind operation will
be typed as given in \cref{fig:quill-bind-type}. This means all resources used by the funtion are separate.
\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
          (>>=) :: m t -*> (t -!*> m u) -*> m u
    \end{minted}
  \end{framed}
  \caption{Type signature for bind in Quill}
  \label{fig:quill-bind-type}
\end{figure}
Thus all the resources used should be separating, but as we see in \cref{fig:file-read-close-2times-desugared} the file handle
\texttt{f} is shared in the third bind operation.
The bind operations will have the signatures as shown in \cref{fig:bind-signatures}
\begin{figure}[h]
\begin{framed}
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
(>>=|$_1$|):: IO FileHandle -*> (FileHandle -!*> IO ()) -*> IO ()
(>>=|$_1$|) (openFile "sample.txt" ReadMode) (\f -> ...)

(>>=|$_2$|) :: IO FileHandle
            -*> (FileHandle -!*> IO (String, Filehandle))
            -*> IO (String, FileHandle)}
(>>=|$_2$|) (readLine f) (\ (s,f) -> ... )

(>>=|$_3$|) :: IO () -*> (() -!*> IO ()) -&> IO ()
(>>=|$_3$|) (closeFile f) (\_ -> closeFile f)}
\end{minted}
\end{framed}
\caption{Bind Signatures}
\label{fig:bind-signatures}
\end{figure}

The type of the third bind would be computed as \\
\mintinline{haskell}{IO () -*> (() -!*> IO ()) -&> IO ()} which would be a type error
as the bind operation should have a type signature of
\mintinline{haskell}{IO () -*> (() -!*> IO ()) -*> IO ()}. The types here would not match.
The types do match up for the correct implementation of the file read and close shown in \cref{fig:file-read-close}.
The first bind \mintinline{haskell}{(>>=) (openFile "sample.txt" ReadMode) (\ f -> ...)} has a type signature of
\mintinline{haskell}{IO FileHandle -*> (FileHandle -!*> IO ()) -*> IO ()} and the second bind
\mintinline{haskell}{(>>=) (readLine f) (\ (s, f) -> close f)} has a type signature of\\
\mintinline{haskell}{IO (String, FileHandle) -*> (FileHandle -!*> IO ()) -*> IO ()}

In \cref{fig:file-read-noclose-desugared} the file handle \texttt{f} is not closed. It is declared, but not used
in its scope, it would be tagged as an unrestricted value by the Quill type checker.
This is in voilation of our assumption that resources cannot be of the unrestricted type. Thus
the program would not typecheck due to mismatch of the file handle type to be unrestricted.

\section{Exception handling}
We expand on the file handling scenario and consider the code that can throw runtime exceptions.
The motivation to do so lies in the fact that memory leaks are caused becuase of runtime
exceptions where the part of code that is responsible to clean up resources or in this case
closing the file is skipped due to an alternate execution path.

The \HaskellF{IOMonad} is a class that encapsulates two kinds of IOs. \HaskellF{IO} that does not fail
or throw exceptions, and \HaskellF{IOF} that can fail and throw exceptions.
For a concrete example we will assume that \HaskellF{readLine} can throw an exception during runtime, where
it might fail to read a line due to the file mode being used has incorrect permissions.
For the sake of simplicity \HaskellF{openFile} and \HaskellF{closeFile} do not throw exceptions.
\HaskellF{onExcept} accepts a code that can fail and executes the second
parameter only if the actual code throws an exception. The \HaskellF{onExcept} gives a chance
to clean up resources in a systematic way. It may convert a code that can fail to a code
that does not fail by using \HaskellF{catch} function, or it may re throw the exception after
cleaning up the resources.

In the exceptionless execution path in \cref{fig:file-exceptions}, a single line would be read from the file and its uppercased
version would be returned after closing it. If suppose, an exception is thrown by \HaskellF{readLine}
the \HaskellF{onExcept} would close the filehandle. Notice that \HaskellF{onExcept}
shares the context with the file readline code, thus the appropriate file handle would be closed and
we would not have any memory leak.

\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
openFile :: FilePath -*> IO FileHandle
closeFile :: FileHandle -*> IO ()
readFile :: FileHandle -*> IOF (String, FileHandle)
writeFile :: String -*> FileHandle -*> IOF ((), FileHandle)

throw :: Exception -> IO a
catch :: IOMonad IOM => IO a -*> (IO a -> IOM b) -&> IOM b

onExcept :: IOF a -*> IOF () -&> IOF a
m `onExcept` n = m `catch` (\e -> n >> throw e)

readFromFile :: String -*> IO (Either String String)
readFromFile f =
do fh  <- openFile f WriteMode
   ((s, fh)  <- readLine fh
   let l = caps s
   () <- close fh
   return $ Right l) `onExcept` (do () <- closeFile fh)
                     `catch` (\e ->
                              return $ Left "Could not read file")
    \end{minted}
  \end{framed}
  \caption{Exception Handling in Files}
  \label{fig:file-exceptions}
\end{figure}



% \section{Non Empty List}\label{sec:dll-example}
% A non empty list in Quill would look like
% \begin{minted}{haskell}
% data NEList a = Last a | Cons a (NEList a)
% \end{minted}

% The operations one could perfrom on a non-empty list are
% \begin{minted}{haskell}
% head :: NEList a -&> a
% head (Last h) = h
% head (Cons h t) = h

% tail :: NEList a -&> a
% tail (Last h) = h
% tail (Cons h t) = tail t

% concat :: NEList a -*> NEList a -&> NEList a
% concat (Last h') t = Cons h' t
% concat (Cons h t') t'' = Cons h (concat t' t'')

% append :: a -*> NEList a -&> NEList a
% append a t = Cons a t
% \end{minted}

% The underlying implementation of this list can be thought of a doubly
% linked list. There would be pointers that would connect the the individual nodes to form a doubly linked list.
% The programmer would be agnostic of the pointer handling as we expect the type system to be powerful enough to
% make sure that the lower level code generated would be free of memory leaks and runtime exceptions.
% It makes sense for this doubly linked list implementation to fit the description of a shared resource as nodes
% are interconnected. Getting access to one node gives us access to the whole list.



% \section{Circular Linked List as a Queue}\label{sec:queue-example}

% Circular list as a queue example



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku"
%%% End:
