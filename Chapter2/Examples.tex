\chapter{Programming in Quill}
In the following chapter we illustrate using different examples to show how Quill is different
from other functional languages and how a powerful type system backed by logic of Bunched Implications
would be useful in keeping track of resources. The theme of the the examples have two main
points to focus on. A resource has to be used in a linear fashion and cannot be dropped or duplicated i.e. resource
does not qualify to be an unrestricted type. This will be illuminated in \cref{sec:file-handle-example}.
The second being we should have atleast one access point or view of the shared resource in our program.
We may create new views or drop the views we have created but the view count cannot go to zero. This will
be illustrated in \cref{sec:dll-example} and \cref{sec:queue-example}.

\section{File Handles}\label{sec:file-handle-example}
In an imperative language file handles are treated as normal variables
and it is the programmers responsiblity to check that that files are not closed twice
or there are no files that remain open when the program exits. This seemingly non-trivial
responsibility becomes tedious and erroneous as soon as there are multiple conditionals in the programming
logic, and as programs get larger in size. Modern functional languages such as Haskell treat file handles as
a special datatype and make them an instance of Monad. Consider the functions for file handling
as shown in \cref{fig:file-handling-function}. The type system however is not powerful enough
to detect whether a file handle is closed twice or is not closed at all. A simple program in Hasell that opens a file and reads
a line from it and then closes the file handle is shown in \cref{fig:file-read-close}.

\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
openFile :: FilePath -> IO FileHandle
closeFile :: FileHandle -> IO ()
readFile :: FileHandle -> IO (String, FileHandle)
writeFile :: String -> FileHandle -> IO ((), FileHandle)
    \end{minted}
  \end{framed}
  \caption{File Handling functions}
  \label{fig:file-handling-function}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
      do f  <- openFile "sample.txt"
         (s, f)  <- readLine f
         () <- close f
    \end{minted}
  \end{framed}
  \caption{Reading from a file in Haskell}
  \label{fig:file-read-close}
\end{figure}

Consider an incorrect version of the above program where the file handle is closed twice after reading a line from it \cref{fig:file-read-close-2times}.
It may not be a problem in a single threaded environment, but in a multithreaded environment
the second close may accidently close the file handle that may have been reused in the background by another thread.
When another thread tries to write on this closed file handle, it would throw an exception.
Haskell's type system would happily accept this program but it might generate a runtime exception.
\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
      do f  <- openFile "sample.txt"
         (s, f)  <- readLine f
         () <- close f
         () <- close f
    \end{minted}
  \end{framed}
  \caption{Reading from a file and closing it twice}
  \label{fig:file-read-close-2times}
\end{figure}

Another example of incorrect way of using file handle is by not closing the file handle after using it shown in \cref{fig:file-read-noclose}.
In a short lived process, when the program exits, file handles that are not closed are freed by the operating system.
But if it is a long running process it would run out of file handles and the whole process would crash with an error that
it cannot open any more file handles. Abnormal exit from the process would interfere in the write process
and the operating system would close the file handle without waiting for the buffer to be completely
written on the file system.
\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
      do f <- openFile "sample.txt"
         (s, f)  <- readLine f
    \end{minted}
  \end{framed}
  \caption{Reading from a file and not closing file handle}
  \label{fig:file-read-noclose}
\end{figure}

We take a deeper dive into this problem by seeing the desugared version of the ``do'' notation.
Both the programs would be translated into bind ($>>=$) operations . Recall that type signature of bind function is given as
\mintinline{haskell}{(>>=) :: (Monad m) => m t -> (t -> m u) -> m u}. Desugared version of \cref{fig:file-read-close-2times}
would look like as shown in \cref{fig:file-read-close-2times-desugared}
and the desugared version of \cref{fig:file-read-noclose} would look like \cref{fig:file-read-noclose-desugared}.

\begin{figure}[h]
  \begin{framed}
    \begin{minted}[escapeinside=||,mathescape=true]{haskell}
      (>>=|$_1$|) (openFile "sample.txt") (\f ->
                  (>>=|$_2$|) (readLine f) (\ (s, f) ->
                              (>>=|$_3$|) (close f) (\_ -> close f)))
    \end{minted}
  \end{framed}
  \caption{Reading from a file in Haskell and closing twice}
  \label{fig:file-read-close-2times-desugared}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
      (>>=) (openFile "sample.txt" ReadMode) (\ f -> readLine f)
    \end{minted}
  \end{framed}
  \caption{Reading from a file in Haskell and not closing it}
  \label{fig:file-read-noclose-desugared}
\end{figure}

In both the cases, the types of the programs would be computed by haskell compiler as \mintinline{haskell}{IO ()}
This well typed looking program should be flagged by the compiler as it would cause problems at runtime.
To overcome this, we introduce the concept of unrestrictedness and sharing and separation of resources.

The $\rightarrow$ constructor now has 2 meanings---shared or separated---we are
forced to describe the bind operator in terms of $\sepimp$ or $\rightarrow$. In Quill the bind operation will
be typed as given in \cref{fig:quill-bind-type}. This means all resources used by the funtion are separate.
\begin{figure}[h]
  \begin{framed}
    \begin{minted}[escapeinside=||,python3=true,mathescape=true]{haskell}
          (>>=) :: m t -*> (t -!*> m u) -*> m u
    \end{minted}
  \end{framed}
  \caption{Type signature for bind in Quill}
  \label{fig:quill-bind-type}
\end{figure}
Thus all the resources used should be separating, but as we see in \cref{fig:file-read-close-2times-desugared} the file handle
\texttt{f} is shared in the third bind operation.
The bind operations will have the signatures as shown in \cref{fig:bind-signatures}
\begin{figure}[h]
\begin{framed}
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
(>>=|$_1$|):: IO FileHandle -*> (FileHandle -!*> IO ()) -*> IO ()
(>>=|$_1$|) (openFile "sample.txt" ReadMode) (\f -> ...)

(>>=|$_2$|) :: IO FileHandle
            -*> (FileHandle -!*> IO (String, Filehandle))
            -*> IO (String, FileHandle)}
(>>=|$_2$|) (readLine f) (\ (s,f) -> ... )

(>>=|$_3$|) :: IO () -*> (() -!*> IO ()) -&> IO ()
(>>=|$_3$|) (closeFile f) (\_ -> closeFile f)}
\end{minted}
\end{framed}
\caption{Bind Signatures}
\label{fig:bind-signatures}
\end{figure}

% The first bind has a type signature of\\
% \mintinline[escapeinside=||,mathescape=true]{haskell}{(>>=|$_1$|) (openFile "sample.txt" ReadMode) (\f -> ...)}\\
% \mintinline{haskell}{:: IO FileHandle -*> (FileHandle -!*> IO ()) -*> IO ()}
% second bind has a type signature of\\
% \mintinline[escapeinside=||,mathescape=true]{haskell}{(>>=|$_2$|) (readLine f) (\s -> ... )}\\
% \mintinline{haskell}{:: IO FileHandle -*> (FileHandle -!*> IO (String, Filehandle)) -*> IO (String, FileHandle)}
% and the third bind operation has the type signature of\\
% \mintinline[escapeinside=||,mathescape=true]{haskell}{(>>=|$_3$|) (closeFile f) (\_ -> closeFile f)}\\
% \mintinline{haskell}{:: IO () -*> (() -!*> IO ()) -&> IO ()}
% This would be raised as a compiler error as the type of the third bind operation does
% not match the expected type of bind function.
% The arguments of the third bind operation are \mintinline{haskell}{close f}
% and \mintinline{haskell}{\_ -> close f} where they share the only resource \texttt{f}
The type of the third bind would be computed as \\
\mintinline{haskell}{IO () -*> (() -!*> IO ()) -&> IO ()} which would be a type error
as the bind operation should have a type signature of
\mintinline{haskell}{IO () -*> (() -!*> IO ()) -*> IO ()}. The types here would not match.

The types do match up for the correct implementation of the file read and close described in \cref{fig:file-read-close}.
      % (>>=) (openFile "sample.txt" ReadMode)
      %       (\f -> (>>=) (readLine f)
      %                    (\s -> (close f)))
The first bind has a type signagure of\\
\mintinline{haskell}{(>>=) (openFile "sample.txt" ReadMode) (\ f -> ...)}\\
\mintinline{haskell}{:: IO FileHandle -*> (FileHandle -!*> IO ()) -*> IO ()}

and the second bind has a type signature of\\
\mintinline{haskell}{(>>=) (readLine f) (\ (s, f) -> close f)}\\
\mintinline{haskell}{:: IO (String, FileHandle) -*> (FileHandle -!*> IO ()) -*> IO ()}

Similarly, in \cref{fig:file-read-noclose-desugared} the file handle \texttt{f} is not closed thus it is declared, but not used
in the scope, it would be tagged as an unrestricted value by the Quill type checker.
This is in voilation of our assumption that resources cannot be of the unrestricted type. Thus
the program would not typecheck due to mismatch of the file handle type needing to be unrestricted.


\section{Exception handling}

What is the return type?
\begin{figure}[h]
  \begin{framed}
    \begin{minted}{haskell}
       or :: IO a -*> IO a -&> IO b
       m `or` n = m `catch` \e -> n

       throw :: Exception -> IO a
       catch :: IO a -> (IO a -> IO b) -&> IO b

      do f  <- openFile "sample.txt" WriteMode
         (s, f)  <- readLine f `or` close f
         let l = caps s
         () <- close f
         return l

    \end{minted}
  \end{framed}
  \caption{playground}
  \label{fig:playground}
\end{figure}



\section{Non Empty List}\label{sec:dll-example}
A non empty list in Quill would look like
\begin{minted}{haskell}
data NEList a = Last a | Cons a (NEList a)
\end{minted}

The operations one could perfrom on a non-empty list are
\begin{minted}{haskell}
head :: NEList a -&> a
head (Last h) = h
head (Cons h t) = h

tail :: NEList a -&> a
tail (Last h) = h
tail (Cons h t) = tail t

concat :: NEList a -*> NEList a -&> NEList a
concat (Last h') t = Cons h' t
concat (Cons h t') t'' = Cons h (concat t' t'')

append :: a -*> NEList a -&> NEList a
append a t = Cons a t
\end{minted}

The underlying implementation of this list can be thought of a doubly
linked list. There would be pointers that would connect the the individual nodes to form a doubly linked list.
The programmer would be agnostic of the pointer handling as we expect the type system to be powerful enough to
make sure that the lower level code generated would be free of memory leaks and runtime exceptions.
It makes sense for this doubly linked list implementation to fit the description of a shared resource as nodes
are interconnected. Getting access to one node gives us access to the whole list.



\section{Circular Linked List as a Queue}\label{sec:queue-example}

Circular list as a queue example


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku"
%%% End:
