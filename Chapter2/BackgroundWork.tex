\chapter{Background Work}\label{chp:background-work}
\section{Hindley-Milner Type System and Type Inference Algorithm}\label{hm-system}

Hindley-Milner (\textbf{HM}) type system\citeyearpar{milner_theory_1978} for lambda calculus extended with parametric polymorphism (i.e restricted version
of System F\citep{girard_proofs_1989}) forms the basis many modern functional programming languages such as Haskell and ML.
\cref{fig:hm-lang} shows the type language contains type variables, primitive types (such as integers, floats),
the type constructor ($\rightarrow$)---which constructs function types---and type scheme ($\sigma$).
The expression language contains variables, function abstraction and applications and
polymorphic \texttt{let} construct. Type inference algorithm $\mathcal{W}$\citep{damas_principal_1982} and its variant
type checking algorithm $\mathcal{M}$\citep{lee_proofs_1998} is decidable in the sense, the algorithm always completes with a success or failure.
The algorithms compute a most general, or principal typing scheme for an expression.

\begin{figure}[h]
  \begin{framed}
    \begin{minipage}{0.35\linewidth}
      \begin{flalign*}
        t, u, \upsilon &\in \text{Type Variables}
      \end{flalign*}
    \end{minipage}%
  \begin{minipage}{0.65\linewidth}
  \begin{flalign*}
    \text{Types}\ \ \  \tau           &::= t \mid \iota \mid \tau \rightarrow \tau\\
    \text{Typing Scheme}\ \ \  \sigma &::= \tau \mid \forall t. \tau\\
    \text{Typing Context}\ \ \ \Gamma &::= \epsilon \mid \Gamma, x:\sigma\\
         \text{Expressions}\ \ \ M, N &::= x \mid \lambda x. M \mid M N \mid \Let{x}{M}{N}
       \end{flalign*}
     \end{minipage}
     \end{framed}
\caption{Hindley-Milner Type and Expression Language}
\label{fig:hm-lang}
\end{figure}

Robinson's\citeyearpar{robinson_machine-oriented_1965} unification algorithm plays a key role
in computation of well-formed principal types. Its purely syntactic approach in creating
substitutions to unify types keeps the complete process elegant.
Algorithm $\mathcal{M}$ can either be used to either infer the types of all well-typed expressions it
can be used to verify that the specified type of expression term matches the actual type. The same
can be obtained using algorithm $\mathcal{W}$ with an additional machinery of
computing equality over types.

\begin{figure}[h]
  \begin{framed}
    % var
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \sigma \in \Gamma$} \RightLabel{[VAR]}
        \UnaryInfC{$\Gamma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma$}
        \AxiomC{$\Gamma_{x}, x: \sigma \vdash N: \tau$} \RightLabel{[LET]}
        \BinaryInfC{$\Gamma \vdash (\Let{x}{M}{N}) : \tau$}
      \end{prooftree}
    \end{minipage}
    % forall I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma$}\RightLabel{[$\forall$ I]}
        \AxiomC{$t \notin \texttt{fvs}(\Gamma)$}
        \BinaryInfC{$\Gamma \vdash M : \forall t. \sigma$}
      \end{prooftree}
    \end{minipage}
    % forall E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma$}
        \AxiomC{$(\sigma' \sqsubseteq \sigma)$}\RightLabel{[$\forall$ E]}
        \BinaryInfC{$\Gamma \vdash M : \sigma'$}
      \end{prooftree}
    \end{minipage}
    % -> I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{[$\rightarrow$ I]}
        \UnaryInfC{$\Gamma \vdash \lambda x. M : \tau \rightarrow \tau'$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \rightarrow \tau'$}
        \AxiomC{$\Gamma \vdash N : \tau$} \RightLabel{[$\rightarrow$ E]}
        \BinaryInfC{$\Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Typing Rules for \textbf{HM} Type System}
  \label{fig:hm-system}
\end{figure}

The rules for \textbf{HM} type system are shown in \cref{fig:hm-system}. $\Gamma$ is the
collection of assumptions, or context, in which the expression M is typed. It can be thought of as a collection--list or set--of
an ordered pair of identifier and its type scheme. $\Gamma_{x}$ denotes the type assignment excluding the type variable $x$.
The [VAR] rule is the tautology; a simple lookup of variable $x$ in context $\Gamma$ for the type scheme. [$\rightarrow$I] and [$\rightarrow$E] type
lambda terms and application respectively. Rules for parametric polymorphism are implicit in expression language.
[$\forall$I] rule generalizes the type scheme by adding universal quantifiers and [$\forall$E] generates an instance
of the type scheme by substituting free type variables. $\sigma' \sqsubseteq \sigma$ means $\sigma'$ is an instance
of $\sigma$. While generalizing types, the rule [$\forall$I], has a side condition that ensures the new type variable
introduced should not be free in the typing context. The $\texttt{fvs}(\Gamma)$ denotes free type variables in $\Gamma$.
The [LET] rules allows implicit parametric polymorphism. For example, the expression, \texttt{g = $\lambda$f.(f True, f 1)} is ill-typed.
The type unification will fail for \texttt{f} as the expression \texttt{f True} asserts \texttt{f:Bool$\rightarrow$u$_1$} while the expression
\texttt{f 1} asserts \texttt{f:Int$\rightarrow$u$_2$}. However, there indeed exists a polymorphic type \texttt{$\forall$u$_1$.u$_1$ $\rightarrow$ u$_1$}
that types \texttt{f}. The \texttt{let} construct makes this possible. The expression \texttt{g} can be defined
as \texttt{g = let f = $\lambda$ x. x in (f True, f 1)}. The type of the expression \texttt{f} is now computed
as \texttt{f : $\forall$u$_1$. u$_1\rightarrow$u$_1$}, using [$\rightarrow$I] and [$\forall$I] rules and \texttt{g} is assigned a type \texttt{(Bool, Int)}.

\begin{figure}[h]
  \centering
  \begin{framed}
  \begin{flalign*}
    A, B, C &::= x \mid A \supset B \mid \forall x. B \mid A \wedge B \mid A \vee B\\
    \Gamma,\Delta &::= \epsilon \mid \Gamma, A
  \end{flalign*}
\end{framed}
\caption{Grammar for Intuitionistic Logic}
\label{fig:intu-logic-grammar}
\end{figure}

Using the Curry-Howard correspondence, the \textbf{HM} type system
corresponds to the second order implication fragment of intuitionistic propositional logic.
The grammar of intuitionistic logic is shown in \cref{fig:intu-logic-grammar} where $\Gamma \supset \Delta$ denotes implication,
$A \wedge B$ denotes conjunction and $A \vee B$ denotes disjunction.

\begin{figure}[h]\centering
  \begin{framed}
    % ID
    \begin{minipage}{0.20\linewidth}
      \begin{prooftree}
        \AxiomC{${\color{white}A \Gamma A}$}\RightLabel{[Ax]}
        \UnaryInfC{$A \vdash A $}
      \end{prooftree}
    \end{minipage}%
    % WKN
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash B$}\RightLabel{[WKN]}
        \UnaryInfC{$\Gamma, A \vdash B$}
      \end{prooftree}
    \end{minipage}%
    % CTR
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, A, A \vdash B$}\RightLabel{[CTR]}
        \UnaryInfC{$\Gamma, A \vdash B $}
      \end{prooftree}
    \end{minipage}

    % \forall I
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash B$}
        \AxiomC{$x \notin \Gamma$}\RightLabel{[$\forall$I]}
        \BinaryInfC{$\forall x. B$}
      \end{prooftree}
    \end{minipage}%
    % \forall E
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash \forall x. B$}
        \AxiomC{$\Gamma \vdash A$}\RightLabel{[$\forall$E]}
        \BinaryInfC{$B[x/A]$}
      \end{prooftree}
    \end{minipage}

    % -> I
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma,A \vdash B$}\RightLabel{[$\supset$I]}
        \UnaryInfC{$\Gamma \vdash A \supset B$}
      \end{prooftree}
    \end{minipage}%
    % -> E
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \supset B$}
        \AxiomC{$\Gamma \vdash A$}\RightLabel{[$\supset$E]}
        \BinaryInfC{$\Gamma \vdash B $}
      \end{prooftree}
    \end{minipage}

    % \Gamma and A
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$}
        \AxiomC{$\Gamma \vdash B$}\RightLabel{[$\wedge$I]}
        \BinaryInfC{$\Gamma \vdash A \wedge B$}
      \end{prooftree}
    \end{minipage}%
    % \Gamma and delta E_1
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \wedge B$}\RightLabel{[$\wedge$E$_1$]}
        \UnaryInfC{$\Gamma \vdash A $}
      \end{prooftree}
    \end{minipage}%
    % \Gamma and delta E_2
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \wedge B$}\RightLabel{[$\wedge$E$_2$]}
        \UnaryInfC{$\Gamma \vdash B$}
      \end{prooftree}
    \end{minipage}

    % \Gamma or A I_1
    \begin{minipage}{0.25\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$}\RightLabel{[$\vee$I$_1$]}
        \UnaryInfC{$\Gamma \vdash A \vee B$}
      \end{prooftree}
    \end{minipage}%
    % \Gamma or delta I_2
    \begin{minipage}{0.25\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash B$}\RightLabel{[$\vee$I$_2$]}
        \UnaryInfC{$\Gamma \vdash A \vee B$}
      \end{prooftree}
    \end{minipage}%
    % \Gamma or delta E
    \begin{minipage}{0.50\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \supset C$}
        \AxiomC{$\Gamma \vdash B \supset C$}
        \AxiomC{$\Gamma \vdash A \vee B$}\RightLabel{[$\vee$E$$]}
        \TrinaryInfC{$\Gamma \vdash C$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Logic rules: Intuitionistic Propositional Logic System}
  \label{fig:intuitionistic-logic}
\end{figure}

The rules of the logic system are shown in \cref{fig:intuitionistic-logic} in Gentzen style natural deduction
where $\Gamma$, $\Delta$ are contexts that keep track of assumptions. The [Ax] rule corresponds to [ID] rule while [$\rightarrow$I] and [$\rightarrow$E] correspond
to [$\supset$I] and [$\supset$E] respectively. The weakening [WKN] and contraction [CTR] rules are implicit in the term structue of \textbf{HM} type-system.
The weakening rule states that we can add unrelated assumptions to derivations without
affecting the proofs while contraction states that we can discard duplicate assumptions in our derivations and the
proof will still hold. The [$\forall$I] introduces the universal quantifier for a proposition and [$\forall$E] instantiates
the quantifier by replacing the variable with given proposition. The rules [$\forall$I] and [$\forall$E] correspond to parametric polymorphism
introduction [$\forall$I] and elimination [$\forall$E] rules in \cref{fig:hm-system}. [$\wedge$I], [$\wedge$E$_2$] and [$\wedge$E$_2$] introduces and eleminates
conjunction. Conjunction is equivalent to pairs or product types. [$\vee$I$_2$], [$\vee$I$_2$] and [$\vee$E] introduces and eleminates disjunction respectively.
Disjunction is equivalent to sum types. While, \textbf{HM} type system does not treat disjunction and conjunction types as first class citizens,
they can be Church encoded using lambda expressions\citep{pierce_tapl_2005}.

\begin{figure}[h]
  \begin{framed}
    \singlespacing
    \centering
    {\small
      \fbox{$\M(\Gamma \vdash M:\tau) = S$}
      % VAR
      \begin{minipage}{0.45\linewidth}
        \begin{flalign*}
            \M(\Gamma \vdash &x:\tau)  = \mathcal{U}(\tau, [\vec{u}/\vec{t}]\upsilon)\\
            &\text{where\qquad}\  \forall \vec{t}. \upsilon = \Gamma(x)
        \end{flalign*}
      \end{minipage}%
      % \x. M
      \begin{minipage}{0.50\linewidth}
        \begin{flalign*}
          \M(\Gamma \vdash &\lambda x. M:\tau) = S  \circ S' \\
            \text{where\qquad}\ S  &= \mathcal{U}(\tau, u_1 \rightarrow u_2)\\
            S'  &= \M(S \Gamma, x: S  u_1 \vdash M : S u_2)
          \end{flalign*}
      \end{minipage}

      % M N
      \begin{minipage}{0.45\linewidth}
        \begin{flalign*}
          \M(\Gamma \vdash &M N:\tau)  = S  \circ S' \\
          \text{where\qquad}\ S  &= \M(\Gamma \vdash M: u \rightarrow \tau)\\
          S'  &= \M(S  \Gamma \vdash N: S u)
        \end{flalign*}
      \end{minipage}%
      % let x = M in N
      \begin{minipage}{0.50\linewidth}
        \begin{flalign*}
          \M(\Gamma \vdash (&\Let{x}{M}{N}):\tau) = S  \circ S' \\
          \text{where\qquad}\ S  &= \M(\Gamma \vdash M: u)\\
                              \sigma &= \texttt{Gen}(S \Gamma, S u)\\
                              S' &= \M(S \Gamma, x:\sigma \vdash N:\tau)\\
        \end{flalign*}
      \end{minipage}

      \fbox{Auxiliary Definitions}

      \begin{minipage}{0.45\linewidth}
        \begin{flalign*}
          \texttt{Gen}(\Gamma, \tau) &= \forall \vec{t}. \tau\\
          \text{where\qquad}\ \vec{t} &= \texttt{fvs}(\tau)\backslash\texttt{fvs}(\Gamma)
        \end{flalign*}
      \end{minipage}%
      \begin{minipage}{0.45\linewidth}
        \begin{flalign*}
          \texttt{fvs}(t) &= \{t\}\\
          \texttt{fvs}(\forall \vec{t}. \tau) &= \texttt{fvs}(\tau) \backslash \vec{t}\\
          \texttt{fvs}(\Gamma) &= \bigcup_{\forall (x:\sigma) \in \Gamma} \texttt{fvs}(\sigma)
        \end{flalign*}
      \end{minipage}

    }
  \end{framed}
  \caption{Algorithm $\M$ for \textbf{HM} type system}
  \label{fig:hm-algo-m}
\end{figure}

The algorithm $\M$ is given in figure \cref{fig:hm-algo-m}. $\mathcal{U}$ is Robinson's unification
algorithm that computes the most general unifier required to unify two types
and $\texttt{Gen}(\Gamma,\tau)$ generalizes a type to a principle type scheme. All the type variables denoted by $u$ are
fresh, and hence do not shadow the existing type variables in the context. $S$ denotes substitutions that are combined using $\circ$ operator
can be applied on types or type schemes. When substitutions are applied to a context $\Gamma$, they are applied to each type scheme contained by $\Gamma$.
$\vec{t}$ is shorthand for a set of type variables $\{t_1, t_2, \dots, t_n\}$ and $\vec{t} \backslash \vec{u}$ denotes the set difference.

\section{Linear Logic}\label{sec:linear-logic}
While propositional logic deals with truth of propositions and their connectives, linear logic\citep{girard_linear_1987}
deals with availability of resources. Linear logic addresses resource and resource control problem.
The core idea is that propositions cannot be freely duplicated or discarded in contrast to intuitionistic logic.
In formal terms, the contraction and weakening rules are restricted. Propositions are modeled as resources.
In real world software applications,
if resources---such as database connections, file handles or even
in-memory shared state---are freely copied or dropped from a program context, it can introduce bugs or crashes.
If contraction and weakening are completely abandoned, the system gets overly restrictive. As a work around,
the modality operator $\oc$ is introduced for controlled use
of contraction and weakening. Wadler\citeyearpar{wadler_taste_1993} describes a refinement of
linear logic based on Girard's Logic of Unity\citeyearpar{girard_unity_1993}.
It is a disjoint union of linear logic and intuitionistic logic:
$[A]$ means that $A$ is an intuitionistic assumption and the rules of weakening and contraction are admissible,
while $\Pair{A}$ would mean that it is a linear assumption and weakening and contraction are prohibited.

\begin{figure}[h]
  \centering
  \begin{framed}
    \begin{flalign*}
      A, B, C &::= X \mid \oc A \mid A \rightspoon B \mid A \with B \mid A \otimes B \mid A \oplus B\\
      \Gamma,\Delta &::= \epsilon \mid \Gamma, \Pair{A} \mid \Gamma, [A]
    \end{flalign*}
  \end{framed}
  \caption{Grammar for Intuitionistic Linear Logic}
  \label{fig:linear-logic-syntax}
\end{figure}

In a linear logic, the assumptions can not be used more than once. In the proposition $A \rightspoon B$, the assumption $A$ cannot be used again after
it has been used to obtain $B$. This gives a new view of implication as consumption.
Due to the absense of weakening and contraction rules in this system we obtain two fragments---multiplicative and additive---of connectives.
Multiplicative conjunction is represented as $A \otimes B$, and additive conjunction and disjunction as $A \with B$ and $A \oplus B$ respectively.
The syntax of linear logic is shown in \cref{fig:linear-logic-syntax}.

\begin{figure}[h]
  \begin{framed}
    \centering
    \centering\fbox{
      Structural Rules
    }

    % []ID
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{{\color{white}$\Gamma, \Delta \vdash A$}} \RightLabel{[ID$_{[]}$]}
        \UnaryInfC{$[A] \vdash A$}
      \end{prooftree}
    \end{minipage}
  % !ID
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{{\color{white}$\Gamma, \Delta \vdash A$}} \RightLabel{[ID$_{\Pair{}}$]}
        \UnaryInfC{$\Pair{A} \vdash A$}
      \end{prooftree}
    \end{minipage}

    % EXCH
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, \Delta \vdash A$} \RightLabel{[EXCH]}
        \UnaryInfC{$\Delta, \Gamma \vdash A$}
      \end{prooftree}
    \end{minipage}
    % CTRN
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, [A], [A] \vdash B$} \RightLabel{[CTRN]}
        \UnaryInfC{$\Gamma, [A] \vdash B$}
      \end{prooftree}
    \end{minipage}
    % WKN
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash B$} \RightLabel{[WKN]}
        \UnaryInfC{$\Gamma, [A] \vdash B$}
      \end{prooftree}
    \end{minipage}

    % ! I
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$[\Gamma] \vdash A$} \RightLabel{[$\oc$I]}
        \UnaryInfC{$[\Gamma] \vdash \oc A$}
      \end{prooftree}
    \end{minipage}
    % ! E
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash \oc A$}
        \AxiomC{$\Delta, [A] \vdash B$} \RightLabel{[$\oc$E]}
        \BinaryInfC{$\Gamma, \Delta \vdash B$}
      \end{prooftree}
    \end{minipage}

    \fbox{    \centering
      Connective Rules
    }

    % -o I
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\rightspoon I]$}
        \UnaryInfC{$\Gamma \vdash A \rightspoon B$}
      \end{prooftree}
    \end{minipage}
    % -o E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash  A \rightspoon B$}
        \AxiomC{$\Delta \vdash A$} \RightLabel{$[\rightspoon E]$}
        \BinaryInfC{$\Gamma, \Delta \vdash B$}
      \end{prooftree}
    \end{minipage}
    % & I
    \begin{minipage}{.3\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$}
        \AxiomC{$\Gamma \vdash B$} \RightLabel{$[\with I]$}
        \BinaryInfC{$\Gamma \vdash A \with B$}
      \end{prooftree}
    \end{minipage}
    % & E_1
    \begin{minipage}{.3\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \with B$} \RightLabel{$[\with E_1]$}
        \UnaryInfC{$\Gamma \vdash A$}
      \end{prooftree}
    \end{minipage}
    % & E_2
    \begin{minipage}{.3\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \with B$} \RightLabel{$[\with E_2]$}
        \UnaryInfC{$\Gamma \vdash B$}
      \end{prooftree}
    \end{minipage}

    % otimes I
    \begin{minipage}{.3\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$}
        \AxiomC{$\Delta \vdash B$} \RightLabel{$[\otimes I]$}
        \BinaryInfC{$\Gamma, \Delta \vdash A \otimes B$}
      \end{prooftree}
    \end{minipage}
    % otimes E
    \begin{minipage}{.6\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \otimes B$} \RightLabel{$[\otimes E]$}
        \AxiomC{$\Delta, A, B \vdash C$}
        \BinaryInfC{$\Gamma,\Delta \vdash C$}
      \end{prooftree}
    \end{minipage}

    % oplus I_1
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$} \RightLabel{$[\oplus I_1]$}
        \UnaryInfC{$\Gamma \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    % oplus I_1
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Delta \vdash B$} \RightLabel{$[\oplus I_2]$}
        \UnaryInfC{$\Delta \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    % oplus E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \oplus B$}
        \AxiomC{$\Delta, A \vdash C$}
        \AxiomC{$\Delta, B \vdash C$}\RightLabel{$[\oplus E]$}
        \TrinaryInfC{$\Gamma, \Delta \vdash C$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Intuitionistic Linear Logic Rules}
  \label{fig:linear-logic-rules}
\end{figure}

The structural and connective logical rules for the complete system is given in \cref{fig:linear-logic-rules}.
To relax linearity constraints, exponential modality $\oc$ is used, which signifies that an assumption can
be duplicated or dropped without restriction. $\oc A$ can be thought of as {\em``as many A's as needed''}.
The intuitionistic implication $A \supset B$ can be encoded in linear logic by using the modality operator as $\oc A \rightspoon B$.
% Similarly, $A \wedge B$ can be encoded as $\oc A \with \oc B$ and $A \vee B$ as $\oc A \otimes \oc B$\citep{wadler_taste_1993}.
We clearly see that this is a more powerful system in comparison to intuitionistic logic because of its enhanced expressivity for handling
resources. However, there is an awkward asymmetry between the connectives. The absense of structural rules enables conjuntion to have
multiplicative and additive fragments. To express additive implication the use of modality is necessary.

There have been several prototype languages based on linear logic. L$^3$\citep{ahmed_l3_2007} is an intermediate
language that is built on a linear type system and supports strong updates. Lolliproc\citep{mazurak_lolliproc_2010} explores the use of
linear logic in concurrent functional programming while F$^{\circ}$\citep{mazurak_lightweight_2010} uses kinds to distinguish between
linear and unrestricted types for general purpose programming. Linear Haskell\citep{bernardy_linear_2017} is a surface level language
that overloads function arrows to incorporate linearity.

\section{Qualified Types}\label{sec:qualified-types}
Jones\citeyearpar{jones_theory_1994} proposed a general framework of incorporating predicates in the type language.
Predicates are used to build constraints on the domain of the type of a term in the language expression.
It introduces additional layer between polymorphic and monomorphic typing of programs.
Qualified types are the types that satisfy all the predicates for the term.
A modification of Damas-Milner algorithm $\mathcal{W}$ to incorporate predicates ensures that type inference
is sound and complete. Qualified types are powerful enough to expresses type classes with functional dependencies\citep{mark_type_2000},
record types\citep{gaster_polymorphic_1996}, sub-typing\citep{jones_theory_1994} and first class polymorphism\citep{jones_first-class_1997}.

\begin{figure}[h]
  \centering
  \begin{framed}
    \begin{minipage}{0.35\linewidth}
      \begin{flalign*}
        t, u  &\in \text{Type Variables}\\
        \pi,\omega &\in \text{Predicates}\\
        P, Q &\in \text{Finite Predicate Set}\\
      \end{flalign*}
    \end{minipage}%
    \begin{minipage}{0.65\linewidth}
  \begin{flalign*}
    \text{Types}\ \ \ \tau, \upsilon    &::= t \mid \iota \mid \tau \rightarrow \tau\\
    \text{Qualified Types}\ \ \ \rho    &::= \tau \mid \pi \Rightarrow \rho\\
    \text{Type Scheme}\ \ \ \sigma      &::= \rho \mid \forall t. \sigma\\
    \text{Typing Context}\ \ \Gamma     &::= \epsilon \mid \Gamma, x : \sigma\\
    \text{Expressions}\ \ \ M, N &::= x: \sigma \mid \lambda x. M \mid M N \\
                                 &\mid \Let{x}{M}{N}
  \end{flalign*}
\end{minipage}
\end{framed}
\caption{Qualified Types and Expression Language}
\label{fig:qualifed-types}
\end{figure}

The type language from \cref{fig:hm-lang} is modified to incorporate
qualified types shown in \cref{fig:qualifed-types}. $\pi$ and $\omega$ range over predicates and  $P$ and $Q$ range over finite set of predicates.
Types of the form $\pi \Rightarrow \sigma$ denote those instances of $\sigma$ that satisfy the predicate $\pi$, in general
$P \Rightarrow \sigma$ would mean the instances of $\sigma$ that satisfy all the predicates $\pi \in P$. The predicate entailment
relation $P \Rightarrow \pi$ asserts that the predicate $\pi$ can be inferred from the predicates in $P$.
The typing rules in \textbf{HM} type system are slightly modified and 2 new rules are added
as shown in \cref{fig:qualified-types-rules}. [$\Rightarrow$I] and [$\Rightarrow$E] serve the purpose of for introduction and elimination of qualified types respectively.
The new rules are \colorbox{blue!30}{highlighted}. The predicate set $P$ is threaded throughout the other rules
but is not used anywhere except [$\Rightarrow$I] and [$\Rightarrow$E].

\begin{figure}[h]
  \begin{framed}\centering
    \begin{minipage}{.45\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \sigma \in \Gamma$} \RightLabel{[VAR]}
        \UnaryInfC{$P \mid \Gamma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \sigma$}
        \AxiomC{$Q \mid \Gamma_{x}, x: \sigma \vdash N: \tau$} \RightLabel{[LET]}
        \BinaryInfC{$P,Q \mid \Gamma \vdash (\Let{x}{M}{N}) : \tau$}
      \end{prooftree}
    \end{minipage}

    % forall I
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \sigma$}\RightLabel{[$\forall$ I]}
        \AxiomC{$t \notin \texttt{fvs}(\Gamma) \cup \texttt{fvs}(P)$}
        \BinaryInfC{$P \mid \Gamma \vdash M : \forall t. \sigma$}
      \end{prooftree}
    \end{minipage}
    % forall E
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \forall t. \sigma$}\RightLabel{[$\forall$ E]}
        \UnaryInfC{$P \mid \Gamma \vdash M: [\tau / t] \sigma$}
      \end{prooftree}
    \end{minipage}

    % -> I
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{[$\rightarrow$ I]}
        \UnaryInfC{$P \mid \Gamma \vdash \lambda x. M : \tau \rightarrow \tau'$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \tau \rightarrow \tau'$}
        \AxiomC{$P \mid \Gamma \vdash N : \tau$} \RightLabel{[$\rightarrow$ E]}
        \BinaryInfC{$P \mid \Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}

    % => I
    \colorbox{blue!30}{
      \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P, \pi \mid \Gamma \vdash M : \rho$} \RightLabel{$[=> I]$}
        \UnaryInfC{$P \mid \Gamma \vdash M : \pi => \rho$}
      \end{prooftree}
    \end{minipage}
    % => E
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \pi => \rho$}
        \AxiomC{$P \Rightarrow \pi$} \RightLabel{$[=> E]$}
        \BinaryInfC{$P \mid \Gamma \vdash M: \rho$}
      \end{prooftree}
    \end{minipage}
    }
  \end{framed}
  \caption{Typing Rules for Qualified Types}
  \label{fig:qualified-types-rules}
\end{figure}

\section{Quill: Linear Logic with Qualified Types}\label{sec:quill}
Quill\citep{morris_best_2016} uses the framework of qualified types to implement a linear type system with a sound and complete type inference.
It uses a modified version of Algorithm $\M$ to compute principal types of the terms.
The key idea of Morris is to introduce two predicates for types into the language, \Un and \texttt{Fun}, with a predicate for ordering
types depending on their admittance to structural rules. The predicate $\tau \geq \tau'$ holds only if $\tau$ admits more
structural rules than $\tau'$ or, in other words, if $\tau'$ is more restricting than $\tau$.
The predicate \Un{$\tau$} implies that the type $\tau$ is unrestricted, which means it does not
contain any resources or the resources that it captures can be easily duplicated and dropped.
In traditional sense of type classes in Haskell, \Un can be thought to be a type-class with methods supporting the operation
of duplication and dropping shown in \cref{fig:un-typeclass}. In a proof theoretic setting, it would mean
that it admits weakening and contraction. The predicate \texttt{Fun $\tau$} implies that the type $\tau$ is of a function type. The function
may or may not capture resources in its closure and so the functions themselves can be of restricted or unrestricted type.
\begin{figure}[h]
  \begin{framed}\centering
    \begin{minted}[escapeinside=||,mathescape=true,xleftmargin=\parindent,linenos]{haskell}
class Un where
    dup  :: t |$\overset{!}{\rightarrow}$| (t |$\otimes$| t)
    drop :: t |$\overset{!}{\rightarrow}$| 1
    \end{minted}
  \end{framed}
  \caption{\texttt{Un} as a Typeclass}
  \label{fig:un-typeclass}
\end{figure}

Simple types such as integers and Booleans are all of unrestricted type, as
they can be duplicated or dropped freely. Program resources such as file handles, database connections
are treated as restricted or linear types as we cannot freely duplicate
or drop them. Consider a lambda expression that represents function application $\lambda f. \lambda x. f x$ and it is applied to
some function $\mathcal{F}$. The linearity of this function $\lambda x. \mathcal{F} x$
would depend on the linearity of $\mathcal{F}$. To generalize, we can say that the linearity of the lambda expression depends
on its closure. The type of $\lambda f. \lambda x. f x$ can be written as $(\tau \overset{f}{\rightarrow} \upsilon) \rightarrow \tau \overset{g}{\rightarrow}\upsilon$.
This function would be well typed only if $f$ is less restricting i.e. admits more structural rules than $g$, so to say
$\forall f g \tau \upsilon. \{f \geq g\} \Rightarrow (\tau \overset{f}{\rightarrow} \upsilon) \rightarrow \tau \overset{g}{\rightarrow}\upsilon$.

\section{Logic of Bunched Implications and $\alpha\lambda$-Calculus}\label{sec:bi}
In intuitionistic logic, the context is considered as a list or a set. In the theory of \BI{},
the context is treated as a tree. Contexts are called bunches and are syntactically
combined using 2 connectives comma ($,$) or a semicolon ($;$). The logic of \BI{} combines
substructural logic with intuitionistic logic by permitting contexts connected with
semicolon to undergo contraction and weakening while the context connected with comma
are prohibited to undergo contraction and weakening. Comma and semicolon do not distribute over each other.
Thus for propositions $A$, $B$ and $C$: $A,(B;C) \neq A, B ; A,C$ and $A;(B,C) \neq A;B,A;C$.

\cite{ohearn_logic_1999} introduce 2 kinds of arrows
and use them depending on the connectives used in the context. A multiplicative implication ($\sepimp$)
is used when the context is connected with a comma and an additive implication ($\shimp$) is used when the
context is connected using semicolon. This gives rise to two introduction rules for implication:
\begin{framed}
\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\sepimp I]$}
    \UnaryInfC{$\Gamma \vdash A \sepimp B$}
  \end{prooftree}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma; A \vdash B$} \RightLabel{$[\shimp I]$}
    \UnaryInfC{$\Gamma \vdash A \shimp B$}
  \end{prooftree}
\end{minipage}
\end{framed}

$\Gamma, A$ cannot under go weakening or contraction to duplicate
or get rid of either $A$ or $\Gamma$. This hints to a notion that multiplicative implication ($\sepimp$)
exhibits property of the linear implication ($\rightspoon$). The linear implication cannot however
be directly converted to a multiplicative implication (or vice versa) as the latter does not exhibit properties of
counting the number of uses of its arguments. Also, in contrast to linear logic, the multiplicative implication
cannot be converted into an additive implication as there is there is no modality introduced in the system.
The logic of \BI{} combines the additive logic i.e. classical intuitionistic logic with the multiplicative side
i.e. intuitionistic substructural logic. The promise of this logic system is that the multiplicative side can
be used to model the behavior of resources in the programming language while the additive side would help the
programmers express the non-resource intuitionistic parts.
\begin{figure}[h]
  \begin{framed}
  \begin{flalign*}
    A, B, C &::= A \sepimp B \mid A \shimp B \mid A \with B \mid A \otimes B \mid A \oplus B\\
    \Gamma,\Delta &::= \{\}_m \mid \{\}_A \mid \Gamma, A \mid \Gamma ; A
  \end{flalign*}
\end{framed}
  \caption{Grammar for Logic of \BI{}}
  \label{fig:grammar-bi}
\end{figure}

\begin{figure}[h]
  \begin{framed}\centering
    \fbox{Structural}
    %ID
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{} \RightLabel{[ID]}
        \UnaryInfC{$A \vdash A$}
      \end{prooftree}
    \end{minipage}%
    %WKN
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma(\Delta) \vdash A$} \RightLabel{[WKN]}
        \UnaryInfC{$\Gamma(\Delta;\Delta') \vdash A$}
      \end{prooftree}
    \end{minipage}%
    %CTR
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma(\Delta;\Delta) \vdash A$} \RightLabel{[CTR]}
        \UnaryInfC{$\Gamma(\Delta) \vdash A$}
      \end{prooftree}
    \end{minipage}

    \fbox{Multiplicative Connectives}

    % -*I
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, A \vdash B$} \RightLabel{[$\sepimp$I]}
        \UnaryInfC{$\Gamma \vdash A \sepimp B$}
      \end{prooftree}
    \end{minipage}%
    % -* E
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \sepimp B$}
        \AxiomC{$\Delta \vdash A$} \RightLabel{[$\sepimp$E]}
        \BinaryInfC{$\Gamma,\Delta \vdash B$}
      \end{prooftree}
    \end{minipage}

    % \otimes I
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$}
        \AxiomC{$\Delta \vdash B$} \RightLabel{$[\otimes I]$}
        \BinaryInfC{$\Gamma, \Delta \vdash A \otimes B$}
      \end{prooftree}
    \end{minipage}%
    % \otimes E
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma(A, B) \vdash C $} \RightLabel{$[\otimes E]$}
        \AxiomC{$\Delta \vdash A \otimes B$}
        \BinaryInfC{$\Gamma(\Delta) \vdash C$}
      \end{prooftree}
    \end{minipage}

    \fbox{Additive Connectives}

    % ->> I
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma; A \vdash B$} \RightLabel{[$\shimp$I]}
        \UnaryInfC{$\Gamma \vdash A \shimp B$}
      \end{prooftree}
    \end{minipage}%
    % ->> E
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \shimp B$}
        \AxiomC{$\Delta \vdash A$} \RightLabel{[$\shimp$E]}
        \BinaryInfC{$\Gamma;\Delta \vdash B$}
      \end{prooftree}
    \end{minipage}

    % \with I
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$}
        \AxiomC{$\Delta \vdash B$} \RightLabel{[$\with$I]}
        \BinaryInfC{$\Gamma; \Delta \vdash A \with B$}
      \end{prooftree}
    \end{minipage}%
    % \with E
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma(A; B) \vdash C $} \RightLabel{[$\with$E]}
        \AxiomC{$\Delta \vdash A \with B$}
        \BinaryInfC{$\Gamma(\Delta) \vdash C$}
      \end{prooftree}
    \end{minipage}

    % \oplus I_1
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$} \RightLabel{[$\oplus$I$_1$]}
        \UnaryInfC{$\Gamma \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    % \oplus I_1
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Delta \vdash B$} \RightLabel{[$\oplus$I$_2$]}
        \UnaryInfC{$\Delta \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    % \oplus E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \oplus B$}
        \AxiomC{$\Delta(A) \vdash C$}
        \AxiomC{$\Delta(B) \vdash C$}\RightLabel{[$\oplus$E]}
        \TrinaryInfC{$\Gamma(\Delta) \vdash C$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Rules for Logic of \BI{}}
  \label{fig:rules-bi}
\end{figure}

The complete grammar for logic of \BI{} is shown in \cref{fig:grammar-bi}. The contexts $\{\}_m$ represents a multiplicative empty context
while the $\{\}_a$ represents an additive empty context. The rules for the logic system are shown in \cref{fig:rules-bi}.
$\Gamma(\Delta)$ means that $\Delta$ is a sub-tree within $\Gamma$ (\cref{chp:qub-language} for more details).

$\alpha\lambda$-calculus\citep{ohearn_resource_1999, pym_semantics_2002}
is the Curry-Howard interpretation of the logic of \BI{}. It views implication in terms of sharing rather than
the number of times it is used. It introduces 2 kinds of arrows by modifying the the syntax of lambda calculus:
\begin{enumerate}
\item $\sepimp$: Functions do not share resources with their arguments
\item $\shimp$ : Functions share resources with their arguments
\end{enumerate}

The types and terms of $\alpha\lambda$-calculus are shown in \cref{fig:al-cal-types}.
The structural and connective rules for $\alpha\lambda$-calculus are summarized in \cref{fig:bi-typing-rules}.
We have left out the terms for additive and multiplicative conjunction and additive disjunction for the
sake of simplicity.

\begin{figure}[h]
\begin{framed}
  \begin{flalign*}
                       t, u,          &\in \text{Type Variables}\\
   \text{Context}\ \ \ \Gamma, \Delta &::= \{\}_m \mid \{\}_a \mid x:\tau \mid \Gamma, \Delta \mid \Gamma;\Delta\\
    \text{Types}\ \ \  \tau, \upsilon &::= t \mid \iota \mid \tau \shimp \tau \mid \tau \sepimp \tau \\
    \text{Expressions}\ \ \ M, N      &::= x \mid \lambda x. M \mid \alpha x. M \mid M N
  \end{flalign*}
\end{framed}
\caption{$\alpha\lambda$-Calculus Types and Terms}
\label{fig:al-cal-types}
\end{figure}

\begin{figure}[h]
  \begin{framed}\centering
    % var
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \tau \in \Gamma$} \RightLabel{[VAR]}
        \UnaryInfC{$\Gamma \vdash x : \tau $}
      \end{prooftree}
    \end{minipage}%
    % CTRN
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma; \Gamma \vdash M:\tau$} \RightLabel{[CTRN]}
        \UnaryInfC{$\Gamma \vdash M:\tau$}
      \end{prooftree}
    \end{minipage}%
    % WKN
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M:\tau$} \RightLabel{[WKN]}
        \UnaryInfC{$\Gamma;\Delta \vdash M:\tau $}
      \end{prooftree}
    \end{minipage}

    % -* I
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{[$\sepimp$I]}
        \UnaryInfC{$\Gamma \vdash \lambda  x. M : \tau \sepimp \tau'$}
      \end{prooftree}
    \end{minipage}%
    % -* E
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \sepimp \tau' \ \ \ \ \
          \Delta \vdash N : \tau$} \RightLabel{[$\sepimp$E]}
        \UnaryInfC{$\Gamma,\Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}

    % -> I
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}; x: \tau \vdash M : \tau'$} \RightLabel{[$\shimp$I]}
        \UnaryInfC{$\Gamma \vdash \alpha  x. M : \tau \shimp \tau'$}
      \end{prooftree}
    \end{minipage}%
    % -> E
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \shimp \tau' \ \ \ \ \
          \Delta \vdash N : \tau$} \RightLabel{[$\shimp$E]}
        \UnaryInfC{$\Gamma;\Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}

  \caption{Typing Rules for $\alpha\lambda$-Calculus}
  \label{fig:bi-typing-rules}
\end{figure}

The logic of \BI{} patches up the awkward asymmetry experienced in linear logic. The multiplicative conjunction $\otimes$ has a right adjoint
counterpart as $\sepimp$ while additive conjunction $\with$ has a right adjoint counterpart $\shimp$.
In other words, $A \otimes B \vdash C$ iff $A \vdash B \sepimp C$ and $A \with B \vdash C$ iff $A \vdash B \shimp C$.
This relieves us from introducing modality into the system.

Due to the rules of $\alpha\lambda$-calculus $f: \tau \sepimp \tau'; x:\tau \nvdash f x:\tau'$,
as $f$ needs an argument that does not share any resources with its context.
The term $\lambda x. \alpha f. f x x: \tau \sepimp (\tau \shimp \tau \shimp \tau') \shimp \tau'$ is a typable term in
$\alpha\lambda$-calculus as shown in \cref{fig:multi-bi-example}. This illustrates the difference between logic of \BI{} and linear logic
as even tough the argument is separate from the function, it may be used twice. In linear logic this expression will be ill-typed.

\begin{figure}[h]
  \begin{framed}
    \begin{minipage}{1.0\linewidth}
      \begin{prooftree}
        \AxiomC{}\RightLabel{[VAR]}
        \UnaryInfC{$f:\tau \shimp \tau \shimp \tau' \vdash f: \tau \shimp \tau \shimp \tau'$}

        \AxiomC{}\RightLabel{[VAR]}
        \UnaryInfC{$x:\tau \vdash x:\tau$} \RightLabel{[$\shimp$E]}
        \BinaryInfC{$f:\tau \shimp \tau \shimp \tau'; x:\tau \vdash f x: \tau \shimp \tau'$}

        \AxiomC{}\RightLabel{[VAR]}
        \UnaryInfC{$x:\tau \vdash x: \tau$}\RightLabel{[$\shimp$E]}

        \BinaryInfC{$x:\tau; f:\tau \shimp \tau \shimp \tau';x:\tau \vdash f x x: \tau'$}\RightLabel{[CTRN]}
        \UnaryInfC{$x:\tau; f:\tau \shimp \tau \shimp \tau' \vdash f x x: \tau'$} \RightLabel{[$\shimp$I]}
        \UnaryInfC{$x:\tau \vdash \lambda x. f x x: (\tau \shimp \tau \shimp \tau') \shimp  \tau'$}\RightLabel{[$\sepimp$I]}
        \UnaryInfC{$\vdash \lambda x. \alpha f. f x x: \tau \sepimp (\tau \shimp \tau \shimp \tau') \shimp \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Multiplicative Argument used Twice in $\alpha\lambda$-calculus}
  \label{fig:multi-bi-example}
\end{figure}

The use of logic of \BI{} as a type inference system is an active area of research in functional programming language implementation.
There has been research on building proof theoretic and semantic models of the logic system\citep{pym_semantics_2002}. The use of bunches instead of
lists as typing environment makes it difficult to have a direct implementation of the type inference algorithm. \cite{atkey_lambda_sep_2004}
designs $\lambda_{sep}$ calculus which is based on the affine variant of $\alpha\lambda$-calculus focusing on separation of resources used by objects.
\cite{collinson_bunched_2005} designs a polymorphic variant of $\alpha\lambda$-calculus.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku"
%%% End:
