\chapter{Background Work}\label{chp:background-work}
\section{Hindley-Milner Type System and Type Inference Algorithm}\label{hm-system}

Hindley-Milner (\textbf{HM}) type system \citeyearpar{milner_theory_1978} for lambda calculus extended with parametric polymorphism or restricted version
of System F \citep{girard_proofs_1989} forms the basis many modern functional programming languages such as Haskell, ML, etc.
The type language contains type variables, primitive types (such as integers, floats), the type constructor ($\rightarrow$)---
which constructs function types---and type scheme ($\sigma$) as shown in \cref{fig:hm-lang}.
The expression language contains variables, lambda expressions and applications extended with a
polymorphic \texttt{let} construct. Type inference algorithm $\mathcal{W}$ \citep{damas_principal_1982} and its variant
type checking algorithm $\mathcal{M}$ \citep{lee_proofs_1998} is decidable in the sense, the algorithm always completes with a success or failure.
The algorithms also guarantee a most general typing scheme or principal types for an expression.

\begin{figure}[h]
\begin{framed}
  \begin{flalign*}
                       t, u, \upsilon &\in \text{Type Variables}\\
    \text{Types}\ \ \  \tau           &::= t \mid \iota \mid \tau \rightarrow \tau\\
    \text{Typing Scheme}\ \ \  \sigma &::= \tau \mid \forall t. \tau\\
    \text{Typing Context}\ \ \ \Gamma &::= \epsilon \mid \Gamma, x:\sigma\\
         \text{Expressions}\ \ \ M, N &::= x \mid \lambda x. M \mid M N \mid \Let{x}{M}{N}
  \end{flalign*}
\end{framed}
\caption{Hindley-Milner Type and Expression Language}
\label{fig:hm-lang}
\end{figure}

Robinson's \citeyearpar{robinson_machine-oriented_1965} unification algorithm plays a key role
in computation of well-formed principal types. Its purely syntactic approach in creating
substitutions to unify types keeps the complete process elegant.
Algorithm $\mathcal{M}$ works in an interesting way where the types of all well-typed terms can be
inferred automatically and if types are specified, the same algorithm can be used
to verify that the specified type of expression term matches the actual type. The same
can be obtained using algorithm $\mathcal{W}$ with an additional machinery of
computing equality over types.

\begin{figure}[h]
  \begin{framed}
    % var
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \sigma \in \Gamma$} \RightLabel{[VAR]}
        \UnaryInfC{$\Gamma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma$}
        \AxiomC{$\Gamma_{x}, x: \sigma \vdash N: \tau$} \RightLabel{[LET]}
        \BinaryInfC{$\Gamma \vdash (\Let{x}{M}{N}) : \tau$}
      \end{prooftree}
    \end{minipage}
    % forall I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma$}\RightLabel{[$\forall$ I]}
        \AxiomC{$t \notin \texttt{fvs}(\Gamma)$}
        \BinaryInfC{$\Gamma \vdash M : \forall t. \sigma$}
      \end{prooftree}
    \end{minipage}
    % forall E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma$}
        \AxiomC{$(\sigma' \sqsubseteq \sigma)$}\RightLabel{[$\forall$ E]}
        \BinaryInfC{$\Gamma \vdash M : \sigma'$}
      \end{prooftree}
    \end{minipage}
    % -> I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{[$\rightarrow$ I]}
        \UnaryInfC{$\Gamma \vdash \lambda x. M : \tau \rightarrow \tau'$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \rightarrow \tau'$}
        \AxiomC{$\Gamma \vdash N : \tau$} \RightLabel{[$\rightarrow$ E]}
        \BinaryInfC{$\Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Typing Rules for \textbf{HM} Type System}
  \label{fig:hm-system}
\end{figure}

The rules for type inference for \textbf{HM} type system are shown in \cref{fig:hm-system}. $\Gamma$ is the
collection of assumptions or context in which the expression is typed. It can be thought of as a collection--list or set--of
an ordered pair of identifier and its type scheme. The [VAR] rule is tautology or a simple
lookup of the term variable $x$ in the context $\Gamma$.  [$\rightarrow$I] and [$\rightarrow$E] are rules for typing
lambda terms and application respectively. We also include the rules for parametric polymorphism where
[$\forall$I] generalizes the type scheme by adding implicit universal quantifiers and [$\forall$E] generates an instance
of the type scheme by substituting free type variables. It is worthwhile to note that when we generalize over types the rule
[$\forall$I] has a side condition that ensures the new type variable introduced should not be free in the existing typing context.
The $\texttt{fvs}(\Gamma)$ denotes free type variables in $\Gamma$. The [LET] rules allows implicit parametric polymorphism.
For example, the expression, \HaskellF{g = |$\lambda$|f. (f True, f 1)} is ill-typed as type unification for \HaskellF{f} with expressions
\HaskellF{f True : Bool |$\rightarrow u_1$|} and \HaskellF{f 1 : Int |$ \rightarrow u_2$|} is not possible.
However, there indeed exists a polymorphic type \HaskellF{|$\forall u_1. u_1 \rightarrow u_1$|}
that types \HaskellF{f}. The \texttt{let} construct makes this possible. The expression \HaskellF{g} can be defined
as \HaskellF{g = let f = |$\lambda$| x. x in (f True, f 1)}. The type of the expression \HaskellF{f} is now computed
as \HaskellF{f: |$\forall u_1$|. |$u_1 \rightarrow u_1$|}, using [$\rightarrow$I] and [$\forall$I] rules and \HaskellF{g} is assigned a type \HaskellF{(Bool, Int)}.

\begin{figure}[h]
  \centering
  \begin{framed}
  \begin{flalign*}
    \Gamma, \Delta, \Phi ::= x \mid \Gamma \supset \Delta \mid \forall x. \Phi
  \end{flalign*}
\end{framed}
\caption{Grammar for Intuitionistic Logic}
\label{fig:intu-logic-grammar}
\end{figure}

\begin{figure}[h]\centering
  \begin{framed}
    % ID
    \begin{minipage}{0.20\linewidth}
      \begin{prooftree}
        \AxiomC{${\color{white}\Phi\Gamma\Phi}$}\RightLabel{[Ax]}
        \UnaryInfC{$\Phi \vdash \Phi $}
      \end{prooftree}
    \end{minipage}%
    % WKN
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash \Phi$}\RightLabel{[WKN]}
        \UnaryInfC{$\Gamma, \Delta \vdash \Phi$}
      \end{prooftree}
    \end{minipage}%
    % CTR
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, \Gamma \vdash \Phi $}\RightLabel{[CTR]}
        \UnaryInfC{$\Gamma \vdash \Phi $}
      \end{prooftree}
    \end{minipage}

    % \forall I
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Phi$}
        \AxiomC{$x \notin \Phi$}\RightLabel{[$\forall$I]}
        \BinaryInfC{$\forall x. \Phi$}
      \end{prooftree}
    \end{minipage}%
    % \forall E
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\forall x. \Phi$}
        \AxiomC{$\Gamma$}\RightLabel{[$\forall$E]}
        \BinaryInfC{$\Phi[x/\Gamma]$}
      \end{prooftree}
    \end{minipage}

    % -> I
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash \Delta$}
        \AxiomC{$\Delta \vdash \Phi $}\RightLabel{[$\supset$I]}
        \BinaryInfC{$\Gamma \vdash \Delta \supset \Phi$}
      \end{prooftree}
    \end{minipage}%
    % -> E
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash \Delta \supset \Phi$}
        \AxiomC{$\Gamma \vdash \Delta$}\RightLabel{[$\supset$E]}
        \BinaryInfC{$\Gamma \vdash \Phi $}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Logic rules: Implication fragment of second order Intuitionistic Propositional Logic}
  \label{fig:intuitionistic-logic}
\end{figure}

The Curry-Howard correspondence of \textbf{HM} type system
corresponds to the second order implication fragment of intuitionistic propositional logic.
The grammar of intuitionistic logic is shown in \cref{fig:intu-logic-grammar} where $\Gamma \supset \Delta$ denotes implication.
The rules of the logic system are shown in \cref{fig:intuitionistic-logic} in Gentzen style natural deduction
where $\Gamma$, $\Delta$ and $\Phi$ are propositions. The [Ax] rule corresponds to [ID] rule while [$\rightarrow$I] and [$\rightarrow$E] correspond
to [$\supset$I] and [$\supset$E] respectively. The structural rules of weakening [WKN] and contraction [CTR] are implicitly obeyed
by \textbf{HM} type-system. The weakening rule states that we can add unrelated assumptions to derivations without
affecting the proofs while contraction states that we can discard duplicate assumptions in our derivations and the
proof will still hold. The [$\forall$I] introduces the universal quantifier for a proposition and [$\forall$E] instantiates
the proposition by replacing the free variable with another proposition. The rules [$\forall$I] and [$\forall$E] correspond to parametric polymorphism
introduction [$\forall$I] and elimination [$\forall$E] rules in \cref{fig:hm-system}

\begin{figure}[h]
  \begin{framed}
    \singlespacing
    \centering
    {\small
      \fbox{$\M(\Gamma \vdash M:\tau) = S$}
      % VAR
      \begin{minipage}{0.45\linewidth}
        \begin{flalign*}
            \M(\Gamma \vdash &x:\tau)  = \mathcal{U}(\tau, [\vec{u}/\vec{t}]\upsilon)\\
            &\text{where\qquad}\  \forall \vec{t}. \upsilon = \Gamma(x)
        \end{flalign*}
      \end{minipage}%
      % \x. M
      \begin{minipage}{0.50\linewidth}
        \begin{flalign*}
          \M(\Gamma \vdash &\lambda x. M:\tau) = S  \circ S' \\
            \text{where\qquad}\ S  &= \mathcal{U}(\tau, u_1 \rightarrow u_2)\\
            S'  &= \M(S \Gamma, x: S  u_1 \vdash M : S u_2)
          \end{flalign*}
      \end{minipage}

      % M N
      \begin{minipage}{0.45\linewidth}
        \begin{flalign*}
          \M(\Gamma \vdash &M N:\tau)  = S  \circ S' \\
          \text{where\qquad}\ S  &= \M(\Gamma \vdash M: u \rightarrow \tau)\\
          S'  &= \M(S  \Gamma \vdash N: S u)
        \end{flalign*}
      \end{minipage}%
      % let x = M in N
      \begin{minipage}{0.50\linewidth}
        \begin{flalign*}
          \M(\Gamma \vdash (&\Let{x}{M}{N}):\tau) = S  \circ S' \\
          \text{where\qquad}\ S  &= \M(\Gamma \vdash M: u)\\
                              \sigma &= \texttt{Gen}(S \Gamma, S u)\\
                              S' &= \M(S \Gamma, x:\sigma \vdash N:\tau)\\
        \end{flalign*}
      \end{minipage}

      \fbox{Auxiliary Definitions}

      \begin{minipage}{0.45\linewidth}
        \begin{flalign*}
          \texttt{Gen}(\Gamma, \tau) &= \forall \vec{t}. \tau\\
          \text{where\qquad}\ \vec{t} &= \texttt{fvs}(\tau)\backslash\texttt{fvs}(\Gamma)
        \end{flalign*}
      \end{minipage}%
      \begin{minipage}{0.45\linewidth}
        \begin{flalign*}
          \texttt{fvs}(t) &= \{t\}\\
          \texttt{fvs}(\forall \vec{t}. \tau) &= \texttt{fvs}(\tau) \backslash \vec{t}\\
          \texttt{fvs}(\Gamma) &= \bigcup_{\forall (x:\sigma) \in \Gamma} \texttt{fvs}(\sigma)
        \end{flalign*}
      \end{minipage}

    }
  \end{framed}
  \caption{Algorithm $\M$ for \textbf{HM} type system}
  \label{fig:hm-algo-m}
\end{figure}

The algorithm $\M$ is given in figure \cref{fig:hm-algo-m}. $\mathcal{U}$ is the Robinson's unification
algorithm that computes the most general unifier required to unify two types
and $\texttt{Gen}(\Gamma,\tau)$ generalizes a type to type scheme. All the type variables denoted by $u$ are
fresh and do not shadow the existing type variables in the context. $S$ denotes substitutions that are combined using $\circ$ operator
can be applied on types or type schemes. When substitutions are applied to a context $\Gamma$, they are applied to each type scheme contained by $\Gamma$.
$\vec{t}$ is shorthand for a set of type variables $\{t_1, t_2, \dots, t_n\}$ and $\vec{t} \backslash \vec{u}$ denotes the set difference.

\section{Linear Logic}\label{sec:linear-logic}
While propositional logic deals with truth of propositions and their connectives, linear logic \citep{girard_linear_1987} deals with availability of resources.
Linear logic promises to help cope with the resource and resource control problem.
The core idea is that propositions cannot be freely duplicated or discarded in contrast to intuitionistic logic.
In formal terms, the contraction and weakening logical rules are restricted.
This instigates a view of propositions that behave like resources. In real world software applications,
resources may not be freely copied or dropped from a program context.
While handling entities like database connections, file handles or even
in-memory shared state can introduce bugs in
industry grade software. Linear logic is proposed to be a remedy for
these problems. If contraction and weakening is completely abandoned,
the system gets overly restrictive. To work around, this modality operator $\oc$ is introduced which
allows intuitionistic rules in fragments. Wadler describes a refinement of
linear logic based on Girard's Logic of Unity \citep{wadler_taste_1993, girard_unity_1993}.
It can be considered as a disjoint union of linear logic and intuitionistic logic.
$[A]$ would mean that it is an intuitionistic assumption and the rules of weakening and contraction are not restricted in this
fragment, while $\Pair{A}$ means that it is a linear assumption where weakening and contraction is prohibited.

In a linear logic setting, the assumptions can not be used more than once. This instigates
a new view of implication which is different from intuitionistic logic. The implication obtains a meaning of
consume which is represented as $A \rightspoon B$ where the assumption $A$ cannot be used again after
it has been used to obtain $B$. Its logical rules is given by [$\rightspoon$I] and [$\rightspoon$E].
Similarly there are two kinds of connectives, multiplicative and additive that
arise in this logic system. More symbols are added in place of $\plus$ and $\times$.
Multiplicative conjunction is represented as $\otimes$ , and additive conjunction and disjunction ($\with $ and $\oplus$).
The structural and connective logical rules for the system is given in \cref{fig:linear-logic-rules}.

\begin{figure}[h]
  \centering
  \begin{framed}
    \begin{flalign*}
      A, B, C ::= X \mid \oc A \mid A \rightspoon B \mid A \with B \mid A \otimes B \mid A \oplus B
    \end{flalign*}
  \end{framed}
  \caption{Grammar for Intuitionistic Linear Logic}
\end{figure}

\begin{figure}[h]
  \begin{framed}

    \centering\fbox{    \centering
      Structural Rules
    }

    % []ID
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{{\color{white}$\Gamma, \Delta \vdash A$}} \RightLabel{[ID$_{[]}$]}
        \UnaryInfC{$[A] \vdash A$}
      \end{prooftree}
    \end{minipage}
  % !ID
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{{\color{white}$\Gamma, \Delta \vdash A$}} \RightLabel{[ID$_{\Pair{}}$]}
        \UnaryInfC{$\Pair{A} \vdash A$}
      \end{prooftree}
    \end{minipage}

    % EXCH
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, \Delta \vdash A$} \RightLabel{[EXCH]}
        \UnaryInfC{$\Delta, \Gamma \vdash A$}
      \end{prooftree}
    \end{minipage}
    % CTRN
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, [A], [A] \vdash B$} \RightLabel{[CTRN]}
        \UnaryInfC{$\Gamma, [A] \vdash B$}
      \end{prooftree}
    \end{minipage}
    % WKN
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash B$} \RightLabel{[WKN]}
        \UnaryInfC{$\Delta, [A] \vdash B$}
      \end{prooftree}
    \end{minipage}

    % ! I
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$[\Gamma] \vdash A$} \RightLabel{[$\oc$I]}
        \UnaryInfC{$[\Gamma] \vdash \oc A$}
      \end{prooftree}
    \end{minipage}
    % ! E
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash \oc A$}
        \AxiomC{$\Delta, [A] \vdash B$} \RightLabel{[$\oc$E]}
        \BinaryInfC{$\Gamma, \Delta \vdash B$}
      \end{prooftree}
    \end{minipage}

    \fbox{    \centering
      Connective Rules
    }

    % -o I
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\rightspoon I]$}
        \UnaryInfC{$\Gamma \vdash A \rightspoon B$}
      \end{prooftree}
    \end{minipage}
    % -o E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash  A \rightspoon B$}
        \AxiomC{$\Delta \vdash A$} \RightLabel{$[\rightspoon E]$}
        \BinaryInfC{$\Gamma, \Delta \vdash B$}
      \end{prooftree}
    \end{minipage}
    % & I
    \begin{minipage}{.3\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$}
        \AxiomC{$\Gamma \vdash B$} \RightLabel{$[\with I]$}
        \BinaryInfC{$\Gamma \vdash A \with B$}
      \end{prooftree}
    \end{minipage}
    % & E_1
    \begin{minipage}{.3\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \with B$} \RightLabel{$[\with E_1]$}
        \UnaryInfC{$\Gamma \vdash A$}
      \end{prooftree}
    \end{minipage}
    % & E_2
    \begin{minipage}{.3\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \with B$} \RightLabel{$[\with E_2]$}
        \UnaryInfC{$\Gamma \vdash B$}
      \end{prooftree}
    \end{minipage}

    % otimes I
    \begin{minipage}{.3\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$}
        \AxiomC{$\Delta \vdash B$} \RightLabel{$[\otimes I]$}
        \BinaryInfC{$\Gamma, \Delta \vdash A \otimes B$}
      \end{prooftree}
    \end{minipage}
    % otimes E
    \begin{minipage}{.6\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \otimes B$} \RightLabel{$[\otimes E]$}
        \AxiomC{$\Gamma, A, B \vdash C$}
        \BinaryInfC{$\Gamma \vdash C$}
      \end{prooftree}
    \end{minipage}

    % oplus I_1
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$} \RightLabel{$[\oplus I_1]$}
        \UnaryInfC{$\Gamma \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    % oplus I_1
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Delta \vdash B$} \RightLabel{$[\oplus I_2]$}
        \UnaryInfC{$\Delta \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    % oplus E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \oplus B$}
        \AxiomC{$\Delta, A \vdash C$}
        \AxiomC{$\Delta, B \vdash C$}\RightLabel{$[\oplus E]$}
        \TrinaryInfC{$\Gamma, \Delta \vdash C$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Intuitionistic Linear Logic Rules}
  \label{fig:linear-logic-rules}
\end{figure}

To relax linearity constraints, exponential modality $\oc$ is used, which signifies that an assumption can
be duplicated or dropped without restriction. $\oc A$ can be thought of as {\em``as many A's as needed''}.
The intuitionistic $A \rightarrow B$ can be encoded in linear logic by using the modality operator as $\oc A \rightspoon B$.
Similarly $A \plus B$ would be represented as $\oc A \otimes \oc B$ and $A \times B$ would be represented as $A \with B$ \citep{wadler_taste_1993}.
We clearly see that this is a much powerful system in comparison to intuitionistic logic because of its enhanced expressivity with
resources and propositions to have different treatment. However, there is an awkward asymmetry between the multiplicative
and additive constructs. The multiplicative connectives follow the intuitionistic logic implication connectives but there is no notion of
implication for additive connectives. In other words, $\rightspoon$ is a right adjoint
for multiplicative $\otimes$ but there is no such right adjoint counter part for additive $\with$.

There have been research efforts in the past to build prototype languages that have type systems based on linear logic. L$^3$\citep{ahmed_l3_2007} is an intermediate
language that is built on a linear type system and supports strong updates. Linear Haskell \citep{bernardy_linear_2017} is a surface level language
that overloads function arrows to incorporate linearity.

\section{Qualified Types}\label{sec:qualified-types}
Jones \citeyearpar{jones_theory_1994} proposed a general framework of incorporating predicates in the type language.
Predicates are used to build constraints on the domain of the type of a term in the language expression.
It introduces additional layer between polymorphic and monomorphic typing of programs.
A modification of Damas-Milner algorithm $\mathcal{W}$ to incorporate predicates ensures that type inference
is sound and complete. The types that satisfy all the predicates are called qualified types for the term.
Qualified types are powerful enough to expresses type classes with functional dependencies \citep{mark_type_2000},
record types, sub-typing \citep{jones_theory_1994} and first class polymorphism \citep{jones_first-class_1997}.

The type language is modified from \cref{fig:hm-lang} to incorporate
qualified types shown in \cref{fig:qualifed-types}. $\pi$ and $\omega$ range over predicates and  $P$ and $Q$ range over finite set of predicates.
The types of the form $\pi => \sigma$ denote those instances of $\sigma$ that satisfy the predicate $\pi$, in general
$P => \sigma$ would mean the instances of $\sigma$ that satisfy all the predicates $\pi \in P$. The predicate entailment
relation $P \Vdash \pi$ asserts that the predicate $\pi$ can be inferred from the predicates in $P$.
The typing rules in \textbf{HM} type system are slightly modified and 2 new rules are added
as shown in \cref{fig:qualified-types-rules}. [$=>$I] and [$=>$E] serve the purpose of for introduction and elimination of qualified types respectively.
The changes to the \textbf{HM} type system are \colorbox{blue!30}{highlighted}. The predicate set $P$ is threaded throughout the other rules
but are not used anywhere except [$=>$I] and [$=>$E]. % The system not only remains sound and complete with respect to \textbf{HM} type system but
% also makes it more flexible {\color{red} i need more words here flexible how? powerful how?}.

\begin{figure}[h]
  \centering
  \begin{framed}
  \begin{flalign*}
                        t, u, \upsilon  &\in \text{Type Variables}\\
                             \pi,\omega &\in \text{Predicates}\\
                                   P, Q &\in \text{Finite Predicate Set}\\
    \text{Types}\ \ \ \tau              &::= t \mid \iota \mid \tau \rightarrow \tau\\
    \text{Qualified Types}\ \ \ \rho    &::= \tau \mid \pi => \rho\\
    \text{Type Scheme}\ \ \ \sigma      &::= \rho \mid \forall t. \sigma\\
           \text{Expressions}\ \ \ M, N &::= x: \sigma \mid \lambda x. M \mid M N \mid \Let{x}{M}{N}
  \end{flalign*}
\end{framed}
\caption{Qualified Types and Expression Language}
\label{fig:qualifed-types}
\end{figure}

\begin{figure}[h]
  \begin{framed}\centering
    \begin{minipage}{.45\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \sigma \in \Gamma$} \RightLabel{[VAR]}
        \UnaryInfC{$P \mid \Gamma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \sigma$}
        \AxiomC{$Q \mid \Gamma_{x}, x: \sigma \vdash N: \tau$} \RightLabel{[LET]}
        \BinaryInfC{$P,Q \mid \Gamma \vdash (\Let{x}{M}{N}) : \tau$}
      \end{prooftree}
    \end{minipage}

    % forall I
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \sigma$}\RightLabel{[$\forall$ I]}
        \AxiomC{$t \notin \texttt{fvs}(\Gamma) \cup \texttt{fvs}(P)$}
        \BinaryInfC{$P \mid \Gamma \vdash M : \forall t. \sigma$}
      \end{prooftree}
    \end{minipage}
    % forall E
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \forall t. \sigma$}\RightLabel{[$\forall$ E]}
        \UnaryInfC{$P \mid \Gamma \vdash M: [\tau / t] \sigma$}
      \end{prooftree}
    \end{minipage}

    % -> I
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{[$\rightarrow$ I]}
        \UnaryInfC{$P \mid \Gamma \vdash \lambda x. M : \tau \rightarrow \tau'$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \tau \rightarrow \tau'$}
        \AxiomC{$P \mid \Gamma \vdash N : \tau$} \RightLabel{[$\rightarrow$ E]}
        \BinaryInfC{$P \mid \Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}

    % => I
    \colorbox{blue!30}{
      \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P, \pi \mid \Gamma \vdash M : \rho$} \RightLabel{$[=> I]$}
        \UnaryInfC{$P \mid \Gamma \vdash M : \pi => \rho$}
      \end{prooftree}
    \end{minipage}
    % => E
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \pi => \rho$}
        \AxiomC{$P \Vdash \pi$} \RightLabel{$[=> E]$}
        \BinaryInfC{$P \mid \Gamma \vdash M: \rho$}
      \end{prooftree}
    \end{minipage}
    }
  \end{framed}
  \caption{Typing Rules for Qualified Types}
  \label{fig:qualified-types-rules}
\end{figure}

\section{Linear logic with Qualified Types: Quill}\label{sec:quill}
Quill \citep{morris_best_2016} implements a linear type system with a sound and complete type inference using qualified types.
It uses a modified version of Algorithm $\M$ to compute principal types of the terms.
% In practice, due to higher ordered kind system, it may not be possible to deduce the
% type of the terms but a work around is to annotate some or all parts of
% the terms. Annotation is usually done at a top level function declaration. Specifying types
% also serves as some kind of documentation for the programmers.
The key idea of Morris is to introduce two predicates for types into the language: \texttt{Un} and \texttt{Fun} with a predicate for ordering
types depending on their admittance to structural rules. The predicate $\tau \geq \tau'$ will hold only if $\tau$ admits more
structural rules than $\tau'$ or, in other words, if $\tau'$ is more restricting than $\tau$.
The predicate \Un{$\tau$} implies that the type $\tau$ is unrestricted which means it does not
contain any resources or the resources that it captures can be easily duplicated and dropped.
In traditional sense of type classes in Haskell, we can think of the \texttt{Un} to be a type-class with methods supporting the operation
of duplication and dropping shown in \cref{fig:un-typeclass}. In a proof theoretic setting, it would mean
that it admits to weakening and contraction. The predicate \texttt{Fun$\tau$} implies that the type $\tau$ is of a function type. The function
depending on its use, may or may not capture resources in its closure and the functions
themselves can be of restricted or unrestricted type.
\begin{figure}[h]
  \begin{framed}\centering
    \begin{minted}[escapeinside=||,mathescape=true,xleftmargin=\parindent,linenos]{haskell}
class Un where
    dup  :: t |$\overset{!}{\rightarrow}$| (t |$\otimes$| t)
    drop :: t |$\overset{!}{\rightarrow}$| 1
    \end{minted}
  \end{framed}
  \caption{\texttt{Un} as a Typeclass}
  \label{fig:un-typeclass}
\end{figure}

Simple types such as integers and booleans are all of unrestricted type as
they can be duplicated or dropped freely. While program resources such as file handles, database connections
should be treated as restricted or linear types as we cannot freely duplicate
or drop them. Consider a lambda expression that represents function application $\lambda f. \lambda x. f x$ and it is applied to
some function $\mathcal{F}$. The linearity of this function $\lambda y. \mathcal{F} x$
would depend on the linearity of $\mathcal{F}$. To generalize, we can say that the linearity of the lambda expression depends
on its closure. The type of $\lambda f. \lambda x. f x$ can be written as $(\tau \overset{f}{\rightarrow} \upsilon) \rightarrow \tau \overset{g}{\rightarrow}\upsilon$
This function would be well typed only if $f$ is more restricting i.e. admits more structural rules than $g$, so to say $f \geq g$.
% The system thus also introduces the concept of comparing types in terms of
% their linearity. The predicate $\tau \geq \tau'$ holds if the type $\tau'$
% is less restricting than $\tau$ or to say $\tau$ has admits more structural rules than $\tau'$.
% Given this definition of $\geq$ we see that the types form a partially ordered lattice where
% unrestricted types ($\Un{\tau}$) would be the meet as they are least restricting and
% admit to both weakening and and contraction rules.

\section{Logic of Bunched Implications and $\alpha\lambda$-Calculus}\label{sec:bi}
In intuitionistic logic, the context is considered as a list or a set. In the theory of \BI,
the context is treated as a tree. Contexts are called bunches and are syntactically
combined using 2 connectives comma ($,$) or a semicolon ($;$). The logic of \BI glues together
intuitionistic linear logic with intuitionistic logic by permitting contexts connected with
semicolon to undergo contraction and weakening while the context connected with comma
are prohibited to undergo contraction and weakening. Comma and semicolon do not distribute over each other.
Thus $A,(B;C) \neq A, B ; A,C$ and $A;(B,C) \neq A;B,A;C$ where $A$, $B$ and $C$ are assumptions or propositions.
There are two flavors of implication---additive and multiplicative---which is closely related to the idea of conjunction.
\begin{framed}\centering
\begin{minipage}{1.0\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma, A \vdash B$}
    \UnaryInfC{$\Gamma \vdash A \lozenge B$}
  \end{prooftree}
\end{minipage}
\end{framed}
In the logic of \BI the question then faced is choosing what kind of
implication should be used in place of $\lozenge$---the additive kind or the multiplicative kind.
\cite{ohearn_logic_1999} introduce 2 kinds of arrows
and use them depending on the connectives used in the context. A multiplicative implication ($\sepimp$)
is used when the context is connected with a comma and an additive implication ($\shimp$) is used when the
context is connected using semicolon. This gives rise to two rules
\begin{framed}
\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\sepimp I]$}
    \UnaryInfC{$\Gamma \vdash A \sepimp B$}
  \end{prooftree}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma; A \vdash B$} \RightLabel{$[\shimp I]$}
    \UnaryInfC{$\Gamma \vdash A \shimp B$}
  \end{prooftree}
\end{minipage}
\end{framed}

$\Gamma, A$ cannot under go weakening or contraction to duplicate
or get rid of either $A$ or $\Gamma$. This hints to a notion that multiplicative implication ($\sepimp$)
exhibits property of the linear implication ($\rightspoon$). The linear implication cannot however
be directly converted to a multiplicative implication as the latter does not exhibit properties of
counting the number of uses of its arguments. Also, in contrast to linear logic, the multiplicative implication
cannot be converted into an intuitionistic implication as there is there is no modality introduced in the system..
The logic of \BI combines the additive logic i.e. intuitionistic logic with the multiplicative side i.e. intuitionistic linear logic.
The promise of this logic system is that the multiplicative side can be used to model the behavior of resources in the programming language
while the additive side would help the programmers fall back to the non-resource intuitionistic parts. This patches
up the awkward asymmetry experienced in linear logic. The multiplicative conjunction $\otimes$ has a right adjoint
counter part as $\sepimp$ while additive conjunction $\with$ has a right adjoint counterpart of $\shimp$.
The logic of \BI argues that instead of looking at the number of times an argument is used within the function,
it should be viewed in terms of {\em sharing}. $\alpha \lambda$-calculus \citep{ohearn_resource_1999, pym_semantics_2002}
is the Curry-Howard interpretation of the logic of \BI. It introduces 2 kinds of arrows by modifying the the syntax of lambda calculus:
\begin{enumerate}
  \item $\sepimp$     : Functions do not share resources with their arguments
  \item $\shimp$ : Functions share resources with their arguments
\end{enumerate}

The types and terms of $\alpha\lambda$-calculus are summarized in \cref{fig:al-cal-types}. The contexts $\{\}_m$ represents a multiplicative empty context
while the $\{\}_a$ represents an additive empty context. The structural and connective rules for $\alpha\lambda$-calculus are
summarized in \cref{fig:bi-typing-rules}.

\begin{figure}[h]
\begin{framed}
  \begin{flalign*}
                       t, u, \upsilon &\in \text{Type Variables}\\
   \text{Context}\ \ \ \Gamma, \Delta &::= \{\}_m \mid \{\}_a \mid x:\tau \mid \Gamma, \Delta \mid \Gamma;\Delta\\
    \text{Types}\ \ \  \tau           &::= t \mid \iota \mid \tau \shimp \tau \mid \tau \sepimp \tau \\
    \text{Expressions}\ \ \ M, N      &::= x \mid \lambda x. M \mid \alpha x. M \mid M N
  \end{flalign*}
\end{framed}
\caption{$\alpha\lambda$-Calculus Types and Terms}
\label{fig:al-cal-types}
\end{figure}

\begin{figure}[h]
  \begin{framed}\centering
    % var
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \tau \in \Gamma$} \RightLabel{[VAR]}
        \UnaryInfC{$\Gamma \vdash x : \tau $}
      \end{prooftree}
    \end{minipage}
    % CTRN
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma; \Gamma \vdash M:\tau$} \RightLabel{[CTRN]}
        \UnaryInfC{$\Gamma \vdash M:\tau$}
      \end{prooftree}
    \end{minipage}
    % WKN
    \begin{minipage}{0.30\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M:\tau$} \RightLabel{[WKN]}
        \UnaryInfC{$\Gamma;\Delta \vdash M:\tau $}
      \end{prooftree}
    \end{minipage}

    % -* I
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{[$\sepimp$ I]}
        \UnaryInfC{$\Gamma \vdash \lambda  x. M : \tau \sepimp \tau'$}
      \end{prooftree}
    \end{minipage}
    % -* E
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \sepimp \tau' \ \ \ \ \
          \Delta \vdash N : \tau$} \RightLabel{[$\sepimp$ E]}
        \UnaryInfC{$\Gamma,\Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}

    % -> I
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}; x: \tau \vdash M : \tau'$} \RightLabel{[$\shimp$ I]}
        \UnaryInfC{$\Gamma \vdash \alpha  x. M : \tau \shimp \tau'$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \shimp \tau' \ \ \ \ \
          \Delta \vdash N : \tau$} \RightLabel{[$\shimp$ E]}
        \UnaryInfC{$\Gamma;\Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Typing Rules for $\alpha\lambda$-Calculus}
  \label{fig:bi-typing-rules}
\end{figure}


Due to the rules of $\alpha\lambda$-calculus $f: \tau \sepimp \tau'; x:\tau \nvdash f x:\tau'$,
as $f$ needs an argument that does not share any resources with its context.
The term $\lambda x. \alpha  f. f x x: \tau \sepimp (\tau \shimp \tau \shimp \tau') \shimp \tau'$ is a typable term in
$\alpha\lambda$-calculus as shown in \cref{fig:multi-bi-example}. This illustrates the difference between logic of \BI and linear logic
as even tough the argument is separate from the function, it may be used twice. Linear logic would prohibit such use of arguments to function.

\begin{figure}[h]
  \begin{framed}
    \begin{minipage}{1.0\linewidth}
      \begin{prooftree}
        \AxiomC{}\RightLabel{[VAR]}
        \UnaryInfC{$f:\tau \shimp \tau \shimp \tau' \vdash f: \tau \shimp \tau \shimp \tau'$}

        \AxiomC{}\RightLabel{[VAR]}
        \UnaryInfC{$x:\tau \vdash x:\tau$} \RightLabel{[$\shimp$E]}
        \BinaryInfC{$f:\tau \shimp \tau \shimp \tau'; x:\tau \vdash f x: \tau \shimp \tau'$}

        \AxiomC{}\RightLabel{[VAR]}
        \UnaryInfC{$x:\tau \vdash x: \tau$}\RightLabel{[$\shimp$E]}

        \BinaryInfC{$x:\tau; f:\tau \shimp \tau \shimp \tau';x:\tau \vdash f x x: \tau'$}\RightLabel{[CTRN]}
        \UnaryInfC{$x:\tau; f:\tau \shimp \tau \shimp \tau' \vdash f x x: \tau'$} \RightLabel{[$\shimp$I]}
        \UnaryInfC{$x:\tau \vdash \lambda x. f x x: (\tau \shimp \tau \shimp \tau') \shimp  \tau'$}\RightLabel{[$\sepimp$I]}
        \UnaryInfC{$\vdash \lambda x. \alpha f. f x x: \tau \sepimp (\tau \shimp \tau \shimp \tau') \shimp \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Multiplicative Argument used Twice in $\alpha\lambda$-calculus}
  \label{fig:multi-bi-example}
\end{figure}

The use of logic of \BI as a type inference system is currently an unexplored area of research in functional programming language implementation.
There has been research on building proof theoretic and semantic models of the logic system \citep{pym_semantics_2002}. The use of bunches instead of
lists as typing environment makes it difficult to have a direct implementation of the type inference algorithm. \cite{atkey_lambda_sep_2004}
designs $\lambda_{sep}$ calculus which is based on the affine variant of $\alpha\lambda$-calculus focusing on separation of resources used by objects.
\cite{collinson_bunched_2005} designs a polymorphic variant of $\alpha\lambda$-calculus.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku"
%%% End:
