\chapter{Background Work}
\section{Type Inference Algorithm}\label{sec:damas-milner-algo-w}
Algorithm $\mathcal{W}$ \citep{damas_principal_1982} and its variant algorithm $\mathcal{M}$ \citep{lee_proofs_1998}
are the basis of most of the modern statically typed functional programming languages. Type inference
is decidable in the sense, type checking algorithm always completes with a success or failure.
The algorithms also grantee a most general typing scheme for an expression in
the Hindley-Milner type system \textbf{HM} which is typed lambda calculus with parametric polymorphism (or restricted version of System F)
extended with a polymorphic \texttt{let} construct having a term language
\begin{framed}
  \begin{flalign*}
    \text{Expressions}\ \ \ M, N ::= x: \sigma \mid \lambda x: \tau. M \mid M N
    \mid \Let{x}{M}{N} \nonumber
  \end{flalign*}
\end{framed}
and a type language specified by
\begin{framed}
  \begin{flalign*}
                              t, u, v &\in \text{Type Variables}\nonumber\\
    \text{Types}\ \ \  \tau           &::= \iota \mid \tau \rightarrow \tau \nonumber \\
    \text{Typing Scheme}\ \ \  \sigma &::= \tau \mid \forall t. \tau \nonumber
  \end{flalign*}
\end{framed}
where $t$ is a type variable, $\iota$ are primitive types in the language, $\rightarrow$
is a type constructor for functions and $\sigma$ is a typing scheme.

Robinson's \citeyearpar{robinson_machine-oriented_1965} unification algorithm plays a key role
in ensuring that types are well formed. Its purely syntactic approach in creating
substitutions to unify types keeps the complete process elegant.
Algorithm $\mathcal{W}$ or $\mathcal{M}$ works in an interesting way where the types of all well-typed terms can be
inferred automatically and if types are specified, the same algorithm can be used
to verify that the specified type of expression term matches the actual type.

\begin{figure}[h]
  \begin{framed}
    % var
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \sigma \in \Gamma$} \RightLabel{[VAR]}
        \UnaryInfC{$\Gamma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma$}
        \AxiomC{$\Gamma_{x}, x: \sigma \vdash N: \tau$} \RightLabel{[LET]}
        \BinaryInfC{$\Gamma \vdash (\Let{x}{M}{N}) : \tau$}
      \end{prooftree}
    \end{minipage}
    % forall I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma$}\RightLabel{[$\forall$ I]}
        \AxiomC{$t \notin \text{fvs}(\Gamma)$}
        \BinaryInfC{$\Gamma \vdash \lambda t. M : \forall t. \sigma$}
      \end{prooftree}
    \end{minipage}
    % forall E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \forall t. \sigma$} \RightLabel{[$\forall$ E]}
        \UnaryInfC{$\Gamma \vdash M \tau : [\tau \backslash t] \sigma$}
      \end{prooftree}
    \end{minipage}
    % -> I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{[$\rightarrow$ I]}
        \UnaryInfC{$\Gamma \vdash \lambda x. M : \tau \rightarrow \tau'$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \rightarrow \tau'$}
        \AxiomC{$\Gamma \vdash N : \tau$} \RightLabel{[$\rightarrow$ E]}
        \BinaryInfC{$\Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Typing Rules for \textbf{HM} Type System}
  \label{fig:stlc-logic}
\end{figure}
The rules for type inference for \textbf{HM} type system are shown in \cref{fig:stlc-logic}. $\Gamma$ is the
collection of assumptions or context in which the expression is typed. The $[VAR]$ rule is tautology or a simple
lookup of the term variable $x$ in the context $\Gamma$. The [LET] allows creating local
definitions within an expression term. [$\rightarrow$ I] and [$\rightarrow$ E] are rules
for typing lambda terms and application respectively. We also include the rules for
type abstraction and application [$\forall$I] and [$\forall$ E] i.e. parametric polymorphism.

By Curry-Howard correspondence the HM type system correspondes to the implication fragment of intuionistic propositional logic
the rules of which are given in \cref{fig:intuitionistic-logic} in Gentzen style natural deduction
where $\Gamma$, $\Phi$ and $\Psi$ are propositions. The [Ax] rule corresponds to [ID] rule while [$\rightarrow$I] and [$\rightarrow$E] correspond
to [$\rightarrow$I] and [$\rightarrow$E] respectively. The structural rules of weakening [WKN] and contraction [CTR] are implicitly obeyed
by \textbf{HM} type-system. The weakening rule states that we can add unrelated assumptions to our derivation without
affecting the proofs while contraction states that we can get rid of the unrelated assumptions from our derivation and the
proof will still hold.

\begin{figure}[h]\centering
  \begin{framed}
    % ID
    \begin{minipage}{0.20\linewidth}
      \begin{prooftree}
        \AxiomC{${\color{white}\Phi\Gamma\Psi}$}\RightLabel{[Ax]}
        \UnaryInfC{$\Gamma, \Phi \vdash \Phi $}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash \Phi$}\RightLabel{[WKN]}
        \UnaryInfC{$\Gamma, \Gamma' \vdash \Phi$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, \Gamma' \vdash \Phi $}\RightLabel{[CTR]}
        \UnaryInfC{$\Gamma \vdash \Phi $}
      \end{prooftree}
    \end{minipage}
    % -> I
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash \Phi$}
        \AxiomC{$\Gamma, \Phi \vdash \Psi $}\RightLabel{[$\rightarrow$I]}
        \BinaryInfC{$\Gamma \vdash \Phi \rightarrow \Psi$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.33\linewidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash \Phi \rightarrow \Psi$}
        \AxiomC{$\Gamma \vdash \Phi$}\RightLabel{[$\rightarrow$E]}
        \BinaryInfC{$\Gamma, \Phi \vdash \Psi $}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Logic rules in Implication fragment of Intuitionistic Propositional
    Logic}
  \label{fig:intuitionistic-logic}
\end{figure}
% This simple type system is powerful in its
% expressiveness and can encode a large variety of computations. The type checking algorithm
% asserts that undefined programs can be be detected statically i.e. without actually
% running the program or as famously known as ``well typed programs do not go wrong''.
% This is extremely useful for programmers who are building
% complex real world softwares. Bad programs can be eliminated instantaneously while
% being written using a mechanize technique so that the programmer can concentrate on designing the logic
% rather than fighting undefinedness of the programs. This creates an excellent feedback loop
% to the programmer while building large software systems.

\section{Linear Logic}\label{sec:linear-logic}
% what is linearity
% restricting weakening and contraction
While propositional logic deals with truth of propositions and their connectives, linear logic deals with availability of resources.
Linear logic \citep{girard_linear_1987} promises to help cope with the resource and resource control problem.
It is refinement of classical intuitionistic logic. The core idea is that propositions
cannot be freely duplicated or discarded as allowed in intuitionistic logic.
In formal terms, the contraction and weakening of logical rules are restricted.
This instigates a view of propositions to behave like resources. In real world software applications,
resources may not be freely copied or dropped from a program context.
Program entities like database connections, file handles or even
in memory shared state are pet peeves for programmers writing
industry grade software. Linear logic hopes to be a remedy for
these problems. If contraction and weakening is completely abandoned,
the system gets overly restrictive. Wadler describes a refinement of
linear logic based on Girard's Logic of Unity \citep{wadler_taste_1993, girard_unity_1993}.
It works around the problem of linear logic being too restrictive by allowing
intuitionistic rules in fragments. It can be considered as a disjoint union
of classical linear logic and intuitionistic logic. The grammar of intuitionistic logic is shown in \ref{fig:intu-logic-grammar}
where $A \rightarrow B$ denotes implication, $A \times B$ denotes conjunction and $A \plus B$ denotes disjunction.
\begin{figure}
  \centering
  \begin{framed}
  \begin{flalign*}
    A, B, C ::= X \mid A \vdash B \mid A \rightarrow B \mid A \times B \mid A \plus B
  \end{flalign*}
\end{framed}
\caption{Grammar for Intuitionistic Logic}
\label{fig:intu-logic-grammar}
\end{figure}

In a pure linear logic setting, none of the assumptions can be used more than once (weakening is prohibited)
and they cannot be discarded as well (contraction prohibited). This gives rise to two different flavor of all the logical connectives.
$A \rightspoon B$ describes the new implication meaning and is read as {\em``consume A to give B''} its logical rules
is given by $\rightspoon I$ and $\rightspoon E$. Similarly there are 2 kinds of connectives, multiplicative and additive that
arise in this logic system. More symbols are added in place of $\plus$ and $\times$ to differentiate between the
multiplicative conjunction and disjunction ($\otimes$ and $\parr$), and additive conjunction and disjunction ($\with $ and $\oplus$).
While working in intuitionistic linear logic, $\parr$ is dropped from the system as it can be encoded by other connectives.

\begin{figure}
  \centering
  \begin{framed}
    \begin{flalign*}
      A, B, C ::= X \mid \oc A \mid A \vdash B \mid A \rightspoon B \mid A \with B \mid A \otimes B
    \end{flalign*}
  \end{framed}
  \caption{Grammar for Intuitionistic Linear Logic}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    % -o I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\rightspoon I]$}
        \UnaryInfC{$\Gamma \vdash A \rightspoon B$}
      \end{prooftree}
    \end{minipage}
    % -o E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash  A \rightspoon B$}
        \AxiomC{$\Delta \vdash A$} \RightLabel{$[\rightspoon E]$}
        \BinaryInfC{$\Gamma, \Delta \vdash B$}
      \end{prooftree}
    \end{minipage}
  % & I
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A$}
      \AxiomC{$\Gamma \vdash B$} \RightLabel{$[\with I]$}
      \BinaryInfC{$\Gamma \vdash A \with B$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A \with B$} \RightLabel{$[\with E_1]$}
      \UnaryInfC{$\Gamma \vdash A$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A \with B$} \RightLabel{$[\with E_2]$}
      \UnaryInfC{$\Gamma \vdash B$}
    \end{prooftree}
  \end{minipage}
  % otimes I
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A$}
      \AxiomC{$\Delta \vdash B$} \RightLabel{$[\otimes I]$}
      \BinaryInfC{$\Gamma, \Delta \vdash A \otimes B$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.7\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A \otimes B$} \RightLabel{$[\otimes E]$}
      \AxiomC{$\Gamma, A, B \vdash C$}
      \BinaryInfC{$\Gamma \vdash C$}
    \end{prooftree}
  \end{minipage}

    % % par I
    % \begin{minipage}{0.5\textwidth}
    %   \begin{prooftree}
    %     \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\parr I]$}
    %     \UnaryInfC{$\Gamma \vdash A \rightspoon B$}
    %   \end{prooftree}
    % \end{minipage}
    % % par E
    % \begin{minipage}{0.5\textwidth}
    %   \begin{prooftree}
    %     \AxiomC{$\Gamma \vdash  A \rightspoon B$}
    %     \AxiomC{$\Delta \vdash A$} \RightLabel{$[\parr E]$}
    %     \BinaryInfC{$\Gamma, \Delta \vdash B$}
    %   \end{prooftree}
    % \end{minipage}

    % oplus
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$} \RightLabel{$[\oplus I_1]$}
        \UnaryInfC{$\Gamma \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Delta \vdash B$} \RightLabel{$[\oplus I_2]$}
        \UnaryInfC{$\Delta \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.6\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \oplus B$}
        \AxiomC{$\Delta, A \vdash C$}
        \AxiomC{$\Delta, B \vdash C$}\RightLabel{$[\oplus E]$}
        \TrinaryInfC{$\Gamma, \Delta \vdash C$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Intuitionistic Linear Logic Rules}
  \label{fig:linear-logic-rules}
\end{figure}

To escape linearity, exponential modality $\oc$ is used, which signifies that an assumption can
be duplicated or dropped without restriction. $\oc A$ can be thought of as {\em``as many A's as needed''}.
Thus the intuitionistic $A \rightarrow B$ can be encoded in linear logic by $\oc A \rightspoon B$.
Similarly $A \plus B$ would be represented as $\oc A \otimes \oc B$ and $A \times B$ would be represented as $A \with B$.
We clearly see that this is a much powerful system in contrast to intuitionistic logic because of its enhanced expressivity.
But there is an awkward asymmetry between the multiplicative and additive constructs. While $\rightspoon$ is a right adjoint
for multiplicative $\times$, there is no such right adjoint counter part for additive $\with$.
{\color{red}There have been quite a few prototypes of languages using linear logic. L3 etc}

\section{Qualified Types}\label{sec:qualified-types}
Jones \citeyearpar{jones_theory_1994} proposed incorporating predicates in the type language.
Predicates are used to build constraints on the domain of the type of a term in the language expression.
It introduces additional layer between polymorphic and monomorphic typing of programs.
A modification of Milner-Damas algorithm to incorporate predicates ensures that type inference
is sound and complete. The types that satisfy all the predicates are called qualified types for the term.
Qualified types are powerful enough to expresses type classes with functional dependencies,
record types and sub-typing \citep{mark_type_2000}. The type language is modified to contain
qualified types. $P$ and $Q$ range over finite set of predicates. We slightly modify the typing rules
from \cref{fig:stlc-logic} to add 2 new rules for qualified types as shown in \cref{fig:qualified-types-rules}
\begin{figure}[h]
  \centering
  \begin{framed}
  \begin{flalign*}
                               t, u, v  &\in \text{Type Variables}\nonumber\\
    \text{Types}\ \ \ \tau              &::= t \mid \iota \mid \tau \rightarrow \tau \nonumber \\
    \text{Qualified Types}\ \ \ \rho    &::= P \Rightarrow \tau \nonumber \\
    \text{Type Scheme}\ \ \ \sigma      &::= \tau \mid \forall T. \rho \nonumber
  \end{flalign*}
\end{framed}
\caption{Qualified Types}
\label{fig:qualifed-types}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    % => I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P, \pi \mid \Gamma \vdash M : \rho$} \RightLabel{$[=> I]$}
        \UnaryInfC{$P \mid \Gamma \vdash M : \pi \Rightarrow \rho$}
      \end{prooftree}
    \end{minipage}
    % => E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \pi \Rightarrow \rho$}
        \AxiomC{$P \Rightarrow \pi$} \RightLabel{$[=> E]$}
        \BinaryInfC{$P \mid \Gamma \vdash M: \rho$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Typing Rules for Qualified Types}
  \label{fig:qualified-types-rules}
\end{figure}

\section{Linear logic with Qualified Types: Quill}\label{sec:quill}
Quill \citep{morris_best_2016} implements a sound and complete linear type system using qualified types.
It uses a modified version of Algorithm $\M$ to compute principal types of the terms.
In practice, due to higher ordered kind system, it may not be possible to deduce the
type of the terms but a work around is to annotate some or all parts of
the terms. Annotation is usually done at a top level function declaration. Specifying types
also serves as some kind of documentation for the programmers.
The key idea of Morris is to introduce two predicates for types into the language: \texttt{Un} and \texttt{Fun}.
\texttt{Un $\tau$} implies that the type $\tau$ is unrestricted which means it does not
contain any resources or the resources that it captures can be easily duplicated and dropped.
In traditional sense of type classes in Haskell, we can think of the \texttt{Un} to be a type-class with methods supporting the operation
of duplication and dropping shown in \cref{fig:un-typeclass}. In a proof theoritic setting, it would mean
that it admits to weakening and contraction.
The \texttt{Fun $\tau$} implies that the type $\tau$ is of a function type. The function
depending on its use, may or may not capture resources in its closure and the functions
themselves can be of restricted or unrestricted type.
\begin{figure}[h]
  \centering
  \begin{framed}\centering
    \begin{minted}[escapeinside=||,mathescape=true]{haskell}
      class Un where
          dup  :: t |$\overset{!}{\rightarrow}$| (t |$\otimes$| t)
          drop :: t |$\overset{!}{\rightarrow}$| 1
    \end{minted}
  \end{framed}
  \caption{\texttt{Un} as a Typeclass}
  \label{fig:un-typeclass}
\end{figure}

Simple types such as integers and booleans are all of unrestricted type as
they can be duplicated or dropped freely. While program resources such as file handles, database connections
should be treated as restricted or linear types as we cannot freely duplicate
or drop them. Consider a lambda expression that represents function application $\lambda f. \lambda x. f x$ and it is applied to
some function $\mathcal{F}$. The linearity of this function $\lambda y. \mathcal{F} x$
would depend on the linearity of $\mathcal{F}$. To generalize, we can say that the linearity of the lambda expression depends
on its closure. The type of $\lambda f. \lambda x. f x$ can be written as $(\tau \overset{f}{\rightarrow} \upsilon) \rightarrow \tau \overset{g}{\rightarrow}\upsilon$
This function would be well typed only if $f$ is more restricting i.e. admits more structural rules than $g$ so to say $f \geq g$.
The system thus also introduces the concept of comparing types in terms of
their linearity. The predicate $\tau \geq \tau'$ holds if the type $\tau'$
is less restricting than $\tau$ or to say $\tau$ has admits more structural rules than $\tau'$.
Given this definition of $\geq$ we see that the types form a partially ordered lattice where
unrestricted types ($\Un{\tau}$) would be the meet as they are least restricting and
admit to both weakening and and contraction rules.

\section{Logic of Bunched Implications and $\alpha\lambda$-Calculus}\label{sec:bi}
In intuitionistic logic, the context is considered as a list or a set. In the theory of \BI,
the context is treated as a tree in contrast to other logics. Contexts are syntactically
combined using 2 connectives comma ($,$) or a semicolon ($;$) and are called bunches. The logic of \BI
tries to glue together intuitionistic linear logic with intuitionistic logic by
permitting contexts connected with semicolon to undergo contraction and weakening while the context connected with comma
are prohibited to undergo contraction and weakening. Comma and semicolon do not distributive over each other.
Thus $A,(B;C) \neq A, B ; A,C$ and $A;(B,C) \neq A;B,A;C$ where $A$, $B$ and $C$ are assumptions or propositions.
There are two flavors of implication---additive and multiplicative---which is closely related to the idea of conjunction.
\begin{framed}\centering
\begin{minipage}{1.0\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma, A \vdash B$}
    \UnaryInfC{$\Gamma \vdash A \lozenge B$}
  \end{prooftree}
\end{minipage}
\end{framed}
In the logic of \BI the question then faced is choosing what kind of
implication should be used in place of $\lozenge$---the additive kind or the multiplicative kind.
O'Hearn et al. \citeyearpar{ohearn_logic_1999} introduce 2 kinds of arrows
and use them depending on the connectives used in the context. A multiplicative implication ($\sepimp$)
is used when the context is connected with a comma and an additive implication ($\rightarrow$) is used when the
context is connected using semicolon. This gives rise to two rules
\begin{framed}
\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\sepimp I]$}
    \UnaryInfC{$\Gamma \vdash A \sepimp B$}
  \end{prooftree}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma; A \vdash B$} \RightLabel{$[\rightarrow I]$}
    \UnaryInfC{$\Gamma \vdash A \rightarrow B$}
  \end{prooftree}
\end{minipage}
\end{framed}

As we see in $[\sepimp I]$ $\Gamma, A$ cannot under go weakening or contraction to duplicate
or get rid of either $A$ or $\Gamma$. This hints to a notion that multiplicative implication ($\sepimp$)
exhibits property of the linear implication ($\rightspoon$). The linear implication cannot however
be directly converted to a multiplicative implication as the latter does not exhibit properties of
counting the number of uses of its arguments. Also, in contrast to linear logic, the multiplicative implication
cannot be converted into an intuitionistic implication by using modality. The logic of \BI tries to combine the
additive logic i.e. intuitionistic logic with the multiplicative side i.e. intuitionistic linear logic seamlessly.
The multiplicative side can be used to model the behavior of resources in the programming language
while the additive side would help the programmers fall back to the non-resource intuitionistic parts. This patches
up the awkward asymmetry experienced in linear logic. The multiplicative conjunction $\otimes$ has a right adjoint
counter part as $\sepimp$ while additive conjunction $\with$ has a right adjoint counterpart of $\rightarrow$.
The logic of \BI argues that instead of looking at the number of times an argument is used within the function,
it should be viewed in terms of {\em sharing}. $\alpha \lambda$-calculus \citep{ohearn_resource_1999, pym_semantics_2002}
is interpretation of the logic of \BI. It introduces 2 kinds of arrows by modifying the the syntax of lambda calculus:
\begin{enumerate}
  \item $\sepimp$     : Functions do not share resources with their arguments
  \item $\rightarrow$ : Functions share resources with their arguments
\end{enumerate}

\begin{figure}[h]
\begin{framed}
  \begin{flalign*}
                              t, u, v &\in \text{Type Variables}\nonumber\\
    \text{Types}\ \ \  \tau           &::= t \mid \iota \mid \tau \rightarrow \tau \mid \tau \sepimp \tau \nonumber\\
    \text{Expressions}\ \ \ M, N      &::= x \mid \lambda^{\alpha} x. M \mid \lambda^{*} x. M \mid M N \nonumber
  \end{flalign*}
\end{framed}
\caption{$\alpha\lambda$-Calculus Types and Terms}
\label{fig:al-cal-types}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    % var
    \begin{minipage}{1.0\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \tau \in \Gamma$} \RightLabel{$[VAR]$}
        \UnaryInfC{$\Gamma \vdash x : \tau $}
      \end{prooftree}
    \end{minipage}
    % -> I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{$[\sepimp I]$}
        \UnaryInfC{$\Gamma \vdash \lambda^{*} x. M : \tau \sepimp \tau'$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \sepimp \tau' \ \ \ \ \
          \Gamma \vdash N : \tau$} \RightLabel{$[\sepimp E]$}
        \UnaryInfC{$\Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
    % -* I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}; x: \tau \vdash M : \tau'$} \RightLabel{$[\rightarrow I]$}
        \UnaryInfC{$\Gamma \vdash \lambda^{\alpha} x. M : \tau \rightarrow \tau'$}
      \end{prooftree}
    \end{minipage}
    % -* E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \rightarrow \tau' \ \ \ \ \
          \Gamma \vdash N : \tau$} \RightLabel{$[\rightarrow E]$}
        \UnaryInfC{$\Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Typing Rules for $\alpha\lambda$ Calculus}
  \label{fig:bi-logic}
\end{figure}

\TODO{
Some more examples about $\alpha\lambda$-calculus programming?
}
Due to the rules of $\alpha\lambda$-calculus $f: \tau \sepimp \tau'; x:\tau \nvdash f x:\tau'$.
As $f$ needs an argument that does not share any resources with its context.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku"
%%% End:
