\chapter{Background Work}
% TODO should change title

\section{Type Inference Algorithm}
Algorithm W [\cite{damas_principal_1982}] and its varient algorithm M [\cite{lee_proofs_1998}]
are the basis of almost all modern statically typed programming languages. Type inference
is decidable in the sense, type checking algorithm always completes with a success or failure.
The algorithms also gurantee a most general typing scheme for an expression in
the simply typed lambda calculus extended with a polymorphic let construct having a term language
\begin{framed}
  \begin{flalign*}
    \text{Expressions}\ \ \ M, N ::= x: \sigma \mid \lambda x: \tau. M \mid M N \mid \texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N \nonumber
  \end{flalign*}
\end{framed}
and a type language specified by
\begin{framed}
  \begin{flalign*}
    \text{Types}\ \ \  \tau    &::= \alpha \mid \iota \mid \tau \rightarrow \tau \nonumber \\
    \text{Typing Scheme}\ \ \  &::= \tau \mid \forall \alpha. \tau \nonumber
  \end{flalign*}
\end{framed}
where $\alpha$ is a type variable, $\iota$ are primitive types in the language, $\rightarrow$
is a type constructor and $\sigma$ is a typing scheme.

Robinson's unification algorithm [\cite{robinson_machine-oriented_1965}] plays a key role
in ensuring that types are well formed. Its purely syntactic approach in creating
substitutions to unify types keeps the complete process elegent.
The algorithm works in an interesting way where the types of all well-typed terms can be
inferred automatically and if types are specified, the same algorithm can be used
to match the expression term.

\begin{figure}[h]
  \begin{framed}
    % var
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \sigma \in \Gamma$} \RightLabel{$[VAR]$}
        \UnaryInfC{$\Gamma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma \ \ \ \ \
          \Gamma_{x}, x: \sigma \vdash N: \tau$} \RightLabel{$[LET]$}
        \UnaryInfC{$\Gamma \vdash (\texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N) : \tau$}
      \end{prooftree}
    \end{minipage}

    % -> I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{$[\rightarrow I]$}
        \UnaryInfC{$\Gamma \vdash \lambda x. M : \tau \rightarrow \tau'$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \rightarrow \tau' \ \ \ \ \
          \Gamma \vdash N : \tau$} \RightLabel{$[\rightarrow E]$}
        \UnaryInfC{$\Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Logic Rules for Simply Typed Lambda Calculus}
  \label{fig:stlc-logic}
\end{figure}
The logical rules for type inference are shown in \ref{fig:stlc-logic}. $\Gamma$ is the
context or assumptions in which the expression is typed. The $[VAR]$ rule is tautology or a simple
lookup of the term variable $x$ in the context $\Gamma$. The $[LET]$ allows creating local
definitions within an expression term. $[\rightarrow I]$ and $[\rightarrow E]$ are rules
for typing lambda terms and application respectively.


% This simple type sytem is powerful in its
% expressivity and can encode a large variety of computations. The type checking algorithm
% asserts that undefined programs can be be detected statically i.e. without actually
% running the program or as famously known as ``well typed programs do not go wrong''.
% This is extremely useful for programmers who are building
% complex real world softwares. Bad programs can be eleminated instantaneously while
% being written using a mechanize technique so that the programmer can concentrate on designing the logic
% rather than fighting undefinedness of the programs. This creates an excellent feedback loop
% to the programmer while building large software systems. % TODO too generic should it be in introduction?
% TODO Give examples?


\section{Qualified Types}
Jones [\cite{jones_theory_1994}] proposed incorporating predicates in the type language.
Predicates are used to build constraints on the domain of the type of a term in the language expression.
It introduces additional layer between polymorphic and monomorphic typing of programs.
A modification of Milner-Damas algorithm to encorporate predicates ensures that type inference
is sound and complete. The types that satisfy all the predicates are called qualified types for the term.
Qualified types are powerful enough to expresses type classes with functional dependencies,
record types and subtyping [\cite{mark_type_2000}]. The type language is modified to contain
qualified types. $\Pi$ and $T$ range over finite set of predicates
\begin{figure}[h]
  \centering
  \begin{framed}
  \begin{flalign*}
    \text{Types}\ \ \ \tau              &::= \alpha \mid \iota \mid \tau \rightarrow \tau \nonumber \\
    \text{Qualified Types}\ \ \ \rho    &::= \Pi \Rightarrow \tau \nonumber \\
    \text{Type Scheme}\ \ \ \sigma      &::= \tau \mid \forall T. \rho \nonumber
  \end{flalign*}
\end{framed}
\caption{Qualified Types}
\label{fig:qualifed-types}
\end{figure}
\section{Linear Logic}
% TODO: points to cover
% what is linearity
% restricting weakening and contraction
Linear logic [\cite{girard_linear_1987}] promises to help cope with the resource and resource control problem.
It is refinement of classical intuistionistic logic. The core idea is that propositions
cannot be freely duplicated or discarded as in classical instuistionistic logic.
In formal terms, the contraction and weakening of logical rules are restricted.
This instigates a view of propositions to behave like resources. In real world software applications,
resources may not be freely copied or dropped from a program context.
Program entities like database connections, file handles or even
in memory shared state are pet peeves for programmers writing
industry grade software. Linear logic hopes to be a remedy for
these problems. If contraction and weakening is completely abandoned,
the system gets overly restrictive. Wadler describes a refinement of
linear logic based on Girard's Logic of Unity [\cite{wadler_taste_1993}, \cite{girard_unity_1993}].
It works around the problem of linear logic being too restrictive by allowing
instuistionistic rules in fragments. It can be considered as a disjoint union
of linear logic and intuistionistic logic. The grammar of classical intuistionistic logic is shown in \ref{fig:intu-logic-grammar}
where $A \rightarrow B$ implies implication, $A \times B$ is conjunction and $A \plus B$ is disjunction.
\begin{figure}
  \centering
  \begin{framed}
  \begin{flalign*}
    A, B, C ::= X \mid A \vdash B \mid A \rightarrow B \mid A \times B \mid A \plus B
  \end{flalign*}
\end{framed}
\caption{Grammar for Intuistionistic Logic}
\label{fig:intu-logic-grammar}
\end{figure}

In a pure linear logic setting, none of the assumptions can be used more than once (weakening prohibited) and they cannot be discarded
(contraction prohibited) This gives rise to a different flavor of all the logical connectives.
$A \rightspoon B$ describes the new implication meaning and is read as {\em``consume A to give B''} its logical rules
is given by $\rightspoon I$ and $\rightspoon E$. Similarly there are 2 kinds of connectives, multiplicative and additive that
arise in this logic system. More symbols are added inplace of $\plus$ and $\times$ to differentiate between the
multipicative conjunction and disjuntion ($\otimes$ and $\parr$), and additive conjuntion and disjunction ($\with $ and $\oplus$).
While working in intuistionistic linear logic, $\parr$ is dropped from the system. (TODO why is additive disjunction dropped? in ILL?)

\begin{figure}
  \centering
  \begin{framed}
    \begin{flalign*}
      A, B, C ::= X \mid \oc A \mid A \vdash B \mid A \rightspoon B \mid A \with B \mid A \otimes B
    \end{flalign*}
  \end{framed}
  \caption{Grammar for Intuistionistic Linear Logic}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    % -o I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\rightspoon I]$}
        \UnaryInfC{$\Gamma \vdash A \rightspoon B$}
      \end{prooftree}
    \end{minipage}
    % -o E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash  A \rightspoon B$}
        \AxiomC{$\Delta \vdash A$} \RightLabel{$[\rightspoon E]$}
        \BinaryInfC{$\Gamma, \Delta \vdash B$}
      \end{prooftree}
    \end{minipage}

  % & I
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A$}
      \AxiomC{$\Gamma \vdash B$} \RightLabel{$[\with I]$}
      \BinaryInfC{$\Gamma \vdash A \with B$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A \with B$} \RightLabel{$[\with E_1]$}
      \UnaryInfC{$\Gamma \vdash A$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A \with B$} \RightLabel{$[\with E_2]$}
      \UnaryInfC{$\Gamma \vdash B$}
    \end{prooftree}
  \end{minipage}

  % otimes I
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A$}
      \AxiomC{$\Delta \vdash B$} \RightLabel{$[\otimes I]$}
      \BinaryInfC{$\Gamma, \Delta \vdash A \otimes B$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.7\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A \otimes B$} \RightLabel{$[\otimes E]$}
      \AxiomC{$\Gamma, A, B \vdash C$}
      \BinaryInfC{$\Gamma \vdash C$}
    \end{prooftree}
  \end{minipage}

    % % par I
    % \begin{minipage}{0.5\textwidth}
    %   \begin{prooftree}
    %     \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\parr I]$}
    %     \UnaryInfC{$\Gamma \vdash A \rightspoon B$}
    %   \end{prooftree}
    % \end{minipage}
    % % par E
    % \begin{minipage}{0.5\textwidth}
    %   \begin{prooftree}
    %     \AxiomC{$\Gamma \vdash  A \rightspoon B$}
    %     \AxiomC{$\Delta \vdash A$} \RightLabel{$[\parr E]$}
    %     \BinaryInfC{$\Gamma, \Delta \vdash B$}
    %   \end{prooftree}
    % \end{minipage}

    % oplus
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$} \RightLabel{$[\oplus I_1]$}
        \UnaryInfC{$\Gamma \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Delta \vdash B$} \RightLabel{$[\oplus I_2]$}
        \UnaryInfC{$\Delta \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.6\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \oplus B$}
        \AxiomC{$\Delta, A \vdash C$}
        \AxiomC{$\Delta, B \vdash C$}\RightLabel{$[\oplus E]$}
        \TrinaryInfC{$\Gamma, \Delta \vdash C$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Intuionistic Linear Logic Rules}
  \label{fig:linear-logic-rules}
\end{figure}

To escape linearity, exponential $\oc$ is used, which signifies that an assumption can
be duplicted or dropped without restriction. $\oc A$ can be thought of as {\em``as many A's as needed''}.
Thus the intitionsistic $A \rightarrow B$ can be encoded in linear logic by $\oc A \rightspoon B$.
Similarly $A \plus B$ would be represented as $\oc A \otimes \oc B$ and $A \times B$ would be represented as $A \with B$. We clearly see that
this is a much powerful system in contrast to classical intuistionistic logic because of its enhanced expressivity.

\section{Bunched Implications and $\alpha$ Lambda Calculus}

In intuitionistic linear logic, the context is considered as a list or a set. In the theory of
bunched implications, the context is treated as a tree in contrast to other logics. Contexts are syntactically
combined using 2 connectives comma ($,$) or a semicolon ($;$) and are called bunches. The logic of Bunched Implication (\textbf{\em BI})
tries to glue together intuistionistic linear logic with intuistionistic logic by
permitting contexts connected with semicolon to undergo contraction and weakening while the ones connect with comma
are prohibited to undergo contraction and weakening. Comma and semicolon do not distributive over each other.
Thus $A,(B;C) \neq A, B ; A,C$ and $A;(B,C) \neq A;B,A;C$ where A B C are contexts.
There are two flavours of implication---additive and multiplicative---which is related to the idea of conjunction.
\begin{framed}
\begin{minipage}{1.0\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma, A \vdash B$}
    \UnaryInfC{$\Gamma \vdash A \lozenge B$}
  \end{prooftree}
\end{minipage}
\end{framed}
In the logic of {\textbf{\em BI}} the question then faced is choosing what kind of
implication should be used inplace of $\lozenge$---the additive kind or the multiplicative kind.
O'Hearn and Pym [\cite{ohearn_logic_1999}] argue by introducing 2 kinds of arrows
and using them depending on the connectives used for the context. A multiplicative implication ($\sepimp$)
is used when the context is connected with a $,$ and an additive implication ($\rightarrow$) is used when the
context is connected using $;$. This gives rise to 2 rules
\begin{framed}
\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\sepimp I]$}
    \UnaryInfC{$\Gamma \vdash A \sepimp B$}
  \end{prooftree}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma; A \vdash B$} \RightLabel{$[\rightarrow I]$}
    \UnaryInfC{$\Gamma \vdash A \rightarrow B$}
  \end{prooftree}
\end{minipage}
\end{framed}

As we see in $[\sepimp I]$; $\Gamma, A$ cannot under go weakening or contraction to duplicate
or get rid of either $A$ or $\Gamma$. This hints to a notion that multiplicative implication ($\sepimp$)
exhibits property of the linear implication ($\rightspoon$). The linear implication cannot however
be directly converted to a multiplicative implication as the later does not exhibit properties of
counting the number of uses of its arguments. The logic of \textbf{\em BI} tries to combine the
additive logic i.e. intuistionistic logic with the multiplicative side i.e. intuistionistic linear logic seemlessly.
The multiplicative side can be used to model the behaviour of resources in the programming language
while the additive side would help the programmers fall back to the non-resource intuistionsitic parts.

$\alpha$ Lambda calculus[\cite{ohearn_resource_1999}] interprets the logic of \textbf{\em BI} and introduces 2 kinds of arrows by
modifiying the the syntax of lambda calculus:\\
$\sepimp$     : Function do not share resources with their arguments\\
$\rightarrow$ : Function may share resources with their arguments\\

\begin{framed}
  \begin{flalign*}
    \text{Expressions}\ \ \ M, N ::= x: \sigma \mid \lambda^{\alpha} x: \tau. M \mid \lambda^{*} x: \tau. M \mid M N \mid \texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N \nonumber
  \end{flalign*}
\end{framed}
\begin{framed}
  \begin{flalign*}
    \text{Types}\ \ \  \tau    &::= \alpha \mid \iota \mid \tau \rightarrow \tau \mid \tau \sepimp \tau \nonumber \\
    \text{Typing Scheme}\ \ \  &::= \tau \mid \forall \alpha. \tau \nonumber
  \end{flalign*}
\end{framed}
\begin{figure}[h]
  \begin{framed}
    % var
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \sigma \in \Gamma$} \RightLabel{$[VAR]$}
        \UnaryInfC{$\Gamma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma \ \ \ \ \
          \Gamma_{x}, x: \sigma \vdash N: \tau$} \RightLabel{$[LET]$}
        \UnaryInfC{$\Gamma \vdash (\texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N) : \tau$}
      \end{prooftree}
    \end{minipage}

    % -> I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{$[\sepimp I]$}
        \UnaryInfC{$\Gamma \vdash \lambda^{*} x. M : \tau \sepimp \tau'$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \sepimp \tau' \ \ \ \ \
          \Gamma \vdash N : \tau$} \RightLabel{$[\sepimp E]$}
        \UnaryInfC{$\Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}

    % -o I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}; x: \tau \vdash M : \tau'$} \RightLabel{$[\rightarrow I]$}
        \UnaryInfC{$\Gamma \vdash \lambda^{\alpha} x. M : \tau \rightarrow \tau'$}
      \end{prooftree}
    \end{minipage}
    % -o E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \rightarrow \tau' \ \ \ \ \
          \Gamma \vdash N : \tau$} \RightLabel{$[\rightarrow E]$}
        \UnaryInfC{$\Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Logic Rules for $\alpha$ Lambda Calculus}
  \label{fig:bi-logic}
\end{figure}

We now see that we have two kinds of pairs. A sharing pair (\texttt{shPair}) and a separating pair (\texttt{sePair}) depending on
what arrow we use. The church encoding of both the pairs are given in \ref{fig:bi-pairs}.
\begin{figure}[h]
  \centering
  \begin{framed}
    \begin{lstlisting}
      shPair = $\lambda^{*} a.\ \lambda^{\alpha} b.\ \lambda^{*} f.\ f\ a\ b$
      sePair = $\lambda^{*} a.\ \lambda^{*} b.\ \lambda^{*}\ f.\ f\ a\ b$
    \end{lstlisting}
  \end{framed}
  \caption{Pairs in \textbf{\em BI}}
  \label{fig:bi-pairs}
\end{figure}
The types of both these pair will be as shown in \ref{fig:bi-pairs-typing}

!!TODO: We have not yet described Curry-Howard isomorphism. We can use logic rules
decorate them with terms in our surface level lambda calculus and run algorithm M/W to infer the type

\begin{figure}[h]
  \centering
  \begin{framed}
    \begin{lstlisting}
      shPair : a $\sepimp$ b $\rightarrow$ (a $\sepimp$ b $\sepimp$ c) $\sepimp$ c
      sePair : a $\sepimp$ b $\sepimp$ (a $\sepimp$ b $\sepimp$ c) $\sepimp$ c
    \end{lstlisting}
  \end{framed}
  \caption{Typing for Pairs in \textbf{\em BI}}
  \label{fig:bi-pairs-typing}
\end{figure}


% This is kind of a big jump here.
% probably shift qualified types after linear logic section to have better continuity
\section{Linear logic with Qualified Types: Quill}
We start our work based on Quill [\cite{morris_best_2016}]. It tries
to implement linear types using qualified types. The novelty of using a qualified
types is that it gives a complete and decidable type inference system. By using
a modified version of Algorithm M we can compute principal types of the terms.
In reality due to higher ordered kind system, we may not be able to deduce the
type of the terms but we can work around it by annotating some or all parts of
the terms. This is usually done at a top level function declaration. Specifying types
also serves as some kind of documentation for the programmers.
The key idea of Morris is to introduce 2 types of predicates into the language: \texttt{Un} and \texttt{Fun}.
\texttt{Un $\tau$} implies that the type $\tau$ is unrestricted, meaning it does not
contain any resources or the resources that it captures can be easily duplicated and dropped.
The \texttt{Fun $\tau$} implies that the type $\tau$ is of a function type. The function
depending on its use, may or may not capture resources in its closure. Thus the functions
themselves can be of restricted or unrestricted type. In traditional sense of typeclasses
in haskell, we can think of the \texttt{Un} to be a typeclass with methods supporting the operation
of duplication and dropping.
\begin{figure}[h]
  \centering
  \begin{framed}
    \begin{minted}[escapeinside=||,mathescape=true]{haskell}
      class Un where
      dup  :: t |$\overset{!}{\rightarrow}$| (t |$\otimes$| t)
      drop :: t |$\overset{!}{\rightarrow}$| 1
    \end{minted}
  \end{framed}
  \caption{\texttt{Un} as a Typeclass}
  \label{fig:un-typeclass}
\end{figure}

Simple types such as integers and booleans are all of unrestricted type as
they can be duplicated or dropped freely.
While program resources such as file handles, database connections
should be treated as restricted type as we cannot freely duplicate it
or drop it. Although there would be certain portions of the program where we would
like to close the file handle or free the memory space allocated on the heap.
This is where we expected the bunched implications would play a crucial role.

Combining linear logic with qualified types in Quill
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
