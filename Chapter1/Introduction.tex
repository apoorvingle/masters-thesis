\chapter{Background Work}
% TODO should change title

\section{Type Inference Algorithm}
Algorithm W [\cite{damas_principal_1982}] and its varient algorithm M [\cite{lee_proofs_1998}]
are the basis of almost all modern statically typed programming languages. Type inference
is decidable in the sense, type checking algorithm always completes with a success or failure.
The algorithms also gurantee a most general typing scheme for an expression in
the simply typed lambda calculus extended with a polymorphic let construct having a term language
\begin{framed}
  \begin{flalign*}
    \text{Expressions}\ \ \ M, N ::= x: \sigma \mid \lambda x: \tau. M \mid M N \mid \texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N \nonumber
  \end{flalign*}
\end{framed}
and a type language specified by
\begin{framed}
  \begin{flalign*}
    \text{Types}\ \ \  \tau    &::= \alpha \mid \iota \mid \tau \rightarrow \tau \nonumber \\
    \text{Typing Scheme}\ \ \  &::= \tau \mid \forall \alpha. \tau \nonumber
  \end{flalign*}
\end{framed}
where $\alpha$ is a type variable, $\iota$ are primitive types in the language, $\rightarrow$
is a type constructor and $\sigma$ is a typing scheme.

Robinson's unification algorithm [\cite{robinson_machine-oriented_1965}] plays a key role
in ensuring that types are well formed. Its purely syntactic approach in creating
substitutions to unify types keeps the complete process elegent.
The algorithm works in an interesting way where the types of all well-typed terms can be
inferred automatically and if types are specified, the same algorithm can be used
to match the expression term.

\begin{figure}[h]
  \begin{framed}
    % var
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \sigma \in \Gamma$} \RightLabel{$[VAR]$}
        \UnaryInfC{$\Gamma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma \ \ \ \ \
          \Gamma_{x}, x: \sigma \vdash N: \tau$} \RightLabel{$[LET]$}
        \UnaryInfC{$\Gamma \vdash (\texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N) : \tau$}
      \end{prooftree}
    \end{minipage}

    % -> I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{$[\rightarrow I]$}
        \UnaryInfC{$\Gamma \vdash \lambda x. M : \tau \rightarrow \tau'$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \rightarrow \tau' \ \ \ \ \
          \Gamma \vdash N : \tau$} \RightLabel{$[\rightarrow E]$}
        \UnaryInfC{$\Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Logic Rules for Simply Typed Lambda Calculus}
  \label{fig:stlc-logic}
\end{figure}
The logical rules for type inference are shown in \ref{fig:stlc-logic}. $\Gamma$ is the
context or assumptions in which the expression is typed. The $[VAR]$ rule is tautology or a simple
lookup of the term variable $x$ in the context $\Gamma$. The $[LET]$ allows creating local
definitions within an expression term. $[\rightarrow I]$ and $[\rightarrow E]$ are rules
for typing lambda terms and application respectively.


% This simple type sytem is powerful in its
% expressivity and can encode a large variety of computations. The type checking algorithm
% asserts that undefined programs can be be detected statically i.e. without actually
% running the program or as famously known as ``well typed programs do not go wrong''.
% This is extremely useful for programmers who are building
% complex real world softwares. Bad programs can be eleminated instantaneously while
% being written using a mechanize technique so that the programmer can concentrate on designing the logic
% rather than fighting undefinedness of the programs. This creates an excellent feedback loop
% to the programmer while building large software systems. % TODO too generic should it be in introduction?
% TODO Give examples?


\section{Qualified Types}
Jones [\cite{jones_theory_1994}] proposed incorporating predicates in the type language.
Predicates are used to build constraints on the domain of the type of a term in the language expression.
It introduces additional layer between polymorphic and monomorphic typing of programs.
A modification of Milner-Damas algorithm to encorporate predicates ensures that type inference
is sound and complete. The types that satisfy all the predicates are called qualified types for the term.
Qualified types are powerful enough to expresses type classes with functional dependencies,
record types and subtyping [\cite{mark_type_2000}]. The type language is modified to contain
qualified types. $\Pi$ and $T$ range over finite set of predicates
\begin{figure}[h]
  \centering
  \begin{framed}
  \begin{flalign*}
    \text{Types}\ \ \ \tau              &::= \alpha \mid \iota \mid \tau \rightarrow \tau \nonumber \\
    \text{Qualified Types}\ \ \ \rho    &::= \Pi \Rightarrow \tau \nonumber \\
    \text{Type Scheme}\ \ \ \sigma      &::= \tau \mid \forall T. \rho \nonumber
  \end{flalign*}
\end{framed}
\caption{Qualified Types}
\label{fig:qualifed-types}
\end{figure}
\section{Linear Logic}
% TODO: points to cover
% what is linearity
% restricting weakening and contraction
Linear logic [\cite{girard_linear_1987}] promises to help cope with the resource and resource control problem.
It is refinement of classical intuistionistic logic. The core idea is that propositions
cannot be freely duplicated or discarded as in classical instuistionistic logic.
In formal terms, the contraction and weakening of logical rules are restricted.
This instigates a view of propositions to behave like resources. In real world software applications,
resources may not be freely copied or dropped from a program context.
Program entities like database connections, file handles or even
in memory shared state are pet peeves for programmers writing
industry grade software. Linear logic hopes to be a remedy for
these problems. If contraction and weakening is completely abandoned,
the system gets overly restrictive. Wadler describes a refinement of
linear logic based on Girard's Logic of Unity [\cite{wadler_taste_1993}, \cite{girard_unity_1993}].
It works around the problem of linear logic being too restrictive by allowing
instuistionistic rules in fragments. It can be considered as a disjoint union
of linear logic and intuistionistic logic. The grammar of classical intuistionistic logic is shown in \ref{fig:intu-logic-grammar}
where $A \rightarrow B$ implies implication, $A \times B$ is conjunction and $A \plus B$ is disjunction.
\begin{figure}
  \centering
  \begin{framed}
  \begin{flalign*}
    A, B, C ::= X \mid A \vdash B \mid A \rightarrow B \mid A \times B \mid A \plus B
  \end{flalign*}
\end{framed}
\caption{Grammar for Intuistionistic Logic}
\label{fig:intu-logic-grammar}
\end{figure}

In a pure linear logic setting, none of the assumptions can be used more than once (weakening prohibited) and they cannot be discarded
(contraction prohibited) This gives rise to a different flavor of all the logical connectives.
$A \rightspoon B$ describes the new implication meaning and is read as {\em``consume A to give B''} its logical rules
is given by $\rightspoon I$ and $\rightspoon E$. Similarly there are 2 kinds of connectives, multiplicative and additive that
arise in this logic system. More symbols are added inplace of $\plus$ and $\times$ to differentiate between the
multipicative conjunction and disjuntion ($\otimes$ and $\parr$), and additive conjuntion and disjunction ($\with $ and $\oplus$).
While working in intuistionistic linear logic, $\parr$ is dropped from the system. (TODO why is additive disjunction dropped? in ILL?)

\begin{figure}
  \centering
  \begin{framed}
    \begin{flalign*}
      A, B, C ::= X \mid \oc A \mid A \vdash B \mid A \rightspoon B \mid A \with B \mid A \otimes B
    \end{flalign*}
  \end{framed}
  \caption{Grammar for Intuistionistic Linear Logic}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    % -o I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\rightspoon I]$}
        \UnaryInfC{$\Gamma \vdash A \rightspoon B$}
      \end{prooftree}
    \end{minipage}
    % -o E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash  A \rightspoon B$}
        \AxiomC{$\Delta \vdash A$} \RightLabel{$[\rightspoon E]$}
        \BinaryInfC{$\Gamma, \Delta \vdash B$}
      \end{prooftree}
    \end{minipage}

  % & I
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A$}
      \AxiomC{$\Gamma \vdash B$} \RightLabel{$[\with I]$}
      \BinaryInfC{$\Gamma \vdash A \with B$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A \with B$} \RightLabel{$[\with E_1]$}
      \UnaryInfC{$\Gamma \vdash A$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A \with B$} \RightLabel{$[\with E_2]$}
      \UnaryInfC{$\Gamma \vdash B$}
    \end{prooftree}
  \end{minipage}

  % otimes I
  \begin{minipage}{.3\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A$}
      \AxiomC{$\Delta \vdash B$} \RightLabel{$[\otimes I]$}
      \BinaryInfC{$\Gamma, \Delta \vdash A \otimes B$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.7\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A \otimes B$} \RightLabel{$[\otimes E]$}
      \AxiomC{$\Gamma, A, B \vdash C$}
      \BinaryInfC{$\Gamma \vdash C$}
    \end{prooftree}
  \end{minipage}

    % % par I
    % \begin{minipage}{0.5\textwidth}
    %   \begin{prooftree}
    %     \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\parr I]$}
    %     \UnaryInfC{$\Gamma \vdash A \rightspoon B$}
    %   \end{prooftree}
    % \end{minipage}
    % % par E
    % \begin{minipage}{0.5\textwidth}
    %   \begin{prooftree}
    %     \AxiomC{$\Gamma \vdash  A \rightspoon B$}
    %     \AxiomC{$\Delta \vdash A$} \RightLabel{$[\parr E]$}
    %     \BinaryInfC{$\Gamma, \Delta \vdash B$}
    %   \end{prooftree}
    % \end{minipage}

    % oplus
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A$} \RightLabel{$[\oplus I_1]$}
        \UnaryInfC{$\Gamma \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{.20\textwidth}
      \begin{prooftree}
        \AxiomC{$\Delta \vdash B$} \RightLabel{$[\oplus I_2]$}
        \UnaryInfC{$\Delta \vdash A \oplus B$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.6\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash A \oplus B$}
        \AxiomC{$\Delta, A \vdash C$}
        \AxiomC{$\Delta, B \vdash C$}\RightLabel{$[\oplus E]$}
        \TrinaryInfC{$\Gamma, \Delta \vdash C$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Intuionistic Linear Logic Rules}
  \label{fig:linear-logic-rules}
\end{figure}

To escape linearity, exponential $\oc$ is used, which signifies that an assumption can
be duplicted or dropped without restriction. $\oc A$ can be thought of as {\em``as many A's as needed''}.
Thus the intitionsistic $A \rightarrow B$ can be encoded in linear logic by $\oc A \rightspoon B$.
Similarly $A \plus B$ would be represented as $\oc A \otimes \oc B$ and $A \times B$ would be represented as $A \with B$. We clearly see that
this is a much powerful system in contrast to classical intuistionistic logic because of its enhanced expressivity.

\section{Bunched Implications and $\alpha$ Lambda Calculus}

In intuitionistic linear logic, the context is considered as a list or a set. In the theory of
bunched implications, the context is treated as a tree in contrast to other logics Contexts are syntactically
combined using 2 connectives $,$ or a $;$ and are called bunches. The logic of Bunched Implication (\textbf{\em BI})
tries to glue together intuistionistic linear logic with intuistionistic logic by
permitting contexts connected with $;$ to undergo contraction and weakening while the ones connect with $,$
are prohibited to undergo contraction and weakening. $,$ and $;$ do not distributive over each other.
There are two flavours of implication---additive and multiplicative---which is related to the idea of conjunction.
\begin{framed}
\begin{minipage}{1.0\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma, A \vdash B$}
    \UnaryInfC{$\Gamma \vdash A \lozenge B$}
  \end{prooftree}
\end{minipage}
\end{framed}
In the logic of {\textbf{\em BI}} the question then faced is choosing what kind of
implication should be used inplace of $\lozenge$---the additive kind or the multiplicative kind.
O'Hearn and Pym [\cite{ohearn_logic_1999}] argue by introducing 2 kinds of arrows
and using them depending on the connectives used for the context. A multiplicative implication ($\sepimp$)
is used when the context is connected with a $,$ and an additive implication ($\rightarrow$) is used when the
context is connected using $;$. This gives rise to 2 rules
\begin{framed}
\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma, A \vdash B$} \RightLabel{$[\sepimp I]$}
    \UnaryInfC{$\Gamma \vdash A \sepimp B$}
  \end{prooftree}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$\Gamma; A \vdash B$} \RightLabel{$[\rightarrow I]$}
    \UnaryInfC{$\Gamma \vdash A \rightarrow B$}
  \end{prooftree}
\end{minipage}
\end{framed}

As we see in $[\sepimp I]$; $\Gamma, A$ cannot under go weakening or contraction to duplicate
or get rid of either $A$ or $\Gamma$. This hints to a notion that multiplicative implication ($\sepimp$)
exhibits property of the linear implication ($\rightspoon$). The linear implication cannot however
be directly converted to a multiplicative implication as the later does not exhibit properties of
counting the number of uses of its arguments. The logic of \textbf{\em BI} tries to combine the
additive logic i.e. intuistionistic logic with the multiplicative side i.e. intuistionistic linear logic seemlessly.
The multiplicative side can be used to model the behaviour of resources in the programming language
while the additive side would help the programmers fall back to the non-resource intuistionsitic parts.

$\alpha$ Lambda calculus[\cite{ohearn_resource_1999}] interprets the logic of \textbf{\em BI} and introduces 2 kinds of arrows by
modifiying the the syntax of lambda calculus.

$\sepimp$     : Arguments of function do not share resources with their arguments\\
$\rightarrow$ : Arguments of functions may share resources with their arguments\\

\begin{framed}
  \begin{flalign*}
    \text{Expressions}\ \ \ M, N ::= x: \sigma \mid \lambda^{\alpha} x: \tau. M \mid \lambda^{*} x: \tau. M \mid M N \mid \texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N \nonumber
  \end{flalign*}
\end{framed}

\begin{framed}
  \begin{flalign*}
    \text{Types}\ \ \  \tau    &::= \alpha \mid \iota \mid \tau \rightarrow \tau \mid \tau \sepimp \tau \nonumber \\
    \text{Typing Scheme}\ \ \  &::= \tau \mid \forall \alpha. \tau \nonumber
  \end{flalign*}
\end{framed}


\begin{figure}[h]
  \begin{framed}
    % var
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$x: \sigma \in \Gamma$} \RightLabel{$[VAR]$}
        \UnaryInfC{$\Gamma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \sigma \ \ \ \ \
          \Gamma_{x}, x: \sigma \vdash N: \tau$} \RightLabel{$[LET]$}
        \UnaryInfC{$\Gamma \vdash (\texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N) : \tau$}
      \end{prooftree}
    \end{minipage}

    % -> I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}, x: \tau \vdash M : \tau'$} \RightLabel{$[\sepimp I]$}
        \UnaryInfC{$\Gamma \vdash \lambda^{*} x. M : \tau \sepimp \tau'$}
      \end{prooftree}
    \end{minipage}
    % -> E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \sepimp \tau' \ \ \ \ \
          \Gamma \vdash N : \tau$} \RightLabel{$[\sepimp E]$}
        \UnaryInfC{$\Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}

    % -o I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma_{x}; x: \tau \vdash M : \tau'$} \RightLabel{$[\rightarrow I]$}
        \UnaryInfC{$\Gamma \vdash \lambda^{\alpha} x. M : \tau \rightarrow \tau'$}
      \end{prooftree}
    \end{minipage}
    % -o E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : \tau \rightarrow \tau' \ \ \ \ \
          \Gamma \vdash N : \tau$} \RightLabel{$[\rightarrow E]$}
        \UnaryInfC{$\Gamma \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Logic Rules for $\alpha$ Lambda Calculus}
  \label{fig:bi-logic}
\end{figure}



This is where $\alpha$ lambda calculus is introduced. we consider resources
magic wand? How does this connect to Linear logic?

\section{Linear logic with qualified types: Quill}
Combining linear logic with qualified types in Quill \cite{morris_best_2016}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
