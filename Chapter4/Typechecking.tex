\chapter{Type System and Type Inference}
In the following chapter we go over the type system using the notion of types and terms defined in previous
chapter. We describe type system based on the logic of \BI\ in \cref{sec:type-system}. We then describe a
syntax directed type system in \cref{sec:syntax-typing-rules} and give a modified algorithm $\M$ in \cref{sec:algorithm-m}.
First we give some conventions and notations that will be used throughout the sections that follow.

\section{Conventions and Notations}
Vector $\vec{t}$ is a shorthand for a finite set of variables $\{t_1, t_2, \dots, t_n\}$ and $\forall \vec{t}. Q => \tau$
abbreviates $\forall t_1 \dots \forall t_n. P_1 => \dots => P_m => \tau$.
The typing context $\mathcal{H}$ is a finite multiset of pairs of terms and types such that if two term variables occur
more than once, all of them must have same type. i.e. if $(x:\sigma) \in \mathcal{H}$ and $x:\sigma' \in \mathcal{H}$ then $\sigma \approx \sigma'$.
The equality ($\approx$) on typing schemes is up-to renaming of bound variables.
$\Gamma_{x}$ denotes the type assignment excluding the type variable $x$.
We write $\sigma = \Gamma(x)$ for the type scheme assigned to the term x in $\Gamma$.
\texttt{dom}($\Gamma$) is the set of identifiers in the type assignment i.e.
\texttt{dom}($\Gamma$) = $\{ x \mid (x:\sigma) \in \Gamma\}$.
$\Gamma \odot \Delta$ would mean that the contexts can either
be sharing union ($\Gamma \varoplus \Delta$) or separating union ($\Gamma \circledast \Delta$).
Similar to Jones' \citeyearpar{jones_theory_1994} qualified types and type schemes are overloaded Hindley-Milner calculi.
\begin{defn}[Free Type Variables]
  $\texttt{fvs}(\tau)$ is the set of free type variables in the type $\tau$\\
  $\texttt{fvs}(\sigma)$ is the set of free type variables in a typing scheme $\sigma = \forall \vec{t} Q. => \tau$.\\
  $\texttt{fvs}(\sigma) = (\texttt{fvs}(\tau) \cup \texttt{fvs}(Q)) \backslash \vec{t})${\color{red} Needs confirmation on \texttt{fvs}(Q).}\\
  $\texttt{fvs}(\Gamma)$ is the set of free type variables in the type assignment $\Gamma$.\\
  $\texttt{fvs}(\Gamma) = \bigcup_{x \in \texttt{dom}(\Gamma)} \{ \texttt{fvs}(\Gamma(x)) \}$
\end{defn}
\begin{defn}[Typing Judgment]
The expression $P \mid \Gamma \vdash M : \sigma$ denotes the assertion that the term $M$ has a typing scheme $\sigma$
when the predicates in $P$ are satisfied and the free type variables in $M$ are specified in type assignment $\Gamma$.
\end{defn}

\section{Type System}\label{sec:type-system}
% Structural Rules
% Connective Rules
% forall, => Qualified type rules
We split our type system into multiple parts for legibility. The first part includes structural rules
shown in \cref{fig:structural-rules} and the second part includes connectives with
introduction and elimination rules shown in \cref{fig:typing-rules}.

% structural rules
\begin{figure}[h]
  \begin{framed}
    % ID
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{} \RightLabel{[ID]}
        \UnaryInfC{$P \mid x^{\vec{y}} : \sigma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % EXCH
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$\Gamma \odot \Delta \vdash M : \sigma$} \RightLabel{[EXCH]}
        \UnaryInfC{$P \mid \Delta \odot \Gamma \vdash M : \sigma $}
      \end{prooftree}
    \end{minipage}
        % CTR UN
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \circledast \Delta \vdash M : \sigma$}
        \AxiomC{$P'\vdash \Delta\ \texttt{un}$} \RightLabel{[CTR-UN]}
        \BinaryInfC{$P \mid \Gamma \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}
    % WKN UN
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \sigma$}
        \AxiomC{$P' \vdash \Delta\ \texttt{un}$} \RightLabel{[WKN-UN]}
        \BinaryInfC{$P \mid \Gamma \circledast \Delta \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}
    % CTR Sh
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \varoplus \Delta \vdash M : \sigma$} \RightLabel{[CTR-SH]}
        \AxiomC{$P \mid \Gamma \vdash M : \sigma$} \RightLabel{[CTR-SH]}
        \BinaryInfC{$P \mid \Gamma \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}
    % WKN Sh
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P  \mid \Gamma \vdash M : \sigma$} \RightLabel{[WKN-SH]}
        \UnaryInfC{$P \mid \Gamma \varoplus \Delta \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}
   \end{framed}
    \caption{Structural Typing Rules}
    \label{fig:structural-rules}
  \end{figure}

The tautology rule ([ID]) is a simple type assignment lookup for checking the type of the term.
The exchange rule ([EXCH]) justifies the fact that the order in which the type assignments are witnessed
in the multiset is insignificant and we can commute the individual term typing schemes within the multiset context
with no effect to the typing derivations. The weakening and contraction rules are made explicit in contrast to standard
Hindley-Milner type system. The contraction sharing rule [CTR-SH] and weakening sharing rule [WKN-SH]
says that we can duplicate or drop certain pairs of type assignments as per our convenience as we know they are in sharing with other
terms that remain in the context. The contraction separation rule [CTR-UN] and weakening separation rule [WKN-SH] can be
applied to terms only if we can prove that they are of unrestricted type which is captured by introducing
the ($\Delta$ \texttt{un}) predicate on the type that is dropped or duplicated.

% Connective rules
  \begin{figure}[h]
    \begin{framed}
    % let
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \sigma$}
        \AxiomC{$P' \mid \Gamma'_{x} \sqcup x: \sigma \vdash N: \tau$} \RightLabel{[LET]}
        \BinaryInfC{$P \cup P' \mid \Gamma \sqcup \Gamma' \vdash \Let{x}{M}{N}: \tau$}
      \end{prooftree}
    \end{minipage}
    \newline\newline\newline
    % forall I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \sigma$}
        \AxiomC{$t \notin \texttt{fvs}(\Gamma) \cup \texttt{fvs}(P)$}\RightLabel{$[\forall I]$}
        \BinaryInfC{$P \mid \Gamma \vdash M: \forall t. \sigma$}
      \end{prooftree}
    \end{minipage}
    % forall E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \forall t.\sigma$}\RightLabel{$[\forall E]$}
        \UnaryInfC{$P \mid \Gamma \vdash M: [\tau \backslash t] \sigma $}
      \end{prooftree}
    \end{minipage}
    \newline\newline\newline
    % => I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P, \pi \mid \Gamma \vdash M : \rho$} \RightLabel{$[=> I]$}
        \UnaryInfC{$P \mid \Gamma \vdash M : \pi \Rightarrow \rho$}
      \end{prooftree}
    \end{minipage}
    % => E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \pi \Rightarrow \rho$}
        \AxiomC{$P \Rightarrow \pi$} \RightLabel{$[=> E]$}
        \BinaryInfC{$P \mid \Gamma \vdash M: \rho$}
      \end{prooftree}
    \end{minipage}
    \newline\newline\newline
    % -&> I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \Rightarrow \texttt{ShFun}\ \phi\ \ \ \ \
          P \vdash \Gamma \geq \phi$}\noLine
        \UnaryInfC{$P \mid \Gamma^{[\emptyset\mapsto \{x\}]},x^{\text{Vars}(\Gamma)}: \tau \vdash M : \tau'$}\RightLabel{$[\rightarrow I]$}
        \UnaryInfC{$P \mid \Gamma \vdash \lambda^{\alpha}x. M : \phi \tau \tau'$}
      \end{prooftree}
    \end{minipage}
    % -&> E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P => \texttt{ShFun}\ \phi\ \ \ \ \
          P \vdash \Gamma \geq \phi$}\noLine
        \UnaryInfC{$P \mid \Gamma \vdash M : \phi \tau \tau'\ \ \ \ \
          P \mid \Delta \vdash N : \tau'$} \RightLabel{$[\rightarrow E]$}
        \UnaryInfC{$P \mid \Gamma \varoplus \Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
    \newline\newline\newline
    % -*> I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P => \texttt{SeFun}\ \phi\ \ \ \ \ P \vdash \Gamma \geq \phi$}\noLine
        \UnaryInfC{$P \mid \Gamma,x^{\emptyset}: \tau \vdash M : \tau'$} \RightLabel{$[\sepimp I]$}
        \UnaryInfC{$P \mid \Gamma \vdash \lambda^{*}x. M : \phi \tau \tau'$}
      \end{prooftree}
    \end{minipage}
    % -*> E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P => \texttt{SeFun}\ \phi\ \ \ \ \ P \vdash \Gamma \geq \phi$}\noLine
        \UnaryInfC{$P \mid \Gamma \vdash M : \phi \tau \tau'\ \ \ \ P \mid \Delta \vdash N : \tau$} \RightLabel{$[\sepimp E]$}
        \UnaryInfC{$P \mid \Gamma \circledast \Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
    \caption{Connective Typing Rules}
    \label{fig:typing-rules}
\end{figure}

The rules of [$\rightarrow$I] and [$\sepimp$I] describes the abstraction over shared and
separating resources respectively, while [$\rightarrow$E] and [$\sepimp$E] is the application
rule for shared and separating resources respectively. [$=>$I] and [$=>$E] are the rules for
qualified types that would add constraints on the type being computed. [$\forall$I] introduces
polymorphism and [$\forall$E] eliminates it. We assume that the free type variables that
would be substituted in the type scheme would not interfere with the sharing and separation
of resources of the fully concretized type. The $\lambda$ abstractions $\lambda^{*} x. M$ and $\lambda^{\alpha}.M$
have a function type $\ShFun{\phi}$ or $\SeFun{\phi}$ only if it is more restricting that its environment.
This is specified in the judgments $\cdot \geq \cdot$. To avoid name shadowing, we would assume that
the binders introduce fresh names. The reason to use multisets can now be understood
as the elimination rule ([$\rightarrow$E]) can be expressed by simply duplicating the typing
judgments that are in sharing after we split the type assignment into two parts,
for typing each sub expression individually.{\color{red} I am not sure about this/can be better articulated}.
\begin{figure}[h]
  \begin{framed}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P => \texttt{Un}\ \tau$}\RightLabel{[\texttt{Un}-$\tau$]}
      \UnaryInfC{$P \vdash \tau\ \texttt{un}$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P,\pi \vdash \rho\ \texttt{un}$}\RightLabel{[\texttt{Un}-$\rho$]}
      \UnaryInfC{$P \vdash \pi => \rho\ \texttt{un}$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P, \texttt{Un}\ t \vdash \sigma\ \texttt{Un}$}\RightLabel{[\texttt{Un}-$\sigma$]}
      \UnaryInfC{$P \vdash \forall t.\sigma\ \texttt{un}$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$\bigwedge_{x:\sigma \in \Gamma}P \vdash \rho\ \texttt{un}$}\RightLabel{[\texttt{Un}-$\Gamma$]}
      \UnaryInfC{$P \vdash \Gamma\ \texttt{un}$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P => \tau \geq \phi$}\RightLabel{[$\geq$-$\tau$]}
      \UnaryInfC{$P \vdash \tau \geq \phi$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P,\pi \vdash \rho \geq \phi$}\RightLabel{[$\geq$-$\rho$]}
      \UnaryInfC{$P \vdash (\pi => \rho) \geq \phi$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P, \texttt{Un}\ t \vdash \sigma \geq \phi$}\RightLabel{[$\geq$-$\sigma$]}
      \UnaryInfC{$P \vdash (\forall t.\sigma) \geq \phi$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$\bigwedge_{x:\sigma \in \Gamma}P \vdash \rho \geq \phi$}\RightLabel{[$\geq$-$\Gamma$]}
      \UnaryInfC{$P \vdash \Gamma \geq \phi$}
    \end{prooftree}
  \end{minipage}
\end{framed}
  \caption{Typing Rules for Base cases}
  \label{fig:bi-base-typing-rules}
\end{figure}
The rules given in \cref{fig:bi-base-typing-rules}
are convenience rules for base cases that compute predicate constraints for types within a context.
The $P \mid \cdot \geq \cdot$ lifts $\geq$ predicate into the typing environment.


\section{Kind Inference}
Our system supports introduction of new types via type constructors. We include a
richer kind system for this purpose. A modified version of Robinson's algorithm \citeyearpar{robinson_machine-oriented_1965}
is used in order to deduce the most general unifier for type constructors. Our treatment to type unification
is similar to Jones' \citeyearpar{jones_system_1993}.
Formally, we define $S$ to be the {\it most general unifier} for type constructors $T$ and $T'$ if:
\begin{enumerate}
  \item $S$ is a unifier for $C$ and $C'$.
  \item For every unifier $S'$ of $C$ and $C'$ we can write $S'$ in a form of
    $R S$ where $R$ is a kind preserving substitution.
\end{enumerate}
We write $C \overset{S}{\sim}_{\kappa} C'$ for assertion that $S$ is the unifier
of the constructor types $C, C' \in C^{\kappa}$. The rules in \cref{fig:unify-types}
describe the unification algorithm for type constructors. [Var] and [Var'] contain
and additional constraint of the type variable $t$ to not be free in the type constructor's $C$
type variables to ensure the unification does not lead to infinite types.

\begin{figure}[h]
  \begin{framed}
    \begin{minipage}[l]{0.5\linewidth}
      \begin{flalign*}
        t \overset{id}{\sim}_{\kappa} t \tag{[ID-Var]}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}[r]{0.5\linewidth}
      \begin{flalign*}
        \tau \overset{id}{\sim}_{\kappa} \tau \tag{[ID-Const]}
      \end{flalign*}
    \end{minipage}

    \begin{minipage}[l]{0.5\linewidth}
      \begin{flalign*}
        t \overset{[C/t]}{\sim}_{\kappa} C, t \notin \texttt{fvs}(C) \tag{[Var]}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}[r]{0.5\linewidth}
      \begin{flalign*}
        C \overset{[C/t]}{\sim}_{\kappa} t, t \notin \texttt{fvs}(C) \tag{[Var']}
      \end{flalign*}
    \end{minipage}

    \begin{minipage}[c]{1.0\linewidth}
      \begin{prooftree}
        \AxiomC{$C \overset{S}{\sim}_{\kappa'\rightarrow \kappa} D$}
        \AxiomC{$S C' \overset{S'}{\sim}_{\kappa'} S D'$}\RightLabel{[Apply]}
        \BinaryInfC{$CC' \overset{SS'}{\sim}_{\kappa} DD'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Kind Preserving Unification of Type Constructors}
  \label{fig:unify-types}
\end{figure}

\section{Syntax Directed Typing rules}\label{sec:syntax-typing-rules}
The type system explained in the previous section are not syntax directed and will not be fit
to develop a type inference algorithm as the typing rules and syntactic forms should have one-to-one
correspondence. In this section we will define syntax directed typing rules
that will simplify our type inference system shown in \cref{fig:syntax-typing-rules}

We define generalization and instantiation to express introduction and elimination of polymorphism in our
syntax direct typing rules as follows:
\begin{defn}[Instantiation]
  For a type scheme $\sigma := \forall \vec{t}. P => \tau'$, we say $(Q => \tau)$ is
  an instance of $\sigma$ and write it as $(Q => \tau) \sqsubseteq \sigma$, if there exists a $\vec{v}$
  such that $\tau = [\vec{v} / \vec{t}] \tau'$ and $Q = [\vec{v} / \vec{t}]P$.
\end{defn}

\begin{defn}[Generalization]
  For a type assignment $\Gamma$ and qualified type $\rho$, we define type scheme
  $\texttt{Gen}(\Gamma, \rho) = \forall (\texttt{fvs}(\rho) \backslash \texttt{fvs}(\Gamma)). \rho$.
\end{defn}

\begin{defn}[Qualified Type Scheme]
  A qualified type scheme is a pair of type scheme with a set of predicates written as $(P \mid \sigma)$,
  where $\sigma = \forall \vec{t}. Q => \tau$.
\end{defn}
\begin{defn}[Qualified Type Scheme Instantiation]
  For two qualified type schemes $(P \mid \sigma)$ where $\sigma = \forall \vec{t}. Q => \tau$ and
  $(P' \mid \sigma')$ where $\sigma' = \forall \vec{t'}. Q' => \tau'$ we say $(P' \mid \sigma')$ is an
  instance of $(P \mid \sigma)$ iff there exists $\vec{v}$ such that $\tau' = [\vec{v}/ \vec{t}]\tau$ and
  $P',Q' => P, [\vec{v}/ \vec{t}]Q$. We write it as $(P' \mid \sigma') \sqsubseteq (P \mid \sigma)$. A type scheme
  $\sigma$ is an abbreviation of $(\emptyset \mid \sigma)$.
\end{defn}

Similar to Quill typing system \citep{morris_best_2016} elimination of polymorphism [$\forall$E] and qualified
types[$=>$E] is always done in the [Var$^s$], introduction of polymorphism [$\forall$I] and qualified types[$=>$I] is
done at let bindings [Let$^s$]. This collapses the rules [$\forall$E], [$=>$E] and [ID] in one rule [VAR$^s$] where
we use instantiation, and [$\forall$I], [$=>$I] and [Let] in one rule [Let$^s$] where we use generalization.
[$\sepimp$I$^s$] is used in occurence of $\lambda^{*}$, and [$\rightarrow$I$^s$] is used in occurence of $\lambda^{\alpha}$.
We would add the introduced abstraction variable into the sharing context in case of [$\rightarrow$I$^s$].
The type variable $\tau$ in both [$\sepimp$I$^s$] and [$\rightarrow$I$^s$] are new. We collapse the application rules
[$\sepimp$E] and [$\rightarrow$E] into one rule [App$^s$] where we check for sharing of the used variables in both
the expressions and then assign a predicate of $\texttt{ShFun}$ or $\texttt{SeFun}$ depending on whether the variables
are shared or not. The \texttt{un} predicates are added to the types of the terms that are not used directly in the expression
or which are not in sharing with the terms used.
\begin{figure}[h]
  \begin{framed}
    % VAR^s
    \begin{minipage}{1.0\textwidth}
      \begin{prooftree}
        \AxiomC{$P \vdash \Gamma_{\vec{y}}\ \texttt{un}$}
        \AxiomC{$(P => \tau) \sqsubseteq \sigma$} \RightLabel{[VAR$^s$]}
        \BinaryInfC{$P \mid \Gamma, x^{\vec{y}} : \sigma \vdashs x : \tau $}
      \end{prooftree}
    \end{minipage}
    \newline\newline\newline
    % Let^s
    \begin{minipage}{1.0\textwidth}
      \begin{prooftree}
        \AxiomC{$Q \mid (\Gamma_x' \varoplus \Gamma_x'') \circledast \Delta \vdashs M: v\ \ \ \ \
          P \vdash \Delta\ \texttt{un}$}
        \noLine
        \UnaryInfC{$P \mid (\Gamma_x \sqcup x:\sigma) \varoplus \Gamma_x'' \circledast \Delta \vdashs N:\tau\ \ \ \ \
          \sigma = \texttt{Gen}(\{\Gamma' \varoplus \Gamma_x'' \circledast \Delta \}, Q => v)$}\RightLabel{[Let$^s$]}
        \UnaryInfC{$P \mid (\Gamma \circledast \Gamma') \varoplus \Gamma'' \circledast \Delta \vdashs (\Let{x}{M}{N} : \tau) $}
      \end{prooftree}
    \end{minipage}
    \newline\newline\newline
    % -*>I^s
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P => \SeFun{\phi}$}
        \AxiomC{$P \vdash \Gamma \geq \phi$}\noLine
        \BinaryInfC{$\ \ \ \ \ \ \ P \mid \Gamma \circledast x^{\emptyset}:\tau \vdashs M: v\ \ \ \ \ \ \ $} \RightLabel{[$\sepimp$I$^s$]}
        \UnaryInfC{$P \mid \Gamma \vdashs \lambda^{*}x. M : \phi \tau v$}
      \end{prooftree}
    \end{minipage}
    % -&>I^s
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P => \ShFun{\phi}\ \ \ \ \ P \vdash \Gamma \geq \phi$}\noLine
        \UnaryInfC{$P \mid \Gamma^{[\emptyset \mapsto \{x\}]} \varoplus x^{\texttt{Vars}(\Gamma)}:\tau \vdashs M: v$}\RightLabel{[$\rightarrow$I$^s$]}
        \UnaryInfC{$P \mid \Gamma \vdashs \lambda^{\alpha}x. M : \phi \tau v$}
      \end{prooftree}
    \end{minipage}
    \newline\newline\newline
    % App^s
    \begin{minipage}{1.0\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \circledast \Delta \vdashs M: \phi v \tau\ \ \ \ \
          P \mid  \Gamma' \circledast \Delta \vdashs N: v$}
        \AxiomC{$P \vdash \Delta\ \texttt{un}$}\noLine
        \BinaryInfC{$(\Gamma \varoplus \Gamma' \wedge (P => \ShFun{\phi}))
          \vee (\Gamma \circledast \Gamma' \wedge (P => \SeFun{\phi}))$}\RightLabel{[App$^s$]}
        \UnaryInfC{$P \mid \Gamma \sqcup \Gamma' \circledast \Delta \vdashs M N: \tau$}
      \end{prooftree}
    \end{minipage}
    % sum types
    % \begin{minipage}{0.5\textwidth}
    %   \begin{prooftree}
    %     \AxiomC{$P \mid  \Gamma \vdashs M: \tau$}\RightLabel{[$\oplus_l$I$^s$]}
    %     \UnaryInfC{$P \mid \Gamma \vdashs \texttt{inl}\ M: \tau \oplus \tau' $}
    %   \end{prooftree}
    % \end{minipage}
    % \begin{minipage}{0.5\textwidth}
    %   \begin{prooftree}
    %     \AxiomC{$P \mid  \Gamma \vdashs M: \tau'$}\RightLabel{[$\oplus_r$I$^s$]}
    %     \UnaryInfC{$P \mid \Gamma \vdashs \texttt{inr}\ M: \tau \oplus \tau' $}
    %   \end{prooftree}
    % \end{minipage}
    % \begin{minipage}{1.0\textwidth}
    %   \begin{prooftree}
    %     \AxiomC{$P \vdash  \Delta\ \texttt{un}\ \ \ \ \ 
    %       P \mid  \Gamma \circledast \Delta \vdashs M: \tau \oplus \tau'$}\noLine
    %     \UnaryInfC{$P \mid  \Gamma'_x \circledast \Delta,x:\tau \vdashs N: v\ \ \ \ \
    %       P \mid  \Gamma'_y \circledast \Delta, y:\tau' \vdashs N': v$}\RightLabel{[$\oplus$E$^s$]}
    %     \UnaryInfC{$P \mid (\Gamma \sqcup \Gamma') \circledast \Delta \vdashs \Case{M}{\{\texttt{inl}\ x \mapsto N; \texttt{inr}\ y \mapsto N'\}}:v$}
    %   \end{prooftree}
    % \end{minipage}
    % \begin{minipage}{1\linewidth}
    %   \TODO{get rid of the red symbols}
    % \end{minipage}
    \end{framed}
  \caption{Syntax Directed Typing Rules}
  \label{fig:syntax-typing-rules}
\end{figure}

The [Let$^s$] rule defines an expression within another expression locally i.e. x would
not be in scope other than using it in $N$. We divide the typing context into multiple parts.
$\Gamma$ contains the variables that exists exclusively in $M$ and $\Gamma'$ which
are exclusively in $N$. $\Gamma''$ is common to both $M$ and $N$ while $\Delta$ is not used in both the expressions.
Thus $\Gamma$ and $\Gamma'$ will be completely separate from each other while $\Gamma''$ would be in sharing with both $\Gamma$ and $\Gamma'$.
$\Delta$ would have to be unrestricted as it is not being used either in $M$ or in $N$. The sharing of $x$ with $\Gamma$ would depend on
whether $\Gamma$ and $\Gamma'$ are completely disjoint or empty. For the application rule [App$^s$] the type assignment $\Gamma$ would contain
variables for $M$ and $\Gamma'$ for $N$. If they are completely separate, it would be a separating function application and $M$ would be
assigned a type $\tau' \sepimp \tau$ else, they would have to be completely sharing and M would be assigned a type $\tau' \rightarrow \tau$.
The conditions do not clearly look as if they are syntax directed and in the cases where the type checker cannot directly infer if the
resources used are separate or shared, the user would be expected to provide it using type annotations  {\color{red} meh.}.

\begin{theorem}[Soundness of $\vdash^s$]
  If $P \mid \Gamma \vdash^s M:\tau$ then $P \mid \Gamma \vdash M : \tau$
\end{theorem}
The soundness property captures the essence that derivations in the syntax directed type system follow the original type system.
The proof is by induction on derivation of $P \mid \Gamma \vdash^s M:\tau$ and is detailed in \cref{prf:soundness-syntax-directed}.

The syntax directed typing system is however not complete i.e. the syntax directed typing may not be able to derive the same
typing judgement as the original system. \TODO{What is the reason? How does this relate to future work? needs elaboration}

\section{Type Inference and Algorithm $\M$}\label{sec:algorithm-m}
We now describe the type inference algorithm based on the previously defined syntax directed
type system. We use a variation of algorithm $\M$ [\cite{lee_proofs_1998}] for type inference.
We address three independent concerns in the type inference algorithm.
The first being treatment of polymorphism to be same as Hindley-Milner style. The second, we introduce
\texttt{Un} predicates for types that are unrestricted. We track this with the help of carrying a
collection of used variables throughout the algorithm which detects whether a variable is discarded
or used multiple types. The third being accounting for sharing of the variables.
The complete algorithm is outlined in \cref{fig:algorithm-m}. The input to the algorithm includes the term $M$ whose
type has to be inferred, $\tau$ is the expected type of the term, $S$ is the current substition and the
sharing information $\Psi$. The output includes the set of new predicates $P$ that are generated,
the new set of substitutions $S'$, the used variables $\Sigma$, and the new sharing information $\Psi'$.
The type variables $u$ with a subscript denote fresh variables.

We now formally define $\Psi$, the sharing information that is defined as a pair of variable and a collection of variables it is in sharing with.
$\Psi(x)$ will denote all the variables that $x$ is in sharing with.  Domain of $\Psi$ defined as
$\texttt{dom}(\Psi) = \{x \mid (x, \bar{y}) \in \Psi \}$, where $\bar{y}$ is the collection of variables shared with x.
One can think of $\Psi$ similar to $\Gamma$, but instead
of the type of the variable it contains the sharing information.
Extending the sharing for a variable will be denoted by $\Psi(x) + y$, which would mean the variable $y$ is in sharing with $x$. Because the sharing
operation is a reflexive, symmetric and transitive we observe certain properties given below to be true.
\begin{flalign*}
 &\forall_{x \in \texttt{dom}(\Psi)}\ x \in \Psi(x) \tag{reflexive}\\
 &\forall_{x,y \in \texttt{dom}(\Psi)}\ \text{if}\ y \in \Psi(x)\ \text{then}\ x \in \Psi(y) \tag{symmetric}\\
 &\forall_{x,y,z\in \texttt{dom}(\Psi)}\ \text{if}\ y \in \Psi(x) \wedge z \in \Psi(y)\ \text{then}\ z \in \Psi(x)\tag{transitive}
\end{flalign*}
Thus sharing relation defines an equivalence relation on $\texttt{dom}(\Psi)$.

{\color{red} needs more formalization? state some
properties. Similar to what we do while defining $\Gamma$}.

We define some auxilary functions in \cref{fig:aux-defs} to lift predicates into the type system.
$\texttt{Weaken}(x, \sigma, \Sigma)$ adds the unrestricted predicate to the type $\sigma$
if it does not belong to $\Sigma$. $\texttt{Un}(\Gamma)$ adds an unrestricted
predicate to all the types of the variables that are in the domain of $\Gamma$. $\mathcal{C}(\Psi, \Sigma)$ is the transitive
closure of sharing relation for all the variables that are in sharing with all the variables in $\Sigma$.

% Explain each case of algorithm M here.
% Var
The first case describes the variable case, where we are given the variable identifier and
the expected type. We try to unify the expected type $\tau$ with the derived type scheme
$\nu$ from the type assignment $\Gamma$. The return values of the algorithm are
a new set of predicates which are nothing but instantiated version of the predicates
obtained from the typing scheme, the variable $x$ being used and the new
substitution which is combination of the unification algorithms output and the original
substitution. There is no change in the sharing information and $\Psi$ is returned as is.

% \&y
In next case of sharing function introduction rule $\lambda^{\alpha}x.M$, as per the [$\rightarrow$I] rules, the entitites returned
are union of four predicate categories. The first is assigning a the predicate of the function to be
a sharing function $\ShFun{u_1}$, where $u_1$ is a new type variable for the type of function argument $x$.
The second assigning the function to be less restricting than the other variables in the typing assignment $\Gamma$.
The third, assigning an unrestricted predicate to the binding variable $x$ if it has not been used
anywhere in the lambda body $M$, which is done by the $\texttt{Weaken}$ function and the fourth
being the predicates generated by recursively type checking the body of the lambda expression $M$.
We create sharing links for $x$ with all the variables within the typing context $\Gamma$ in updated
$\Psi''$.
% \*x
The case of separating function $\lambda^{*}x. M$ is very similar to the previous case of $\lambda^{\alpha}x. M$ except
the that there is no sharing information to be updated as the argument to the function is
separate from its body and the function predicate assigned is $\SeFun{u_1}$ to denote this very
separating relation instead of $\ShFun u_1$

% App
In the application case the algorithm typechecks the subexpressions $M$ as a function type having
an input of the type of $N$. The additional check done here is to identify whether $M$ has a sharing
application or a separating application. If all the variables used in $M$ are also used in $N$ then
it is a sharing application i.e. $M$ is assigned a sharing function predicate $\ShFun{}$
else if the used variables in $M$ are disjoint to the variables that
are shared by $N$ or if the variables shared by variables in $M$ are disjoint to the variables
that are used in $N$, $M$ is assigned the predicate type $\SeFun{}$. Incase of a separating function
application, the variables that are used in both are marked as unrestricted. This is captured by
$\texttt{Un}(\Gamma|_{\Sigma \cap \Sigma'})$. $\Gamma|_{\Sigma}$ means the typing assignment $\Gamma$
restricted to the variables in $\Sigma$.
% Let
In the polymorphic \texttt{let} case we first check for the type of the expression $M$ and
ensure that the variable binding $x$ is not usd in it to avoid recursive definition which would
lead to infinite types. We then generalize the type to $\sigma$ and then check the type of expression $N$
by expanding the type assignment $\Gamma$ with the variable $x$ and type scheme $\sigma$.

% \begin{framed}\centering
%   $\tau \sim \tau' => \exists S. S \tau = \tau'$
% \end{framed}

\begin{figure}[h]
  \begin{framed}
    \begin{minipage}[ht]{1\linewidth}
      \centering
      \fbox{
        $\M(S, \Psi, \Gamma \vdash M : \tau) = P, S', \Sigma, \Psi'$
      }
    \end{minipage}
    % x var
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, \Psi, \Gamma \vdash x : \tau) &= ([\vec{u} / \vec{t}]P), S' \circ S, \{x\}, \Psi \\
        \text{where}\ (x : \forall \vec{t}. P => \nu) &\in S \Gamma \\
        S' &= \Unf([\vec{u} / \vec{t}]\nu, S \tau)
      \end{flalign*}
    \end{minipage}

    % \&x. M: t
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, \Psi, \Gamma \vdash \lambda ^{\alpha} x. M : \tau) &= \{P \cup Q \}, S', \Sigma \backslash x, \Psi''  \\
        \text{where}\ P; S'; \Sigma; \Psi' &= \M(\Unf(\tau, u_1 u_2 u_3) \circ S, \Psi, \Gamma, x:u_2 \vdash M: u_3) \\
        Q &= \{\ShFun{u_1}\} \cup \text{Leq}(u_1, \Gamma|_{\Sigma}) \cup \text{Weaken}(x, u_2, \Sigma)\\
        \Psi'' &= \{\forall_{y \in \texttt{dom}(\Psi')}. \Psi'(y) + x\} \cup \{x \mapsto \{ x \}\}
      \end{flalign*}
    \end{minipage}

    % \*x. M: t
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, \Psi, \Gamma \vdash \lambda ^{*} x. M : \tau) &= \{ P \cup Q \}, S', \Sigma \backslash x, \Psi''\\
        \text{where}\ P; S'; \Sigma; \Psi' &= \M(\Unf(\tau, u_1 u_2 u_3) \circ S, X; \Gamma, x:u_2 \vdash M: u_3) \\
        Q &= \{\SeFun{u_1}\} \cup \text{Leq}(u_1, \Gamma\mid_{\Sigma}) \cup \text{Weaken}(x, u_2, \Sigma)\\
        \Psi'' &= \Psi' \cup \{x \mapsto \{ x \}\}
      \end{flalign*}
    \end{minipage}

    % M N: t
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, \Psi, \Gamma \vdash M N : \tau) &= \{ P \cup P' \cup Q \}, R', \Sigma \cup \Sigma', \Psi'' \\
        \text{where}\ P; R; \Sigma; \Psi' &= \M(S, \Psi, \Gamma \vdash M:  u_1 u_2 \tau) \\
        P'; R'; \Sigma'; \Psi'' &= \M(S R, \Psi', S \Gamma \vdash N: u_2)\\
        \text{if}\ \mathcal{C}(\Gamma, \Psi'', \Sigma) &= \mathcal{C}(\Gamma, \Psi'', \Sigma')\\
        \text{then}\ Q &= \{\ShFun{u_1}\} \\
        \text{else}\ \text{if}\ &(\Sigma \# \mathcal{C}(R\Gamma, \Psi'', \Sigma')\ \text{and}\ \Sigma' \# \mathcal{C}(R\Gamma, \Psi'', \Sigma))\\
        &\text{then}\ Q = \{\SeFun{u_1}\}\\
        \text{else}\ Q &= \{\SeFun{u_1}\} \cup \text{Un}(\Gamma|_{\Sigma \cap \Sigma'})
      \end{flalign*}
    \end{minipage}

    % let x = M in N: t
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, \Psi, \Gamma \vdash \Let{x}{M}{N} : \tau) &= (P \cup Q), R', \Sigma \cup \{\Sigma' \backslash x \}, \Psi'' \\
        \text{where}\ P; R; \Sigma; \Psi' &= \M(S, \Psi, \Gamma \vdash M:u_1)  \\
        \sigma &= \text{GenI}(R\Gamma; R(P => u_1)) \\
        P'; R'; \Sigma'; \Psi'' &= \M(R, \Psi', \Gamma, x:\sigma \vdash N : \tau) \\
        Q &= \text{Un}(\Gamma|_{\Sigma \cap \Sigma'}) \cup \text{Weaken}(x, \sigma, \Sigma')
      \end{flalign*}
    \end{minipage}

    % \begin{minipage}{1\linewidth}
    %   \begin{flalign*}
    %     \M(S, X;\Gamma \vdash \Case{M}{\{p_i \mapsto N_i\}_i}) &= (P_M \cup \{P_i\}), Q, \Sigma_M \cup \{\Sigma_i\} \nonumber\\
    %     \text{where}\ P_M, R_M, \Sigma_M &= \M(S, X;\Gamma \vdash M:u_1 \oplus u_2 \oplus \cdots \oplus u_n) \nonumber \\
    %     P_1, R_1, \Sigma_1 &= \M(R_M, X;\Gamma \vdash p_1:u_1 \vdash N_1: v) \nonumber \\
    %     P_i, R_i, \Sigma_i &= \M(R_{i-1}, X;\Gamma \vdash p_i:u_i \vdash N_i: v) \nonumber \\
    %     \Sigma' &= \bigcup_{i,j \leq n} (\Sigma_i \cap \Sigma_{j}) \nonumber\\
    %     Q &= \text{Un}(\Gamma|_{\Sigma'}) \cup \{\text{Weaken}(p_i, u_i, \Sigma_i)\}
    %   \end{flalign*}
    % \end{minipage}
  \end{framed}
  \caption{Type Inference Algorithm $\mathcal{M}$}
  \label{fig:algorithm-m}


\end{figure}
\begin{figure}[h]
  \begin{framed}
    \begin{minipage}{0.5\linewidth}
      \begin{flalign*}
        Leq(\phi, \Gamma)  = \bigcup_{(x:\tau) \in \Gamma} \{P \mid P \vdash \phi \leq \tau \}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{flalign*}
        \texttt{Un}(\Gamma)  = \bigcup\{P \mid (y:\sigma) \in \Gamma, P \vdash \sigma\ \texttt{un} \}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{flalign*}
        \texttt{Weaken}(x, \sigma, \Sigma)  = \begin{cases}
          P\ \ \ \ &\text{if}\ x \notin \Sigma, P \vdash \sigma\ \texttt{un}\\
          \emptyset\ \ \ &otherwise
        \end{cases}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{flalign*}
        \texttt{GenI}(\Gamma, P &=> \tau)  = \forall (ftv(S P, \tau)).S P => \tau \nonumber\\
        \text{where}\ &S\ \text{improves}\ \texttt{ftv}(P) \backslash \texttt{ftv}(\Gamma, \tau)\ \text{in}\ P
      \end{flalign*}
    \end{minipage}
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \mathcal{C}(\Psi, \Sigma)  = \bigcup_{x \in \texttt{dom}(\Sigma)} \Psi(x)
      \end{flalign*}
    \end{minipage}
  \end{framed}
  \caption{Auxiliary definitions}
  \label{fig:aux-defs}
\end{figure}

% \begin{figure}[h]
%   \begin{framed}
%     \begin{minipage}{1\linewidth}
%       \begin{flalign*}
%         \M(S, X;\Gamma \vdash C\ x) &= (P_M \cup \{P_i\}), Q, \Sigma_M \cup \{\Sigma_i\} \nonumber\\
%         \text{where}\ C &= \forall \vec{t_1}. (\forall \vec{t_2}. \exists \vec{t_3}. Q => v') \sepimp v \nonumber\\
%         P_M, R_M, \Sigma_M &= \M(S, X;\Gamma \vdash M:u_1 \oplus u_2 \oplus \cdots \oplus u_n) \nonumber \\
%         P_1, R_1, \Sigma_1 &= \M(R_M, X;\Gamma \vdash p_1:u_1 \vdash N_1: v) \nonumber \\
%         P_i, R_i, \Sigma_i &= \M(R_{i-1}, X;\Gamma \vdash p_i:u_i \vdash N_i: v) \nonumber \\
%         \Sigma' &= \bigcup_{i,j \leq n} (\Sigma_i \cap \Sigma_{j}) \nonumber\\
%         Q &= \text{Un}(\Gamma|_{\Sigma'}) \cup \{\text{Weaken}(p_i, u_i, \Sigma_i)\}
%       \end{flalign*}
%     \end{minipage}
%   \end{framed}
%   \caption{Type Inference Algorithm $\mathcal{M}$ (continued)}
%   \label{fig:algorithm-m-cont}
% \end{figure}

% Here is how the naive recursive algorithm works

% For Lambda
% \begin{enumerate}
% \item Get the bound variable
% \item Assign a new type for bound variable
% \item assign a new type variable for the body
% \item Evaluate type of the body and assign it to the body type variable
% \item return the type as (type of var) -> (type of body)
% \end{enumerate}

% Body can be made up of another lambda. In this case the same 5 steps will be triggered
% or it is an application of 2 or more variables
% In case of application 2 new type variable:
% \begin{enumerate}
% \item introduce type variables for left expression and right expression
%   left expression a type $A \rightarrow B$ right expression gets the type $A$
% \item recursively type check both of them
% \item return the type of the complete application as $B$ if the type checking in previous step is successfully
% \end{enumerate}


% In \qub{} there are 2 kinds of lambdas:
% \begin{enumerate}
% \item Sharing Lambda $\lambda^{\alpha}$
% \item Separating Lambda $\lambda^{*}$
% \end{enumerate}
% This helps us specify if the 2 variables are separated or have sharing
% of resources between them.
% The church encoding of a sharing pair will be represented as\\
% $shPair = \lambda^{*} x \rightarrow \lambda^{\alpha} y \rightarrow \lambda^{*} sh \rightarrow sh\ x\ y$\\
% This means that x and y may share resources
% A separating pair is represented as\\
% $sePair = \lambda^{*} x \rightarrow \lambda^{*}y \rightarrow \lambda^{*}se \rightarrow se\ x\ y$\\
% This means that x and y do not share resources.
% % By default we may assume that resources are always separating unless explicitly specified
% % that they are sharing.

\section{Implementing Algorithm $\M$}
The typing environment in standard Milner-Damas algorithm
is a pair of identifier and its type.
We need to modify the typing environment so that it describes sharing.
% There can be many different ways of doing it.
In the current implementation we have
extended the typing environment to hold 2 more entities along with the
type of the identifier, a list of list of identifiers --- that describes the sharing of variables,
a scope tag---that identifies if the variable is global in the complete module or local to the definition.
Global variables can be used anywhere in the file or other code file if it is imported
All function names will be defaulted to global scope.
Local variables can be used only after they have been bound in the typing environment.
The new typing environment can be realized as:
\begin{minted}{haskell}
  type Env = Map Id (Type, [[Id]], Scope)
\end{minted}

% % how is the list of list of ids help in identifying sharing

% % how do you define a closure

% % What do you mean by having a break in the closure

% % The used field in the type-checker state

% \section{Modification to Typechecking Algorithm}

% To incorporate the sharing, we have to modify the typechecking algorithm.
% The main reason to do that is to avoid adding $Un$ predicates to
% shared variables that are not used. Take an example of $fst$ function
% that returns the first argument of a shared pair
% \begin{verbatim}
% fst = \x -> \&y -> x
% \end{verbatim}
% In this case y should not be assigned an $Un$ predicate because
% it is shared with x and x is indeed used.

% The type checking algorithm has to be tweaked so that we keep track
% of what all variables are shared and which ones are separate.

% When we encounter an Alpha Lambda
% \begin{enumerate}
% \item Get the bound variable
% \item Assign a new type for bound variable
% \item Assign a new type variable for the body
% \item add the variable in a sharing context
% \item Evaluate type of the body and assign it to the body type variable
% \item return the type as (type of var) -> (type of body)
% \end{enumerate}


% % The main problem is that we do not know when a sharing variable should be kept in scope
% % or removed. In some cases we may need to keep it around for introducing the (>:=) predicates
% % Some cases are 2 types:
% % 1) The variable is used
% % 2) The variable is not used

% The type checking calls occur from left to right recursively.
% While going down the recursion we keep on adding variables to the environment
% We stop recursing at application. where we compute whether we have complete sharing to assign ShFun or SeFun.

% While folding out of of the recursion we do 2 things:
% 1) keep track of the used variables (including implicitly used variables due to sharing)
% 2) generate new goals
% a) depending on whether the the introduced variable was used
% or its sharing member was used. Assign Un predicates and weaken if it is not used at all
% b) introduce lesser-restricted predicates
% 3) Generate other new assumptions

% We cannot determine when to get rid of the complete bunch.
% \begin{verbatim}
% \z -> \*x -> \&y -> y
% \end{verbatim}
% hence, when we are folding out of the final recursive but 1 call ie. for Lambda bound variable x

% \section{Sharing}
% What do we exactly mean by sharing?
% There are 2 interpretations of sharing that i can think of
% 1) We have a resource $\mathcal{R}$, and 2 pointers $\alpha$, $\beta$. we say $alpha$, $\beta$ share if both of them point to the same resource $\mathcal{R}$
% $\mathcal{R}$ is never exposed to the user space and can be manipulated only by using $\alpha$, $\beta$.
% 2) We have resource

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku"
%%% End:
