\chapter{\qub{} Extention and Datatypes}\label{chp:datatypes}

In this chapter we discuss how \qub{} can be extended to have a kind system which makes
the type language powerful enough to accept user defined datatypes\cref{sec:kind-system}. We also discuss
how we can encode sums and multiplicative and additive products in \cref{sec:pairs-types}.


\section{Kind System}\label{sec:kind-system}
In the original system, there is no concept of type constructors, it would be tedious to add in
new types into the system as we would have to introduce new syntax and associated typing rules for
each of the new syntax. The kind system alleviates this tedious process by adding in the language
of type constructors. This idea was introduced by Barendregt \citeyearpar{barendregt_1991} and
is desribed in detail by Jones \citeyearpar{jones_system_1993}. We will follow Jones' approach
to add the language of type constructors and kinds in our system. The modified type system is shown in \cref{fig:qub-kind-extension}. All types have kind $\star$ and the
kind of the type constructors depends on its arity. The language of type constructors is extendible
by using a specialized syntax on surface level. In Haskell, this is done by using \mintinline{Haskell}{class} keywork.
and then declaring datatypes as instances of the defined class.

\begin{figure}[h]
  \begin{framed}
    \begin{flalign*}
      \text{Type Variables}\ \ t, u, \upsilon         &\in \text{Type Variables}  \\
      \text{Kinds}\ \ \               \kappa          &::= \kappa \mid \kappa' \rightarrow \kappa\\
      \text{Types}\ \ \             \tau^{\kappa}      &::= t^\kappa \mid T^{\kappa} \mid \tau^{\kappa' \rightarrow \kappa}\tau^{\kappa'}\\
      \text{Type Constructors}\ \ \   T^{\kappa}       &\in \mathcal{T}^{\kappa}\ 
                         \text{where}\ \{\overset{!}{\sepimp}, \sepimp, \xrightarrow{!}, \rightarrow \} \subseteq \mathcal{T}^{\star \rightarrow \star \rightarrow \star}\\
      \text{Predicates}\ \ \          \pi             &::= \texttt{Un}\ \tau \mid \texttt{SeFun}\ \tau \mid \texttt{ShFun}\ \tau \mid \tau \geq \tau' \\
      \text{Qualified Types}\ \ \     \rho            &::= \tau \mid \pi => \rho \\
      \text{Type schemes}\ \ \        \sigma          &::= \rho \mid \forall t. \sigma
    \end{flalign*}
  \end{framed}
  \caption{Types \qub{}}
  \label{fig:qub-kind-extension}
\end{figure}

Addition of a kind system changes the treatement to the type inference algorithm in some detail.
All types and type constructors have to be annotated with their kind. $T^\kappa$ denotes type constructors
and $\tau^{\kappa' \rightarrow \kappa}\tau^{\kappa'}$ denotes application of types.
The type constructor application rule that computes kinds is given in \cref{fig:constructor-application} where
$\tau$ is of kind $\kappa' \rightarrow \kappa$ and $\tau'$ is of kind $\kappa'$. The application
of both the constructors would result in a kind $\kappa$. 
$\sepimp$, $\overset{!}{\sepimp}$, $\rightarrow$ and $\overset{!}{\rightarrow}$
are now treated as type constructors with an arity of two and would have a kind $\star \rightarrow \star \rightarrow \star$ while
type like Int and Float will have a kind $\star$.

\begin{figure}
  \begin{framed}
    \begin{prooftree}
      \AxiomC{$\tau :: \kappa' \rightarrow \kappa$}
      \AxiomC{$\tau' :: \kappa'$}
      \BinaryInfC{$\tau \tau' :: \kappa$}
    \end{prooftree}
  \end{framed}
  \caption{Constructor Application Rule}
  \label{fig:constructor-application}
\end{figure}

The unification of types is now done via a modified version of Robinson's algorithm \citeyearpar{robinson_machine-oriented_1965}
is used in order to deduce the most general unifier for type constructors.
Formally we define $S$ to be the {\it most general unifier} for type constructors $T$ and $T'$ if:
\begin{enumerate}
  \item $S$ is a unifier for $T$ and $T'$.
  \item For every unifier $S'$ of $T$ and $T'$ we can write $T'$ in a form of
    $R S$ where $R$ some kind preserving substitution.
\end{enumerate}
We write $T \overset{S}{\sim}_{\kappa} T'$ for assertion that $S$ is the unifier
of the constructor types $T, T' \in T^{\kappa}$. The rules in \cref{fig:unify-types}
describe the unification algorithm for type constructors. [KVar] and [KVar'] contain
and additional constraint of the type variable $t$ to not be free in the type constructor's $T$
type variables to ensure the unification does not lead to infinite types. The [KApply] rule
states that type constructors of the form $T T'$ can be unified with $H H'$ only if $T$ and $H$
can be unified which asserts that they have to have the same kind $\kappa' \rightarrow \kappa$.

\begin{figure}[h]
  \begin{framed}
    \begin{minipage}[l]{0.5\linewidth}
      \begin{flalign*}
        t \overset{id}{\sim}_{\kappa} t \tag{[ID-KVar]}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}[r]{0.5\linewidth}
      \begin{flalign*}
        T \overset{id}{\sim}_{\kappa} T \tag{[ID-KConst]}
      \end{flalign*}
    \end{minipage}

    \begin{minipage}[l]{0.5\linewidth}
      \begin{flalign*}
        t \overset{[C/t]}{\sim}_{\kappa} T, t \notin \texttt{fvs}(T) \tag{[KVar]}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}[r]{0.5\linewidth}
      \begin{flalign*}
        T \overset{[C/t]}{\sim}_{\kappa} t, t \notin \texttt{fvs}(T) \tag{[KVar']}
      \end{flalign*}
    \end{minipage}

    \begin{minipage}[c]{1.0\linewidth}
      \begin{prooftree}
        \AxiomC{$T \overset{S}{\sim}_{\kappa'\rightarrow \kappa} T'$}
        \AxiomC{$S H \overset{S'}{\sim}_{\kappa'} S H'$}\RightLabel{([KApply])}
        \BinaryInfC{$T T' \overset{SS'}{\sim}_{\kappa} H H'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Kind Preserving Unification of Type Constructors}
  \label{fig:unify-types}
\end{figure}

\TODO{add more details of how this helps and proofs remain the same}

\section{Pairs and Sums in  \qub{}}\label{sec:pairs-types}
In this section we illustrate how the extented \qub{} can be used to introduce new types.
We introduce multiplicative pairs in \cref{subsec:mul-pairs} and additive pairs in \cref{subsec:mul-pairs}.
We then introduce the syntax and types for sum types in \cref{subsec:sums} and verify that they indeed work as expected.

\subsection{Multiplicative Pairs}\label{subsec:mul-pairs}

\subsection{Additive Pairs}\label{subsec:add-pairs}

\subsection{Sums Pairs}\label{subsec:sums}

Having two arrows indroduces two types of pairs. A sharing pair (\texttt{Pair$_{sh}$}) and a separating pair (\texttt{Pair$_{sep}$}) depending on
which arrow we use. The church encoding of both the pairs and their respective types are given in \ref{fig:bi-pairs-typing}.
Derivation proofs of both the pairs are given in \cref{sec:pairs}.
\begin{figure}
  \centering
  \begin{framed}
    \begin{flalign*}
      \text{Pair}_{sh} &: \tau \sepimp \tau' \rightarrow (\tau \sepimp \tau' \rightarrow \nu) \rightarrow \nu\\
      \text{Pair}_{sh} &= \lambda^{*} x. \lambda^{\alpha} by. \lambda^{\alpha} f. f x y\\
      \text{Pair}_{sep} &: \tau \sepimp \tau' \sepimp (\tau \sepimp \tau' \sepimp \nu) \sepimp \nu\\
      \text{Pair}_{sep} &= \lambda^{*} x. \lambda^{*} y. \lambda^{*} f. f x y
    \end{flalign*}
  \end{framed}
  \caption{Typing for Pairs in \textbf{\em BI}}
  \label{fig:bi-pairs-typing}
\end{figure}

We can now introduce 2 types in our type language $\otimes$ and $\with$
which represent separating pair and sharing pair respectively as shown in \cref{fig:pair-typing-rules}.
We also have a sum type whose rules are shown in \cref{fig:bi-sum-types}.
Proof derivation and definitions for sum type is given in \cref{sec:sums}.

\begin{figure}[h]
  \begin{framed}
    \begin{minipage}{1\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma  \vdash M : \tau$}
        \AxiomC{$P \mid \Delta \vdash N: \tau'$} \RightLabel{$[\with I]$}
        \BinaryInfC{$P \mid \Gamma \oplus \Delta \vdash \Pair{M;N} : \tau \with \tau'$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \tau \with \tau'$} \RightLabel{$[\with E_1]$}
        \UnaryInfC{$P \mid \Gamma \vdash \texttt{fst}_{sh}\ M: \tau$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \tau \with \tau'$} \RightLabel{$[\with E_2]$}
        \UnaryInfC{$P \mid \Gamma \vdash \texttt{snd}_{sh}\ M: \tau'$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{1\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma  \vdash M : \tau$}
        \AxiomC{$P \mid \Delta \vdash N: \tau'$} \RightLabel{$[\otimes I]$}
        \BinaryInfC{$P \mid \Gamma \circledast \Delta \vdash \Pair{M,N}: \tau \otimes \tau'$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \tau \otimes \tau'$} \RightLabel{$[\otimes E_1]$}
        \AxiomC{$P => \texttt{Un}\ \tau'$}
        \BinaryInfC{$P \mid \Gamma \vdash \texttt{fst}_{sep}\ M: \tau$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \tau \otimes \tau'$} \RightLabel{$[\otimes E_2]$}
        \AxiomC{$P => \texttt{Un}\ \tau$}
        \BinaryInfC{$P \mid \Gamma \vdash \texttt{snd}_{sep}\ M: \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Derivable Typing rules for Pair types}
  \label{fig:pair-typing-rules}
\end{figure}

\begin{figure}[h]
\begin{framed}
% sum type I_l
\begin{minipage}{0.5\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash M: \tau$}
    \UnaryInfC{$P \mid \Delta \vdash \texttt{inl}\ M: \tau \oplus \tau'$}
  \end{prooftree}
\end{minipage}
% sum type I_r
\begin{minipage}{0.5\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash M: \tau_2$}
    \UnaryInfC{$P \mid \Delta \vdash \texttt{inr}\ M: \tau \oplus \tau'$}
  \end{prooftree}
\end{minipage}
% sum type E
\begin{minipage}{1\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash M: \tau \oplus \tau'$}
    \AxiomC{$P \mid \Gamma \circledast x:\tau \vdash N :\nu$}
    \AxiomC{$P \mid \Gamma \circledast y:\tau' \vdash N':\nu$}\RightLabel{[$\oplus$E]}
    \TrinaryInfC{$P \mid \Gamma \vdash \Case{M}{\{\texttt{inl}\ x \mapsto N; \texttt{inr}\ y \mapsto N'\}} : v $}
  \end{prooftree}
\end{minipage}
\end{framed}
\caption{Derivable Typing Rules for Sum Type}
\label{fig:bi-sum-types}
\end{figure}


\begin{figure}[h]
  % sharing constructor
  \begin{framed}
    \TODO{How do we write about type constructors?}
\begin{minipage}{1\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash C: \tau_1 \sepimp \tau_2 \rightarrow \tau_3 \rightarrow \dots \rightarrow \tau_n \rightarrow T$}
    \AxiomC{$\Delta \equiv H(x_1 : \tau_1 ; x_2 : \tau_2 ; \ldots ; x_n:\tau_n)$}\RightLabel{$[\text{C-sh}]$}
    \BinaryInfC{$P \mid \Gamma; \Delta \vdash C \vec{x} : T $}
  \end{prooftree}
\end{minipage}
% Separating constructor
\begin{minipage}{1\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash C: \tau_1 \sepimp \tau_2 \sepimp \tau_3 \sepimp \dots \sepimp \tau_n \sepimp T$}
    \AxiomC{$\Delta \equiv H(x_1: \tau_1, x_2:\tau_2, \dots ,x_n:\tau_n)$}\RightLabel{$[\text{C-se}]$}
    \BinaryInfC{$P \mid \Gamma, \Delta \vdash C \vec{x} : T $}
  \end{prooftree}
\end{minipage}
\end{framed}
  \caption{User Defined Datatypes}
  \label{fig:ud-datatypes}
\end{figure}

The datatypes are user defined types:
There are 2 main kinds of non-recursive datatypes

1) data Choice a b = L a | R b

where the types a and b do not appear in both the constructors.
Choice here is a sum type a + b. How can we handle sum types in the current scenario?
1 way is to have a and b both not share resources. in this case we will have
a and b to be both un restricted.

a and b cannot direclty share resources. As the meaning of a sum type is that
either a or b can exist and not both. So we will always have separating arrow
for the sum types

Write the elemination rules for Either

for functions the closure has to be equal.

2) data Pair a b = P a b

The constructor uses both the resources a and b
Here we can have 2 subtypes:

a and b share resources or can be completely different.
We would want the programmer to specify whether the arguments are shared or separate.

For current purposes this syntactical specification is given via a modified syntax

data SeparatingPair a b = MkSeP a, b
data SharingPair a b = MkShP !! a b

We can of-course mix and match the sharing or separation.

data MixTuple a b c d e = MkMixTuple a,b;c,d

The question now that needs to be answered is how should the sharing be interpreted?
There are various options.

1. interpreted right to left. i.e. MkMixTuple (a, (b; (c,d)))
   so the b is shared with separating pair (c,d) and a is separate than b

2. interpreted left to right. i.e. MkMixTuple (((a, b);c),d)
   so the c is shared with separating pair (a,b) and d is separate from c

3. Sharing ; has precedence over separating , i.e. MkMixTuple a,(b;c),d

4. Separating , has lower precedence over ; i.e. MkMixTuple (a,b);(c,d)

This should be handled during the AST generating while parsing.
The type checking algorithm should be robust enough
to perform type checking either of these 4 types of sharing as they are
all perfectly valid scenarios.

Recursive datatypes have some kind of structural similarities within themselves

data Tree a = Leaf a | Node a (Tree a) (Tree a)

data Tree a b = Leaf b | Node a (Tree a b) (Tree a b)

Open questions:
How do we specify sharing of data between nodes?
eg. How can we say that all the leaves have shared data? and the data in nodes is sparating


What happens when lesser unrestrictedness with datatypes? Choice a b >:= f


\section{Examples}

\subsection{Pairs}

Our language has a notion of 2 kinds of pairs. The pairs representing resources that do not share
are denoted using separating pair $A \otimes B$. This means that when ever 



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku.tex"
%%% End:
