\chapter{\qub{} Datatypes}\label{chp:datatypes}

\section{Kind System}\label{sec:kind-system}
{\color{red}Type constructors, Class of type constructors, Unification of types and Type constructors?}
Our system supports introduction of new types via type constructors. We include a
richer kind system for this purpose. A modified version of Robinson's algorithm \citeyearpar{robinson_machine-oriented_1965}
is used in order to deduce the most general unifier for type constructors. Our treatment to type unification
is similar to Jones' \citeyearpar{jones_system_1993}.
Formally we define $S$ to be the {\it most general unifier} for type constructors $T$ and $T'$ if:
\begin{enumerate}
  \item $S$ is a unifier for $T$ and $T'$.
  \item For every unifier $S'$ of $T$ and $T'$ we can write $T'$ in a form of
    $R S$ where $R$ some kind preserving substitution.
\end{enumerate}
We write $T \overset{S}{\sim}_{\kappa} T'$ for assertion that $S$ is the unifier
of the constructor types $T, T' \in T^{\kappa}$. The rules in \cref{fig:unify-types}
describe the unification algorithm for type constructors. [Var] and [Var'] contain
and additional constraint of the type variable $t$ to not be free in the type constructor's $T$
type variables to ensure the unification does not lead to infinite types.

\begin{figure}[h]
  \begin{framed}
    \begin{minipage}[l]{0.5\linewidth}
      \begin{flalign*}
        t \overset{id}{\sim}_{\kappa} t \tag{[ID-Var]}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}[r]{0.5\linewidth}
      \begin{flalign*}
        \tau \overset{id}{\sim}_{\kappa} \tau \tag{[ID-Const]}
      \end{flalign*}
    \end{minipage}

    \begin{minipage}[l]{0.5\linewidth}
      \begin{flalign*}
        t \overset{[C/t]}{\sim}_{\kappa} C, t \notin \texttt{fvs}(C) \tag{[Var]}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}[r]{0.5\linewidth}
      \begin{flalign*}
        C \overset{[C/t]}{\sim}_{\kappa} t, t \notin \texttt{fvs}(C) \tag{[Var']}
      \end{flalign*}
    \end{minipage}

    \begin{minipage}[c]{1.0\linewidth}
      \begin{prooftree}
        \AxiomC{$C \overset{S}{\sim}_{\kappa'\rightarrow \kappa} D$}
        \AxiomC{$S C' \overset{S'}{\sim}_{\kappa'} S D'$}\RightLabel{[Apply]}
        \BinaryInfC{$CC' \overset{SS'}{\sim}_{\kappa} DD'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Kind Preserving Unification of Type Constructors}
  \label{fig:unify-types}
\end{figure}

Having two arrows indroduces two types of pairs. A sharing pair (\texttt{Pair$_{sh}$}) and a separating pair (\texttt{Pair$_{sep}$}) depending on
which arrow we use. The church encoding of both the pairs and their respective types are given in \ref{fig:bi-pairs-typing}.
Derivation proofs of both the pairs are given in \cref{sec:pairs}.
\begin{figure}
  \centering
  \begin{framed}
    \begin{flalign*}
      \text{Pair}_{sh} &: \tau \sepimp \tau' \rightarrow (\tau \sepimp \tau' \rightarrow \nu) \rightarrow \nu\\
      \text{Pair}_{sh} &= \lambda^{*} x. \lambda^{\alpha} by. \lambda^{\alpha} f. f x y\\
      \text{Pair}_{sep} &: \tau \sepimp \tau' \sepimp (\tau \sepimp \tau' \sepimp \nu) \sepimp \nu\\
      \text{Pair}_{sep} &= \lambda^{*} x. \lambda^{*} y. \lambda^{*} f. f x y
    \end{flalign*}
  \end{framed}
  \caption{Typing for Pairs in \textbf{\em BI}}
  \label{fig:bi-pairs-typing}
\end{figure}

We can now introduce 2 types in our type language $\otimes$ and $\with$
which represent separating pair and sharing pair respectively as shown in \cref{fig:pair-typing-rules}.
We also have a sum type whose rules are shown in \cref{fig:bi-sum-types}.
Proof derivation and definitions for sum type is given in \cref{sec:sums}.

\begin{figure}[h]
  \begin{framed}
    \begin{minipage}{1\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma  \vdash M : \tau$}
        \AxiomC{$P \mid \Delta \vdash N: \tau'$} \RightLabel{$[\with I]$}
        \BinaryInfC{$P \mid \Gamma \oplus \Delta \vdash \Pair{M;N} : \tau \with \tau'$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \tau \with \tau'$} \RightLabel{$[\with E_1]$}
        \UnaryInfC{$P \mid \Gamma \vdash \texttt{fst}_{sh}\ M: \tau$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \tau \with \tau'$} \RightLabel{$[\with E_2]$}
        \UnaryInfC{$P \mid \Gamma \vdash \texttt{snd}_{sh}\ M: \tau'$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{1\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma  \vdash M : \tau$}
        \AxiomC{$P \mid \Delta \vdash N: \tau'$} \RightLabel{$[\otimes I]$}
        \BinaryInfC{$P \mid \Gamma \circledast \Delta \vdash \Pair{M,N}: \tau \otimes \tau'$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \tau \otimes \tau'$} \RightLabel{$[\otimes E_1]$}
        \AxiomC{$P => \texttt{Un}\ \tau'$}
        \BinaryInfC{$P \mid \Gamma \vdash \texttt{fst}_{sep}\ M: \tau$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \tau \otimes \tau'$} \RightLabel{$[\otimes E_2]$}
        \AxiomC{$P => \texttt{Un}\ \tau$}
        \BinaryInfC{$P \mid \Gamma \vdash \texttt{snd}_{sep}\ M: \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Derivable Typing rules for Pair types}
  \label{fig:pair-typing-rules}
\end{figure}

\begin{figure}[h]
\begin{framed}
% sum type I_l
\begin{minipage}{0.5\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash M: \tau$}
    \UnaryInfC{$P \mid \Delta \vdash \texttt{inl}\ M: \tau \oplus \tau'$}
  \end{prooftree}
\end{minipage}
% sum type I_r
\begin{minipage}{0.5\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash M: \tau_2$}
    \UnaryInfC{$P \mid \Delta \vdash \texttt{inr}\ M: \tau \oplus \tau'$}
  \end{prooftree}
\end{minipage}
% sum type E
\begin{minipage}{1\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash M: \tau \oplus \tau'$}
    \AxiomC{$P \mid \Gamma \circledast x:\tau \vdash N :\nu$}
    \AxiomC{$P \mid \Gamma \circledast y:\tau' \vdash N':\nu$}\RightLabel{[$\oplus$E]}
    \TrinaryInfC{$P \mid \Gamma \vdash \Case{M}{\{\texttt{inl}\ x \mapsto N; \texttt{inr}\ y \mapsto N'\}} : v $}
  \end{prooftree}
\end{minipage}
\end{framed}
\caption{Derivable Typing Rules for Sum Type}
\label{fig:bi-sum-types}
\end{figure}


\begin{figure}[h]
  % sharing constructor
  \begin{framed}
    \TODO{How do we write about type constructors?}
\begin{minipage}{1\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash C: \tau_1 \sepimp \tau_2 \rightarrow \tau_3 \rightarrow \dots \rightarrow \tau_n \rightarrow T$}
    \AxiomC{$\Delta \equiv H(x_1 : \tau_1 ; x_2 : \tau_2 ; \ldots ; x_n:\tau_n)$}\RightLabel{$[\text{C-sh}]$}
    \BinaryInfC{$P \mid \Gamma; \Delta \vdash C \vec{x} : T $}
  \end{prooftree}
\end{minipage}
% Separating constructor
\begin{minipage}{1\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash C: \tau_1 \sepimp \tau_2 \sepimp \tau_3 \sepimp \dots \sepimp \tau_n \sepimp T$}
    \AxiomC{$\Delta \equiv H(x_1: \tau_1, x_2:\tau_2, \dots ,x_n:\tau_n)$}\RightLabel{$[\text{C-se}]$}
    \BinaryInfC{$P \mid \Gamma, \Delta \vdash C \vec{x} : T $}
  \end{prooftree}
\end{minipage}
\end{framed}
  \caption{User Defined Datatypes}
  \label{fig:ud-datatypes}
\end{figure}

The datatypes are user defined types:
There are 2 main kinds of non-recursive datatypes

1) data Choice a b = L a | R b

where the types a and b do not appear in both the constructors.
Choice here is a sum type a + b. How can we handle sum types in the current scenario?
1 way is to have a and b both not share resources. in this case we will have
a and b to be both un restricted.

a and b cannot direclty share resources. As the meaning of a sum type is that
either a or b can exist and not both. So we will always have separating arrow
for the sum types

Write the elemination rules for Either

for functions the closure has to be equal.

2) data Pair a b = P a b

The constructor uses both the resources a and b
Here we can have 2 subtypes:

a and b share resources or can be completely different.
We would want the programmer to specify whether the arguments are shared or separate.

For current purposes this syntactical specification is given via a modified syntax

data SeparatingPair a b = MkSeP a, b
data SharingPair a b = MkShP !! a b

We can of-course mix and match the sharing or separation.

data MixTuple a b c d e = MkMixTuple a,b;c,d

The question now that needs to be answered is how should the sharing be interpreted?
There are various options.

1. interpreted right to left. i.e. MkMixTuple (a, (b; (c,d)))
   so the b is shared with separating pair (c,d) and a is separate than b

2. interpreted left to right. i.e. MkMixTuple (((a, b);c),d)
   so the c is shared with separating pair (a,b) and d is separate from c

3. Sharing ; has precedence over separating , i.e. MkMixTuple a,(b;c),d

4. Separating , has lower precedence over ; i.e. MkMixTuple (a,b);(c,d)

This should be handled during the AST generating while parsing.
The type checking algorithm should be robust enough
to perform type checking either of these 4 types of sharing as they are
all perfectly valid scenarios.

Recursive datatypes have some kind of structural similarities within themselves

data Tree a = Leaf a | Node a (Tree a) (Tree a)

data Tree a b = Leaf b | Node a (Tree a b) (Tree a b)

Open questions:
How do we specify sharing of data between nodes?
eg. How can we say that all the leaves have shared data? and the data in nodes is sparating


What happens when lesser unrestrictedness with datatypes? Choice a b >:= f


\section{Examples}

\subsection{Pairs}

Our language has a notion of 2 kinds of pairs. The pairs representing resources that do not share
are denoted using separating pair $A \otimes B$. This means that when ever 



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku.tex"
%%% End:
