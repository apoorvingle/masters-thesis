\chapter{Language Syntax and Types}
In the following chapter we give the formal description of the language syntax and types. We explain what
it means for a judgement to exist as binary trees and then how we approximate the tree judgement
to a multiset inorder to simplify our type assignment algorithm.

\begin{figure}[h]
  \begin{framed}
    \begin{flalign*}
      \text{Type Variables}\ \ \      t, u, v         &\in \text{TVar}  \nonumber\\
      \text{Kinds}\ \ \               \kappa          &::= \star \mid \kappa \rightarrow \kappa \nonumber\\
      \text{Type constructors}\ \ \   T^{\kappa}       &::= \mathcal{T}^{\kappa}\ \text{where}
                                                      \{\overset{!}{\sepimp}, \sepimp, \xrightarrow{!}, \rightarrow \} \subseteq \mathcal{T}^{* \rightarrow * \rightarrow *}\nonumber\\
      \text{Types}\ \ \               \tau^{\kappa}    &::= t \mid T^{\kappa} \mid \tau^{\kappa' \rightarrow \kappa} \tau^{\kappa'}\nonumber\\
      \text{Predicates}\ \ \          \pi             &::= \texttt{Un}\ \tau \mid \texttt{SeFun}\ \tau \mid \texttt{ShFun}\ \tau \mid \tau \leq \tau' \nonumber\\
      \text{Qualified Types}\ \ \     \rho            &::= \tau^{*} \mid \pi => \rho \nonumber\\
      \text{Type schemes}\ \ \        \sigma          &::= \rho \mid \forall t. \sigma \nonumber
    \end{flalign*}
  \end{framed}
  \caption{Types and Kinds in \qub{}}
  \label{fig:qub-types}
\end{figure}
% Describe types
The type language consists of type variables and two kinds of binary type constructors the
sharing arrow ($\rightarrow$) and the separating arrow ($\sepimp$). The sharing arrow
would mean that the function shares resources with its argument and the separating
arrow would mean that the function does not share resources with its arguments.
We would write both the arrows in an infix notation. The kind system is simple where we use
$\star$ to denote all the types. We use $\tau$, $v$ and $\phi$ to denote types of any kind.
We also include additive and multiplicative sums or product types in our core language. The
definitions of all the four type constructors is described in \cref{sec:pairs} and \cref{sec:sums}.
The system is powerful enough to let programmers define their own types using the type constructors.
% We support user defined data types following
% Jones' [\cite{jones_system_1993}] by adding kind support to our language.

% Describe Predicates
The predicate system enhances the expressibility of the type system. Following the same route taken
by Quill \citep{morris_best_2016} we use the predicate \texttt{Un} $\tau$ to denote
that the type $\tau$ is unrestricted. We write \texttt{ShFun} $\tau$ to describe that type $\tau$ may share resources with its
argument types and \texttt{SeFun} $\tau$ to describe that $\tau$ is
does not share any resources from its argument types. The function types can also be of the unrestricted type.
Thus if a type $\tau$ is unrestricted i.e. it qualifies with predicate \texttt{Un} and it is also one of the function types
i.e. \texttt{SeFun} or \texttt{ShFun}, we write them as $\overset{!}{\sepimp}$ and $\xrightarrow{!}$ respectively.
This can be considered as an improving substitution following Jones notion of improvement of qualified types \citep{jones_simplifying_1995}.
We also define an ordering on types by using the predicate $\geq$. The predicate $\tau \geq \tau'$ holds if the type $\tau'$
is less restricting than $\tau$. The predicate entailment relations $P => Q$ are given in \cref{fig:entailment-rules}.
\TODO{Explain what does it mean for a type to be less that other type}
\begin{figure}[h]
  \begin{framed}
    \begin{minipage}{0.20\linewidth}
      \begin{prooftree}
        \AxiomC{$\pi \in P$}
        \UnaryInfC{$P => \pi$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.20\linewidth}
      \begin{prooftree}
        \AxiomC{$\bigwedge_{\pi \in Q} P => \pi$}
        \UnaryInfC{$P => Q$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.20\linewidth}
      \begin{prooftree}
        \AxiomC{}
        \UnaryInfC{$P => \Un{(\tau \sepimp \tau')}$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.20\linewidth}
      \begin{prooftree}
        \AxiomC{}
        \UnaryInfC{$P => \Un{(\tau \rightarrow \tau')}$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.20\linewidth}
      \begin{prooftree}
        \AxiomC{$\tau = \sepimp \vee \tau = \overset{!}{\sepimp}$}
        \UnaryInfC{$P => \SeFun{\tau}$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.20\linewidth}
      \begin{prooftree}
        \AxiomC{$\tau = \rightarrow \vee \tau = \overset{!}{\rightarrow}$}
        \UnaryInfC{$P => \ShFun{\tau}$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.20\linewidth}
      \begin{prooftree}
        \AxiomC{$P => \Un{\tau}$}
        \UnaryInfC{$P => \tau \geq (v \overset{!}{\sepimp} v')$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.20\linewidth}
      \begin{prooftree}
        \AxiomC{$P => \Un{\tau}$}
        \UnaryInfC{$P => \tau \geq (v \overset{!}{\rightarrow} v')$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$$}
        \UnaryInfC{$P => \tau \geq (v \sepimp v')$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$$}
        \UnaryInfC{$P => \tau \geq (v \rightarrow v')$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P => \tau \geq \phi t$}
        \AxiomC{$t\ \text{fresh}$}
        \BinaryInfC{$P => \tau \geq \phi$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P => \tau t \geq \phi$}
        \AxiomC{$t\ \text{fresh}$}
        \BinaryInfC{$P => \tau \geq \phi$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
  \caption{Entailment Rules}
  \label{fig:entailment-rules}
\end{figure}


\begin{figure}[h]
  \begin{framed}
    \begin{flalign*}
      \text{Environments}\ \ \      \Gamma,\Delta     &::= \epsilon \mid x^{\bar{y}}:\sigma \mid \Gamma, \Delta \mid \Gamma; \Delta \nonumber\\
      \text{Environment Context}\ \ \ \mathcal{H}     &::= \epsilon \mid \mathcal{H} \varoplus \Gamma \mid \mathcal{H} \circledast \Gamma \nonumber\\
  \end{flalign*}
\end{framed}
  \caption{Typing Context}
  \label{fig:typing-context}
\end{figure}
% Describe Typing judgments
In normal type systems, the contexts are represented as sets or lists. In \BI\ they are represented as binary trees.
The leaf nodes contain the pair of term and its associated type. Internal nodes of the context tree are
connectives which can either be a semicolon ($;$) or a comma ($,$).
If a bunch $\Delta$ is a subtree of $\Gamma$, then we denote a subtree relation by $\Gamma(\Delta)$.
Two context are equivalent ($\Gamma \equiv \Delta$)if they can be transformed into one another by renaming the identifiers.
The bunches have a restriction that no identifier appears more than once. We restrict certain structural rules on the context
depending on the connectives being used. If contexts are combined using a comma ($,$), contraction and weakening is not admissible,
but if the contexts are combined using a semicolon ($;$) then it can undergo contraction and weakening. Exchange rule is admissible
in both the connectives. This distinction enables us to have a special treatment for resources in our language.
By associating a resource with a comma constructor, our type system will not disposed it off by using the contraction rule.
While, non-resourceful objects (or normal propositions) can be combined using the semi-colon constructor.
An example bunch is shown in \cref{fig:bunches-bi}. a and b have a shared context while c is separate from the bunch a and b.
If $\Gamma$ represents the complete bunch of \cref{fig:bunches-bi}, $\Delta \equiv (a:A; b:B)$ and $\Delta' \equiv (c:C)$
then $\Gamma \equiv \Delta,\Delta'$ and $\Gamma(\Delta)$.

\begin{figure}[h]
  \centering
  \tikzset{every tree node/.style={minimum width=2em},
         blank/.style={draw=none},
         edge from parent/.style=
         {draw,edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
         level distance=1.5cm}
\begin{tikzpicture}
\Tree
[.,
    [.;
        [.a:A ]
        [.b:B ]
    ]
    [.c:C ]
    ]
\end{tikzpicture}
\caption{Bunches in \textbf{\em BI}}
\label{fig:bunches-bi}
\end{figure}

We try to emulate the behaviour of bunches using multisets and denote multiset union using $\Gamma \sqcup \Gamma'$.
The type assignment will be a collection of variables with an added annotation of sharing. If a resource $x$ is in
sharing with one or many resources $\bar{y}$ we would represent it as $x^{\bar{y}}:\tau$.
Further $\Gamma, x^{\bar{y}}:\tau$ would mean $\Gamma \sqcup \{x^{\bar{y}}:\tau\}$. We define a few auxilary functions on the
type assigments. Vars($\Gamma$) is the set of all the term variables in $\Gamma$. Shared($\Gamma$) computes
the set of all the term variables that are in sharing with each other. Used($\Gamma$) computes the
union of all the term variables in the type assignment and the term variables shared by each of those.
We define two partial operators on type assigments as shown in \cref{fig:context-operation}.
Two type assigments are said to be in disjoint union ($\circledast$) if they have no common used term.
If the type assignments have an exact overlapping of terms being used, it is said to be in a sharing union ($\varoplus$).

\begin{figure}[h]
  \begin{framed}
    \noindent
    \begin{flalign*}
      \text{Vars}(\Gamma, x^{\bar{y}}) &= \text{Vars}(\Gamma) \cup \{ x \}\\
      \text{Shared}(\Gamma, x^{\bar{y}}) &= \text{Shared}(\Gamma) \cup \{ \bar{y} \}\\
      \text{Used}(\Gamma) &= \text{Vars}(\Gamma) \cup \text{Shared}(\Gamma)\\
      (\Gamma, x^{\bar{y}})^{[a \mapsto \bar{b}]} &= \begin{cases}
        x \notin \bar{y}\ \ \ \ (\Gamma^{[a \mapsto \bar{b}]}, x^{\bar{y}}:\tau)\\
        x \in \bar{y}\ \ \ \  (\Gamma^{[a \mapsto \bar{b}]}, x^{(\bar{y}\backslash a)\cup\bar{b}}:\tau)
      \end{cases}\\
      \Gamma^{[\bar{a} \mapsto \bar{b}]} &= (\dots((\Gamma^{[a_1 \mapsto \bar{b}]})^{[a_2 \mapsto \bar{b}]})^{\dots})^{[a_2 \mapsto \bar{b}]}
    \end{flalign*}
  \end{framed}
  \caption{Auxilary Functions on Multisets}
  \label{fig:multiset-aux-function}
\end{figure}
\begin{figure}[h]
  \begin{framed}
    \begin{flalign*}
      \Gamma \circledast \Gamma' &= \Gamma \sqcup \Gamma' => \text{if}\ \text{Vars}(\Gamma) \# \text{Used}(\Gamma')\ \text{and}\ \text{Vars}(\Gamma')\# \text{Used}(\Gamma) \\
      \Gamma \varoplus \Gamma'   &= \Gamma \sqcup \Gamma' => \text{if}\ \text{Used}(\Gamma) \equiv \text{Used}(\Gamma')
    \end{flalign*}
  \end{framed}
  \caption{Context Operations}
  \label{fig:context-operation}
\end{figure}


\begin{figure}[h]
  \begin{framed}
    \begin{flalign*}
      \text{Term Variables}\ \ \  x, y, z  &\in \text{Var} \nonumber\\
      % \text{Patterns}\ \ \        p        &::= x \mid C \vec{x}\nonumber\\
      \text{Expressions}\ \ \     M, N     &::= x \mid \lambda^{*}x. M \mid \lambda^{\alpha}x. M \mid M N\nonumber\\
      &\mid \Case{M}{\{\texttt{inl}\ x \mapsto N ; \texttt{inr}\ y \mapsto N'\}}\mid \texttt{inl}\ x \mid \texttt{inr}\ y \nonumber\\
      &\mid \Let{x}{M}{N} \mid \Pair{M,N} \mid \Pair{M;N}
    \end{flalign*}
  \end{framed}
  \caption{Language Syntax}
  \label{fig:quill-terms}
\end{figure}
% Describe the language here

% Describe terms and patterns
Our term language is similar to that of simply typed lambda calculus involving variables and application
but we have 2 different kind of lambdas. The alpha lambda ($\lambda^{\alpha} x. M$) denotes sharing
of the argument term with the expression $M$ and the separating lambda term ($\lambda^{*} x. M$) that implies
the argument term has a separating context with the expression $M$. We also have polymorphic $\texttt{let}$
expressions to be able to define expressions with a limited scope. The type constructors \texttt{inl} and \texttt{inr} build
a sum type while \texttt{case} expression match on the sum type to specify what should be done in for the two ways
in which the sum type was created.

% The type constructors are added in order to allow programmers to define their own data types. They can be used to define sum and product types.
% \texttt{case} expression can be used to pattern match on the expression to express it in terms
% of individual sum types. Patterns are either term variables or constructor terms.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku.tex"
%%% End:
 