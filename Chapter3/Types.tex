\section{Type Extensions}

We add 2 new type classes to our language
\begin{itemize}
\item Unrestricted values will have a type Un
  that represents the fact that the resource can be
  duplicated/discarded or they cannot.
  This expressivity helps us understand how the functions
  use the resources. If the function uses a file handle as a resource
  in a restricted fashion. It would not call duplicate or drop on it.
  Its return value would contain the reference to the resource
  On the other hand if the file handle is being opened or closed
  by a function, it will have to be in an unrestricted fashion.
\item All the functions are of class $->$ can potentially have any of the 4 choices
  \begin{lstlisting}
                  ShFun SeFun

    Un            $\overset{!}{\rightarrow}$    $\overset{!}{\sepimp}$

   Substructural   $\rightarrow$     $\sepimp$
  \end{lstlisting}

  $\rightarrow$ implies that the function application is of the sharing type.
  i.e. the resources used in the function have a may have a sharing closure.
  represented as $-\&>$

  $\sepimp$ implies that the function applciation is of a separating type.
  the function may not share resources with its arguments

  $\overset{!}{\rightarrow}$ implies that the function itself can be discarded
  or used multiple number of times. i.e. its closure
  can be duplicated or discarded. And the function shares resources with the arguments

  $\overset{!}{\sepimp}$ implies that the function itself can be discarded.
  This is useful in case of higher order functions.

\begin{minted}{haskell}
instance Monad (-!*>) Maybe where
   return a = Just a
   (>>=) a f = case a of
                 Nothing -> Nothing
                 Just v  -> f v
\end{minted}

  In the first branch of case expression, f is never used and discarded. Hence
  the type of the function should be $-!*>$
  This may not always be the case. As with a non-empty list
  the operation f is performed atleast once.

\begin{minted}{haskell}
instance Monad (-!*>) NEList where
   return a   = Last a
   (>>=) m f  = case a of
                  Last a    -> f a
                  Cons a as -> concat (f a) (as >>= f)
\end{minted}

\end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
