\chapter{Language Core Syntax and Types}

\begin{figure}[h]
  \begin{framed}
    \begin{flalign*}
      \text{Type Variables}\ \ \      t, u, v         &\in \text{TVar}  \nonumber\\
      \text{Kinds}\ \ \               \kappa          &::= * \mid \kappa \rightarrow \kappa \nonumber\\
      \text{Type constructors}\ \ \   T^{\kappa}       &::= \mathcal{T}^{\kappa}\ \text{where}
                                                      \{ \overset{!}{\sepimp}, \sepimp, \xrightarrow{!}, \rightarrow \} \subset \mathcal{T}^{* \rightarrow * \rightarrow *}\nonumber\\
      \text{Types}\ \ \               \tau^{\kappa}    &::= t \mid T^{\kappa} \mid \tau^{\kappa' \rightarrow \kappa} \tau^{\kappa'}\nonumber\\
      \text{Predicates}\ \ \          \pi             &::= \texttt{Un}\ \tau \mid \texttt{SeFun}\ \tau \mid \texttt{ShFun}\ \tau \mid \tau \geq \tau' \nonumber\\
      \text{Qualified Types}\ \ \     \rho            &::= \tau^{*} \mid \pi \Rightarrow \rho \nonumber\\
      \text{Type schemes}\ \ \        \sigma          &::= \rho \mid \forall t. \sigma \nonumber\\
    \end{flalign*}
  \end{framed}
  \caption{Types in Language}
  \label{fig:quill-types}
\end{figure}

\begin{figure}[h]
  \begin{framed}
  \begin{flalign*}
    \text{Environments}\ \ \      \Gamma,\Delta     &::= \epsilon \mid x:\sigma \mid \Gamma, \Delta \mid \Gamma; \Delta \nonumber\\
    \text{Environment Context}\ \ \ H, H'           &::= \epsilon \mid H,H' \mid H;H' \mid \square \nonumber\\
  \end{flalign*}
\end{framed}
  \caption{Language Context}
  \label{fig:quill-context}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    \begin{flalign*}
      \text{Term Variables}\ \ \      x, y, z         &\in \text{Var} \nonumber\\
      \text{Expressions}\ \ \         M, N            &::= x \mid \lambda^{*}x. M \mid \lambda^{\alpha}x. M \mid M N\nonumber\\
                                                      &\mid \texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N
                                                      \mid \texttt{case}\ M\ \texttt{of}\ \{C_i\ x_{1i}\ x_{2i}\ \ldots\ x_{ji}\}_i\nonumber
    \end{flalign*}
  \end{framed}
  \caption{Language Syntax}
  \label{fig:quill-terms}
\end{figure}

% Describe the language here

% Describe types
We extend the type language described in \cite{morris_best_2016} by adding four new binary
type constructors $\sepimp$, $\overset{!}{\sepimp}$, $\rightarrow$ and $\xrightarrow{!}$
which we write in infix format instead of the two $\overset{\circ}{\rightarrow}$
and $\overset{\bullet}{\rightarrow}$ constructors which describe restricted and unrestricted
versions of function types. We would write $\sepimp$ when the function does not share any resources
with its arguments and $\rightarrow$ when the function may share resources
with its arguments. $\overset{!}{\sepimp}$ and $\xrightarrow{!}$
mean that they are unrestricted versions of $\sepimp$ and $\rightarrow$ respectively.
We use $\tau$, $\nu$ and $\phi$ to denote types of any kind. We support user defined datatypes following
Jone's FCP [\cite{jones_first-class_1997}]

% Describe Predicates
The \texttt{Un} $\tau$ denotes that the type $\tau$ is unrestricted. 
There are 2 new predicates instead of \texttt{Fun} $\tau$. We write \texttt{ShFun} $\tau$ to describe that
type $\tau$ may share resources with its argument types and \texttt{SeFun} $\tau$ to describe that $\tau$ is
does not share any resources from its arugmet types.
% Describe Typing judgements

% Describe terms

\section{Conventions and Notations}
$\Gamma_{x}$ is the typing environment excluding the type variable $x$. $TV(\Gamma)$ are the free
variables in the environment $\Gamma$. $\Gamma \cdot \Delta$ means that the contexts can either
be comma separated or semicolon separated i.e. $\Gamma, \Delta$ or $\Gamma;\Delta$. The contexts are
in bunches we denote a subtree of a bunch by $\mathcal{H}(\Delta)$ we mean $\Delta$ is a subtree of
$\mathcal{H}$. describe Contexts with holes

\section{Syntax Directed Typing Judgements}

\begin{figure}[h]
  \begin{framed}
    % var
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{} \RightLabel{[VAR]}
        \UnaryInfC{$P \mid x : \sigma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \sigma$}
        \AxiomC{$P' \mid \Gamma_{x} \cdot x: \sigma \vdash N: \tau$} \RightLabel{[LET]}
        \BinaryInfC{$P \cup P' \mid \Gamma \vdash \texttt{let}\ x\ \texttt{=}\ M\ \texttt{in}\ N: \tau$}
      \end{prooftree}
    \end{minipage}

    % CTR UN
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma(H', H') \vdash M : \sigma$}
        \AxiomC{$P'\vdash H' un$} \RightLabel{[C-un]}
        \BinaryInfC{$P \mid \Gamma(H') \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}
    % WKN UN
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma(\epsilon) \vdash M : \sigma$}
        \AxiomC{$P'\vdash H' un$} \RightLabel{[W-un]}
        \BinaryInfC{$P \mid \Gamma(H') \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}

    % CTR Sh
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma(H'; H') \vdash M : \sigma$} \RightLabel{[C-sh]}
        \UnaryInfC{$P \mid \Gamma(H') \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}
    % WKN Sh
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P  \mid \Gamma(H') \vdash M : \sigma$} \RightLabel{[W-sh]}
        \UnaryInfC{$P \mid \Gamma(H'; H'') \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}

    % => I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P, \pi \mid \Gamma \vdash M : \rho$} \RightLabel{$[\Rightarrow I]$}
        \UnaryInfC{$P \mid \Gamma \vdash M : \pi \Rightarrow \rho$}
      \end{prooftree}
    \end{minipage}
    % => E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \pi \Rightarrow \rho$}
        \AxiomC{$P \Rightarrow \pi$} \RightLabel{$[\Rightarrow E]$}
        \BinaryInfC{$P \mid \Gamma \vdash M: \rho$}
      \end{prooftree}
    \end{minipage}

    % forall I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \sigma$}
        \AxiomC{$t \notin TV(\Gamma) \cup TV(P)$}\RightLabel{$[\forall I]$}
        \BinaryInfC{$P \mid \Gamma \vdash M: \forall t. \sigma$}
      \end{prooftree}
    \end{minipage}
    % forall E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \forall t.\sigma$}\RightLabel{$[\forall E]$}
        \UnaryInfC{$P \mid \Gamma \vdash M: [\tau / t] \sigma $}
      \end{prooftree}
    \end{minipage}

    % -&> I
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma_{x};x: \tau \vdash M : \tau'$}
        \AxiomC{$P \Rightarrow \texttt{ShFun} \phi$}
        \AxiomC{$P \vdash \Gamma \geq \phi$} \RightLabel{$[\rightarrow I]$}
        \TrinaryInfC{$P \mid \Gamma \vdash \lambda^{\alpha}x. M : \phi \tau \tau'$}
      \end{prooftree}
    \end{minipage}
    % -&> E
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \phi \tau \tau'$}
        \AxiomC{$P \mid \Delta \vdash N : \tau'$}
        \AxiomC{$P \Rightarrow \texttt{ShFun} \phi$}
        \AxiomC{$P \vdash \Gamma \geq \phi$} \RightLabel{$[\sepimp E]$}
        \QuaternaryInfC{$P \mid \Gamma,\Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}

    % -*> I
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma_{x},x: \tau \vdash M : \tau'$}
        \AxiomC{$P \Rightarrow \texttt{SeFun} \phi$}
        \AxiomC{$ P \vdash \Gamma \geq \phi$} \RightLabel{$[\sepimp I]$}
        \TrinaryInfC{$P \mid \Gamma \vdash \lambda^{*}x. M : \phi \tau \tau'$}
      \end{prooftree}
    \end{minipage}
    % -*> E
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \phi \tau \tau'$}
        \AxiomC{$P \mid \Delta \vdash N : \tau$}
        \AxiomC{$P \Rightarrow \texttt{ShFun} \phi$}
        \AxiomC{$P \vdash \Gamma \geq \phi$} \RightLabel{$[\rightarrow E]$}
        \QuaternaryInfC{$P \mid \Gamma;\Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
    % user defined type constructor I
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \tau$}
        \AxiomC{$\{\vdash C_i:\bar{x}_i \rightsquigarrow H$}
        \AxiomC{$\Delta \cdot H \vdash M: v \}_i$}\RightLabel{$[K_i I]$}
        \TrinaryInfC{$P \mid \Gamma \cdot \Delta \vdash \texttt{case}\ M\ \texttt{of}\ \{C_i\ x_{1i}\ x_{2i} \ldots\ x_{ji} \rightarrow N_i\}_i : v $}
      \end{prooftree}
    \end{minipage}
    % user defined type constructor E
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \cdot \Delta \vdash \texttt{case}\ M\ \texttt{of}\ \{C_i\ x_{1i}\ x_{2i} \ldots\ x_{ji} \rightarrow N_i\}_i : v $}\RightLabel{$[K_i E]$}
        \UnaryInfC{$Elemenation TODO!$}
      \end{prooftree}
    \end{minipage}

    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P \Rightarrow \texttt{Un}\ \tau$}\RightLabel{[\texttt{Un}-$\tau$]}
        \UnaryInfC{$P \vdash \tau\ \texttt{un}$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P,\pi \vdash \rho\ \texttt{un}$}\RightLabel{[\texttt{Un}-$\rho$]}
        \UnaryInfC{$P \vdash \pi \Rightarrow \rho\ \texttt{un}$}
      \end{prooftree}
    \end{minipage}

    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P, \texttt{Un}\ t \vdash \sigma\ \texttt{Un}$}\RightLabel{[\texttt{Un}-$\sigma$]}
        \UnaryInfC{$P \vdash \forall t.\sigma\ \texttt{un}$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$\bigwedge_{x:\sigma \in H}P \vdash \rho\ \texttt{un}$}\RightLabel{[\texttt{Un}-$H$]}
        \UnaryInfC{$P \vdash H\ \texttt{un}$}
      \end{prooftree}
    \end{minipage}

    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P \Rightarrow \tau \geq \phi$}\RightLabel{[$\geq$-$\tau$]}
        \UnaryInfC{$P \vdash \tau \geq \phi$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P,\pi \vdash \rho \geq \phi$}\RightLabel{[$\geq$-$\rho$]}
        \UnaryInfC{$P \vdash (\pi \Rightarrow \rho) \geq \phi$}
      \end{prooftree}
    \end{minipage}

    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$P, \texttt{Un}\ t \vdash \sigma \geq \phi$}\RightLabel{[$\geq$-$\sigma$]}
        \UnaryInfC{$P \vdash (\forall t.\sigma) \geq \phi$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{prooftree}
        \AxiomC{$\bigwedge_{x:\sigma \in H}P \vdash \rho \geq \phi$}\RightLabel{[$\geq$-$H$]}
        \UnaryInfC{$P \vdash H \geq \phi$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
    \caption{Typing Rules}
    \label{fig:typing-rules}
\end{figure}

\begin{figure}[h]
  \begin{framed}
  \begin{minipage}{1\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H  \vdash M : \tau$}
      \AxiomC{$P \mid H' \vdash N: \tau'$} \RightLabel{$[\with I]$}
      \BinaryInfC{$P \mid H;H' \vdash (M;N): \tau \with \tau'$}
    \end{prooftree}
  \end{minipage}

  \begin{minipage}{.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H \vdash M: \tau \with \tau'$} \RightLabel{$[\with E_1]$}
      \UnaryInfC{$P \mid H \vdash \texttt{fst}\ M: \tau$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H \vdash M: \tau \with \tau'$} \RightLabel{$[\with E_2]$}
      \UnaryInfC{$P \mid H \vdash \texttt{snd}\ M: \tau'$}
    \end{prooftree}
  \end{minipage}

  \begin{minipage}{1\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H  \vdash M : \tau$}
      \AxiomC{$P \mid H' \vdash N: \tau'$} \RightLabel{$[\otimes I]$}
      \BinaryInfC{$P \mid H,H' \vdash (M,N): \tau \otimes \tau'$}
    \end{prooftree}
  \end{minipage}

  \begin{minipage}{.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H \vdash M: \tau \otimes \tau'$} \RightLabel{$[\otimes E_1]$}
      \AxiomC{$P => \texttt{Un}\ \texttt{snd}\ M$}
      \BinaryInfC{$P \mid H \vdash \texttt{fst}\ M: \tau$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H \vdash M: \tau \otimes \tau'$} \RightLabel{$[\otimes E_2]$}
      \AxiomC{$P => \texttt{Un}\ \texttt{fst}\ M$}
      \BinaryInfC{$P \mid H \vdash \texttt{snd}\ M: \tau'$}
    \end{prooftree}
  \end{minipage}
\end{framed}
  \caption{Derivable Typing rules}
  \label{fig:derivable-typing-rules}
\end{figure}


\begin{figure}[h]
  \begin{framed}
    \begin{minipage}[ht]{1\linewidth}
      \centering
      \fbox{
        $\mathcal{M}(S, X;\Gamma \vdash M : \tau) = P, S', \Sigma$
      }
    \end{minipage}
    \begin{minipage}{1\linewidth}
      
    \end{minipage}
  \end{framed}
  \caption{Type Inference Algorithm $\mathcal{M}$}
  \label{fig:algorithm-m}
\end{figure}


Here is how the naive recursive algorithm works

For Lambda
\begin{enumerate}
\item Get the bound variable
\item Assign a new type for bound variable
\item assign a new type variable for the body
\item Evaluate type of the body and assign it to the body type varialbe
\item return the type as (type of var) -> (type of body)
\end{enumerate}

Body can be made up of another lambda. In this case the same 5 steps will be triggered
or it is an application of 2 or more variables
In case of application 2 new type variable:
\begin{enumerate}
\item introduce type variables for left expression and right expression
    left expression a type $A \rightarrow B$ right expression gets the type $A$
\item recursively type check both of them
\item return the type of the complete application as $B$ if the type checking in previous step is successfull
\end{enumerate}


In Quill there are 2 kinds of lambdas:
\begin{enumerate}
\item Sharing Lambda $\lambda^{\alpha}$
\item Separating Lambda $\lambda^{*}$
\end{enumerate}
This helps us specify if the 2 variables are separated or have sharing
of resources between them.
The church encoding of a sharing pair will be represented as\\
$shPair = \lambda^{*} x \rightarrow \lambda^{\alpha} y \rightarrow \lambda^{*} sh \rightarrow sh\ x\ y$\\
This means that x and y may share resources
A sparating pair is represented as\\
$sePair = \lambda^{*} x \rightarrow \lambda^{*}y \rightarrow \lambda^{*}se \rightarrow se\ x\ y$\\
This means that x and y do not share resources.
%By default we may assume that resources are always separating unless explicitly specified
%that they are sharing.

\section{Typing environment}

The typing environment in standard Milner-Damas algorithm
is a pair of identifier and its type.
We need to modify the typing envrionment so that it describes sharing.
% There can be many different ways of doing it.
In the current implmenetation we have
extended the typing environment to hold 2 more entities along with the
type of the indentifier, a list of list of identifiers --- that describes the sharing of variables,
a scope tag---that identifies if the variable is global in the complete module or local to the definition.
Global variables can be used anywhere in the file or other code file if it is imported
All function names will be defaulted to global scope.
Local variables can be used only after they have been bound in the typing environment.
The new typing envionment can be realized as:
\begin{minted}{haskell}
  type Env = Map Id (Type, [[Id]], Scope)
\end{minted}

% how is the list of list of ids help in identifying sharing

% how do you define a closure

% What do you mean by having a break in the closure

% The used field in the typechecker state

\section{Modification to Typechecking Algorithm}

To incorporate the sharing, we have to modify the typechecking algorithm.
The main reason to do that is to avoid adding $Un$ predicates to
shared variables that are not used. Take an example of $fst$ function
that returns the first argument of a shared pair
\begin{verbatim}
fst = \x -> \&y -> x
\end{verbatim}
In this case y should not be assigend an $Un$ predicate because
it is shared with x and x is indeed used.

The type checking algorithm has to be tweeked so that we keep track
of what all variables are shared and which ones are separate.

When we encounter an Alpha Lambda
\begin{enumerate}
\item Get the bound variable
\item Assign a new type for bound variable
\item Assign a new type variable for the body
\item add the variable in a sharing context
\item Evaluate type of the body and assign it to the body type variable
\item return the type as (type of var) -> (type of body)
\end{enumerate}


% The main problem is that we do not know when a sharing variable should be kept in scope
% or removed. In some cases we may need to keep it around for introducing the (>:=) predicates
% Some cases are 2 types:
% 1) The variable is used
% 2) The variable is not used

The type checking calls occur from left to right recursively.
While going down the recursion we keep on adding variables to the envionment
We stop recursing at application. where we compute whether we have complete sharing to assign ShFun or SeFun.

While folding out of of the recursion we do 2 things:
1) keep track of the used variables (including implicitly used variables due to sharing)
2) generate new goals
   a) depending on whether the the introduced variable was used
      or its sharing member was used. Assign Un predicates and weaken if it is not used at all
   b) introduce lesser-restricted predicates
3) Generate other new assumptions

We cannot determine when to get rid of the complete bunch.
\begin{verbatim}
\z -> \*x -> \&y -> y
\end{verbatim}
hence, when we are folding out of the final recursive but 1 call ie. for Lambda bound variable x


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku.tex"
%%% End:
