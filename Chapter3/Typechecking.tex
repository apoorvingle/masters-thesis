\chapter{Language Core Syntax and Types}

\begin{figure}[h]
  \begin{framed}
    \begin{flalign*}
      \text{Type Variables}\ \ \      t, u, v         &\in \text{TVar}  \nonumber\\
      \text{Kinds}\ \ \               \kappa          &::= * \mid \kappa \rightarrow \kappa \nonumber\\
      \text{Type constructors}\ \ \   T^{\kappa}       &::= \mathcal{T}^{\kappa}\ \text{where}
                                                      \{\oplus, \overset{!}{\sepimp}, \sepimp, \xrightarrow{!}, \rightarrow \} \subseteq \mathcal{T}^{* \rightarrow * \rightarrow *}\nonumber\\
      \text{Types}\ \ \               \tau^{\kappa}    &::= t \mid T^{\kappa} \mid \tau^{\kappa' \rightarrow \kappa} \tau^{\kappa'}\nonumber\\
      \text{Predicates}\ \ \          \pi             &::= \texttt{Un}\ \tau \mid \texttt{SeFun}\ \tau \mid \texttt{ShFun}\ \tau \mid \tau \leq \tau' \nonumber\\
      \text{Qualified Types}\ \ \     \rho            &::= \tau^{*} \mid \pi => \rho \nonumber\\
      \text{Type schemes}\ \ \        \sigma          &::= \rho \mid \forall t. \sigma \nonumber
    \end{flalign*}
  \end{framed}
  \caption{Types in Language}
  \label{fig:quill-types}
\end{figure}
% Describe types
We extend the type language described in \cite{morris_best_2016} by adding four new binary
type constructors $\sepimp$, $\overset{!}{\sepimp}$, $\rightarrow$ and $\xrightarrow{!}$
which we write in infix format instead of the two $\overset{\circ}{\rightarrow}$
and $\overset{\bullet}{\rightarrow}$ constructors which describe restricted and unrestricted
versions of function types. We write $\sepimp$ when the function does not share any resources
with its arguments and $\rightarrow$ when the function may share resources
with its arguments. $\overset{!}{\sepimp}$ and $\xrightarrow{!}$
mean that they are unrestricted versions of $\sepimp$ and $\rightarrow$ respectively.
We use $\tau$, $\nu$ and $\phi$ to denote types of any kind. We support user defined data types following
Jones' [\cite{jones_system_1993}] by adding kind support to our language. Sum types can be represented
in the language using $\oplus$ notation.
% Describe Predicates
The \texttt{Un} $\tau$ denotes that the type $\tau$ is unrestricted.
We write \texttt{ShFun} $\tau$ to describe that type $\tau$ may share resources with its
argument types and \texttt{SeFun} $\tau$ to describe that $\tau$ is
does not share any resources from its argument types. The function types can also be of the unrestricted type.
Thus if a type $\tau$ is unrestricted i.e. it qualifies with predicate \texttt{Un} and it is also a function types
i.e. \texttt{SeFun} or \texttt{ShFun}, we write them as $\overset{!}{\sepimp}$ and $\xrightarrow{!}$ respectively.
This can be considered as an improving substitution following Jone's notion of improvement of qualified types [\cite{jones_simplifying_1995}].
We also define an ordering on types by using the predicate $\leq$. The predicate $\tau \leq \tau'$ holds if the type $\tau$
is less restricting than $\tau'$

\begin{figure}[h]
  \begin{framed}
  \begin{flalign*}
    \text{Environments}\ \ \      \Gamma,\Delta     &::= \epsilon \mid x:\sigma \mid \Gamma, \Delta \mid \Gamma; \Delta \nonumber
    % \text{Environment Context}\ \ \ H, H'           &::= \epsilon \mid H,H' \mid H;H' \mid \square \nonumber\\
  \end{flalign*}
\end{framed}
  \caption{Language Context}
  \label{fig:quill-context}
\end{figure}
% Describe Typing judgments
In normal type systems, the contexts are represented as sets or lists. In our modified system we represented them as binary trees.
The leaf nodes contain the pair of variable and types. Internal nodes of the context tree are
connectives which can either be a semicolon ($;$) or a comma ($,$).
If a bunch $\Delta$ is a subtree of $\Gamma$, then we denote a subtree relation by $\Gamma(\Delta)$.
Two contex are equivalent ($\Gamma \equiv \Delta$)if they can be transformed into one another by renaming the identifiers.
The bunches have a restriction that no identifier appears more than once. We restrict certain structural rules on the context
depending on the connectives being used. If contexts are combined using a comma ($,$), contraction and weakening is not admissible,
but if the contexts are combined using a semicolon ($;$) then it can undergo contraction and weakening. Exchange rule is admissible
in both the connectives. This distinction enables us to have a special treatement for resources in our language.
By associating a resource with a comma constructor, our type system will not disposed it off by using the contraction rule.
While, non-resourceful objects (or normal propositions) can be combined using the semi-colon constructor.
\TODO{add the contexttree graph here}
\begin{figure}[h]
  \begin{framed}
    \begin{flalign*}
      \text{Term Variables}\ \ \  x, y, z  &\in \text{Var} \nonumber\\
      \text{Patterns}\ \ \        p        &::= x \mid C \vec{x}\nonumber\\
      \text{Expressions}\ \ \     M, N     &::= x \mid \lambda^{*}x. M \mid \lambda^{\alpha}x. M \mid M N\nonumber\\
                                           &\mid \Case{M}{\{\texttt{inl}\ M \mapsto N ; \texttt{inr}\ M \mapsto N'\}}\mid \texttt{inl}\ M \mid \texttt{inr}\ M \nonumber\\
                                           &\mid \Let{x}{M}{N} \mid \nonumber
    \end{flalign*}
  \end{framed}
  \caption{Language Syntax}
  \label{fig:quill-terms}
\end{figure}
% Describe the language here

% Describe terms and patterns
Our term language is similar to that of simply typed lambda calculus involving variables and application
but now we have 2 different kind of lambdas. The alpha lambda ($\lambda^{\alpha} x. M$) denotes sharing
of the argument term with the expression $M$ and the separating lambda term ($\lambda^{*} x. M$) that implies
the argument term has a separating context with the expression $M$. We also have polymorphic $\texttt{let}$
expressions to be able to define functions with a limited scope. The type constructors are added
in order to allow programmers to define their own data types. They can be used to define sum and product types.
\texttt{case} expression can be used to pattern match on the expression to express it in terms
of individual sum types. Patterns are either term variables or constructor terms.

\TODO{How do we write about type constructors?}
\TODO{Encode sum types in this calculus}
\TODO{4 types of pairs. 2 of them are church encodeable. 2 of them are not.}

\section{Conventions and Notations}
$\Gamma_{x}$ is the typing environment excluding the type variable $x$. $TV(\Gamma)$ are the free
variables in the environment $\Gamma$. $\Gamma \bullet \Delta$ means that the contexts can either
be comma separated or semicolon separated i.e. $\Gamma, \Delta$ or $\Gamma;\Delta$. $\vec{x}$ is a shorthand for
one or many variables.

\section{Syntax Directed Typing Judgments}

\begin{figure}[h]
  \begin{framed}
    % var
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{} \RightLabel{[VAR]}
        \UnaryInfC{$P \mid x : \sigma \vdash x : \sigma $}
      \end{prooftree}
    \end{minipage}
    % let
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \sigma$}
        \AxiomC{$P' \mid \Gamma_{x} \cdot x: \sigma \vdash N: \tau$} \RightLabel{[LET]}
        \BinaryInfC{$P \cup P' \mid \Gamma \vdash \Let{x}{M}{N}: \tau$}
      \end{prooftree}
    \end{minipage}
    % forall I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \sigma$}
        \AxiomC{$t \notin TV(\Gamma) \cup TV(P)$}\RightLabel{$[\forall I]$}
        \BinaryInfC{$P \mid \Gamma \vdash M: \forall t. \sigma$}
      \end{prooftree}
    \end{minipage}
    % forall E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M: \forall t.\sigma$}\RightLabel{$[\forall E]$}
        \UnaryInfC{$P \mid \Gamma \vdash M: [\tau \backslash t] \sigma $}
      \end{prooftree}
    \end{minipage}
    % => I
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P, \pi \mid \Gamma \vdash M : \rho$} \RightLabel{$[=> I]$}
        \UnaryInfC{$P \mid \Gamma \vdash M : \pi \Rightarrow \rho$}
      \end{prooftree}
    \end{minipage}
    % => E
    \begin{minipage}{0.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \pi \Rightarrow \rho$}
        \AxiomC{$P \Rightarrow \pi$} \RightLabel{$[=> E]$}
        \BinaryInfC{$P \mid \Gamma \vdash M: \rho$}
      \end{prooftree}
    \end{minipage}
    % CTR UN
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma(\Delta', \Delta') \vdash M : \sigma$}
        \AxiomC{$P'\vdash H' un$} \RightLabel{[CTR-UN]}
        \BinaryInfC{$P \mid \Gamma(\Delta') \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}
    % WKN UN
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma(\epsilon) \vdash M : \sigma$}
        \AxiomC{$P'\vdash H' un$} \RightLabel{[WKN-UN]}
        \BinaryInfC{$P \mid \Gamma(\Delta') \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}
    % CTR Sh
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma(\Delta'; \Delta') \vdash M : \sigma$} \RightLabel{[CTR-SH]}
        \UnaryInfC{$P \mid \Gamma(\Delta') \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}
    % WKN Sh
    \begin{minipage}{.5\textwidth}
      \begin{prooftree}
        \AxiomC{$P  \mid \Gamma(H') \vdash M : \sigma$} \RightLabel{[WKN-SH]}
        \UnaryInfC{$P \mid \Gamma(H'; H'') \vdash M : \sigma$}
      \end{prooftree}
    \end{minipage}
    % -&> I
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma_{x};x: \tau \vdash M : \tau'$}
        \AxiomC{$P \Rightarrow \texttt{ShFun}\ \phi$}
        \AxiomC{$P \vdash \Gamma \geq \phi$} \RightLabel{$[\rightarrow I]$}
        \TrinaryInfC{$P \mid \Gamma \vdash \lambda^{\alpha}x. M : \phi \tau \tau'$}
      \end{prooftree}
    \end{minipage}
    % -&> E
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \phi \tau \tau'$}
        \AxiomC{$P \mid \Delta \vdash N : \tau'$}
        \AxiomC{$P => \texttt{ShFun}\ \phi$}
        \AxiomC{$P \vdash \Gamma \geq \phi$} \RightLabel{$[\rightarrow E]$}
        \QuaternaryInfC{$P \mid \Gamma;\Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
    % -*> I
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma_{x},x: \tau \vdash M : \tau'$}
        \AxiomC{$P => \texttt{SeFun}\ \phi$}
        \AxiomC{$ P \vdash \Gamma \geq \phi$} \RightLabel{$[\sepimp I]$}
        \TrinaryInfC{$P \mid \Gamma \vdash \lambda^{*}x. M : \phi \tau \tau'$}
      \end{prooftree}
    \end{minipage}
    % -*> E
    \begin{minipage}{1\textwidth}
      \begin{prooftree}
        \AxiomC{$P \mid \Gamma \vdash M : \phi \tau \tau'$}
        \AxiomC{$P \mid \Delta \vdash N : \tau$}
        \AxiomC{$P => \texttt{SeFun}\ \phi$}
        \AxiomC{$P \vdash \Gamma \geq \phi$} \RightLabel{$[\sepimp E]$}
        \QuaternaryInfC{$P \mid \Gamma,\Delta \vdash M N : \tau'$}
      \end{prooftree}
    \end{minipage}
  \end{framed}
    \caption{Typing Rules}
    \label{fig:typing-rules}
\end{figure}

We now see that we have two kinds of pairs. A sharing pair (\texttt{shPair}) and a separating pair (\texttt{sePair}) depending on
what arrow we use. The church encoding of both the pairs are given in \ref{fig:bi-pairs}.
\begin{figure}[h]
  \centering
  \begin{framed}
    \begin{minted}[escapeinside=||,mathescape=true]{haskell}
      shPair = |$\lambda^{*}$| a. |$\lambda^{\alpha}$| b. |$\lambda^{*}$| f. f a b
      sePair = |$\lambda^{*}$| a. |$\lambda^{*}$| b. |$\lambda^{*}$| f. f a b
    \end{minted}
  \end{framed}
  \caption{Pairs in \textbf{\em BI}}
  \label{fig:bi-pairs}
\end{figure}
The types of both these pair will be as shown in \ref{fig:bi-pairs-typing}
\begin{figure}[h]
  \centering
  \begin{framed}
    \begin{lstlisting}
      shPair : a $\sepimp$ b $\rightarrow$ (a $\sepimp$ b $\sepimp$ c) $\sepimp$ c
      sePair : a $\sepimp$ b $\sepimp$ (a $\sepimp$ b $\sepimp$ c) $\sepimp$ c
    \end{lstlisting}
  \end{framed}
  \caption{Typing for Pairs in \textbf{\em BI}}
  \label{fig:bi-pairs-typing}
\end{figure}


% sum type E
\begin{minipage}{1\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash M: \tau_1 \oplus \tau_2$}
    \AxiomC{$P \mid \Delta_x\bullet x:\tau_1 \vdash N :\tau_i$}
    \AxiomC{$P \mid \Delta_x \bullet x:\tau_2 \vdash N':v$}\RightLabel{$[\oplus E]$}
    \TrinaryInfC{$P \mid \Delta \bullet \Delta' \vdash \Case{M}{\{\texttt{inl}\ M \mapsto N; \texttt{inr}\ M \mapsto N'\}} : v $}
  \end{prooftree}
\end{minipage}
% sum type I_l
\begin{minipage}{0.5\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash M: \tau_1$}
    \UnaryInfC{$P \mid \Delta \vdash \texttt{inl}\ M: \tau_1 \oplus \tau_2 $}
  \end{prooftree}
\end{minipage}
% sum type I_r
\begin{minipage}{0.5\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash M: \tau_2$}
    \UnaryInfC{$P \mid \Delta \vdash \texttt{inr}\ M: \tau_1 \oplus \tau_2 $}
  \end{prooftree}
\end{minipage}

% sharing constructor
\begin{minipage}{1\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash C: \tau_1 \sepimp \tau_2 \rightarrow \tau_3 \rightarrow \dots \rightarrow \tau_n \rightarrow T$}
    \AxiomC{$\Delta \equiv H(x_1 : \tau_1 ; x_2 : \tau_2 ; \ldots ; x_n:\tau_n)$}\RightLabel{$[\text{C-sh}]$}
    \BinaryInfC{$P \mid \Gamma; \Delta \vdash C \vec{x} : T $}
  \end{prooftree}
\end{minipage}
% Separating constructor
\begin{minipage}{1\textwidth}
  \begin{prooftree}
    \AxiomC{$P \mid \Gamma \vdash C: \tau_1 \sepimp \tau_2 \sepimp \tau_3 \sepimp \dots \sepimp \tau_n \sepimp T$}
    \AxiomC{$\Delta \equiv H(x_1: \tau_1, x_2:\tau_2, \dots ,x_n:\tau_n)$}\RightLabel{$[\text{C-se}]$}
    \BinaryInfC{$P \mid \Gamma, \Delta \vdash C \vec{x} : T $}
  \end{prooftree}
\end{minipage}

\begin{figure}[h]
  \begin{framed}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P => \texttt{Un}\ \tau$}\RightLabel{[\texttt{Un}-$\tau$]}
      \UnaryInfC{$P \vdash \tau\ \texttt{un}$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P,\pi \vdash \rho\ \texttt{un}$}\RightLabel{[\texttt{Un}-$\rho$]}
      \UnaryInfC{$P \vdash \pi => \rho\ \texttt{un}$}
    \end{prooftree}
  \end{minipage}

  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P, \texttt{Un}\ t \vdash \sigma\ \texttt{Un}$}\RightLabel{[\texttt{Un}-$\sigma$]}
      \UnaryInfC{$P \vdash \forall t.\sigma\ \texttt{un}$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$\bigwedge_{x:\sigma \in \Gamma}P \vdash \rho\ \texttt{un}$}\RightLabel{[\texttt{Un}-$\Gamma$]}
      \UnaryInfC{$P \vdash \Gamma\ \texttt{un}$}
    \end{prooftree}
  \end{minipage}

  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P => \tau \leq \phi$}\RightLabel{[$\leq$-$\tau$]}
      \UnaryInfC{$P \vdash \tau \leq \phi$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P,\pi \vdash \rho \leq \phi$}\RightLabel{[$\leq$-$\rho$]}
      \UnaryInfC{$P \vdash (\pi => \rho) \leq \phi$}
    \end{prooftree}
  \end{minipage}

  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P, \texttt{Un}\ t \vdash \sigma \leq \phi$}\RightLabel{[$\leq$-$\sigma$]}
      \UnaryInfC{$P \vdash (\forall t.\sigma) \leq \phi$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    \begin{prooftree}
      \AxiomC{$\bigwedge_{x:\sigma \in \Gamma}P \vdash \rho \leq \phi$}\RightLabel{[$\leq$-$\Gamma$]}
      \UnaryInfC{$P \vdash \Gamma \leq \phi$}
    \end{prooftree}
  \end{minipage}
\end{framed}
  \caption{Typing Rules for Base cases}
  \label{fig:bi-base-typing-rules}
\end{figure}

  \begin{figure}[h]
  \begin{framed}
  \begin{minipage}{1\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H  \vdash M : \tau$}
      \AxiomC{$P \mid H' \vdash N: \tau'$} \RightLabel{$[\with I]$}
      \BinaryInfC{$P \mid H;H' \vdash (M;N): \tau \with \tau'$}
    \end{prooftree}
  \end{minipage}

  \begin{minipage}{.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H \vdash M: \tau \with \tau'$} \RightLabel{$[\with E_1]$}
      \UnaryInfC{$P \mid H \vdash \texttt{fst}\ M: \tau$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H \vdash M: \tau \with \tau'$} \RightLabel{$[\with E_2]$}
      \UnaryInfC{$P \mid H \vdash \texttt{snd}\ M: \tau'$}
    \end{prooftree}
  \end{minipage}

  \begin{minipage}{1\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H  \vdash M : \tau$}
      \AxiomC{$P \mid H' \vdash N: \tau'$} \RightLabel{$[\otimes I]$}
      \BinaryInfC{$P \mid H,H' \vdash (M,N): \tau \otimes \tau'$}
    \end{prooftree}
  \end{minipage}

  \begin{minipage}{.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H \vdash M: \tau \otimes \tau'$} \RightLabel{$[\otimes E_1]$}
      \AxiomC{$P => \texttt{Un}\ \tau'$}
      \BinaryInfC{$P \mid H \vdash \texttt{fst}\ M: \tau$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.5\linewidth}
    \begin{prooftree}
      \AxiomC{$P \mid H \vdash M: \tau \otimes \tau'$} \RightLabel{$[\otimes E_2]$}
      \AxiomC{$P => \texttt{Un}\ \tau$}
      \BinaryInfC{$P \mid H \vdash \texttt{snd}\ M: \tau'$}
    \end{prooftree}
  \end{minipage}
\end{framed}
  \caption{Derivable Typing rules}
  \label{fig:derivable-typing-rules}
\end{figure}

\section{Modified Algorithm $\M$}
The type inference algorithm is given in \cref{fig:algorithm-m}
$\Sigma$ keeps track of all the used variables
$S$ is the substitution that is generated by the algorithm to infer the type of the
term using the context $\Gamma$. $X$ are the predicates for the qualified types.

$\mathcal{U}$ is a modified Robinson's unification algorithm[\cite{robinson_machine-oriented_1965}].
It generates kind preserving substitutions to unify types. The algorithm fails, if no such substitution exists.
We write $C \overset{U}{\sim}_{\kappa} C'$ for assertion that $U$ is the unifier
of the constructor types $C$ and $C'$.

\begin{flalign*}
\tau \sim \tau' => \exists S. S \tau = \tau'
\end{flalign*}
\begin{figure}[h]
  \begin{framed}
    \begin{minipage}{0.5\linewidth}
      \begin{flalign*}
        Leq(\phi, \Gamma)  = \bigcup_{(x:\tau) \in \Gamma} \{P \mid P \vdash \phi \leq \tau \}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{flalign*}
        \texttt{Un}(\Gamma)  = \bigcup\{P \mid (y:\sigma) \in \Gamma, P \vdash \sigma\ \texttt{un} \}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{flalign*}
        \texttt{Weaken}(x, \sigma, \Sigma)  = \begin{cases}
             P\ \ \ \ &\text{if}\ x \notin \Sigma, P \vdash \sigma\ \texttt{un}\\
             \emptyset\ \ \ &otherwise
        \end{cases}
      \end{flalign*}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
      \begin{flalign*}
        \texttt{GenI}(\Gamma, P &=> \tau)  = \forall (ftv(S P, \tau)).S P => \tau \nonumber\\
                                          \text{where}\ &S\ \text{improves}\ \texttt{ftv}(P) \backslash \texttt{ftv}(\Gamma, \tau)\ \text{in}\ P
      \end{flalign*}
    \end{minipage}
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \mathcal{C}(P, \Gamma, \Sigma)  = \{ x_i, x_j \mid \Gamma(x_i:\tau_1;x_j:\tau_2) \}
      \end{flalign*}
    \end{minipage}
  \end{framed}
  % Un
  % Weaken
  % GenI
  % \mathcal{C}(\Gamma, \Sigma)
  \caption{Auxilary definitions}
  \label{fig:aux-defs}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    \begin{minipage}[ht]{1\linewidth}
      \centering
      \fbox{
        $\M(S, X;\Gamma \vdash M : \tau) = P, S', \Sigma$
      }
    \end{minipage}

    % x var
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, X;\Gamma \vdash x : \tau) &= ([\vec{u} / \vec{t}]P), S' \circ S, \{x\} \nonumber \\
        \text{where}\ (x : \forall \vec{t}. P => \nu) &\in S \Gamma \nonumber\\
        S' &= \Unf([\vec{u} / \vec{t}]\nu, S \tau)
      \end{flalign*}
    \end{minipage}

    % \*x. M: t
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, X;\Gamma \vdash \lambda ^{*} x. M : \tau) &= (P \cup Q), S', \Sigma \backslash x \nonumber \\
        \text{where}\ P; S'; \Sigma &= \M(\Unf(\tau, u_1 u_2 u_3) \circ S, X; \Gamma, x:u_2 \vdash M: u_3) \nonumber\\
        Q &= \{\SeFun{u_1}\} \cup \text{Leq}(u_1, \Gamma\mid_{\Sigma}) \cup \text{Weaken}(x, u_2, \Sigma)
      \end{flalign*}
    \end{minipage}

    % \&x. M: t
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, X;\Gamma \vdash \lambda ^{\alpha} x. M : \tau) &= (P \cup Q), S', \Sigma \backslash x \nonumber \\
        \text{where}\ P; S'; \Sigma &= \M(\Unf(\tau, u_1 u_2 u_3) \circ S, X; \Gamma, x:u_2 \vdash M: u_3) \nonumber\\
        Q &= \{\ShFun{u_1}\} \cup \text{Leq}(u_1, \Gamma|_{\Sigma}) \cup \text{Weaken}(x, u_2, \Sigma)
      \end{flalign*}
    \end{minipage}

    % M N: t
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, X;\Gamma \vdash M N : \tau) &= Q, R', \Sigma \cup \Sigma' \nonumber \\
        \text{where}\ P, R, \Sigma &= \M(S, X; \Gamma M:  u_1 u_2 \tau) \nonumber \\
        P', R', \Sigma' &= \M(R, X; \Gamma N: u_2) \nonumber\\
        \text{if}\ \mathcal{C}(\Gamma, \Sigma) &= \mathcal{C}(\Gamma, \Sigma') \nonumber\\
        \text{then}\ Q &= P \cup P' \cup \{\ShFun{u_1}\} \nonumber\\
        \text{else}\ Q &= P \cup P' \cup \{\SeFun{u_1}\} \cup \text{Un}(\Gamma|_{\Sigma \cap \Sigma'})
      \end{flalign*}
    \end{minipage}

    % let x = M in N: t
    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, X;\Gamma \vdash \Let{x}{M}{N} : \tau) &= (P \cup Q), R', \Sigma \cup \{\Sigma' \backslash x \} \nonumber\\
        \text{where}\ P, R, \Sigma &= \M(S, X;\Gamma \vdash M:u_1) \nonumber \\
        \sigma &= \text{GenI}(R\Gamma; R(P => u_1)) \nonumber\\
        P', R', \Sigma' &= \M(R, X;\Gamma, x:\sigma \vdash N : \tau) \nonumber\\
        Q &= \text{Un}(\Gamma|_{\Sigma \cap \Sigma'}) \cup \text{Weaken}(x, \sigma, \Sigma')
      \end{flalign*}
    \end{minipage}

    \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, X;\Gamma \vdash \Case{M}{\{p_i \mapsto N_i\}_i}) &= (P_M \cup \{P_i\}), Q, \Sigma_M \cup \{\Sigma_i\} \nonumber\\
        \text{where}\ P_M, R_M, \Sigma_M &= \M(S, X;\Gamma \vdash M:u_1 \oplus u_2 \oplus \cdots \oplus u_n) \nonumber \\
                      P_1, R_1, \Sigma_1 &= \M(R_M, X;\Gamma \vdash p_1:u_1 \vdash N_1: v) \nonumber \\
                      P_i, R_i, \Sigma_i &= \M(R_{i-1}, X;\Gamma \vdash p_i:u_i \vdash N_i: v) \nonumber \\
                                 \Sigma' &= \bigcup_{i,j \leq n} (\Sigma_i \cap \Sigma_{j}) \nonumber\\
                                       Q &= \text{Un}(\Gamma|_{\Sigma'}) \cup \{\text{Weaken}(p_i, u_i, \Sigma_i)\}
      \end{flalign*}
    \end{minipage}
\end{framed}
  \caption{Type Inference Algorithm $\mathcal{M}$}
  \label{fig:algorithm-m}
\end{figure}

\begin{figure}[h]
  \begin{framed}
      \begin{minipage}{1\linewidth}
      \begin{flalign*}
        \M(S, X;\Gamma \vdash C\ x) &= (P_M \cup \{P_i\}), Q, \Sigma_M \cup \{\Sigma_i\} \nonumber\\
          \text{where}\ C &= \forall \vec{t_1}. (\forall \vec{t_2}. \exists \vec{t_3}. Q => v') \sepimp v \nonumber\\
       P_M, R_M, \Sigma_M &= \M(S, X;\Gamma \vdash M:u_1 \oplus u_2 \oplus \cdots \oplus u_n) \nonumber \\
       P_1, R_1, \Sigma_1 &= \M(R_M, X;\Gamma \vdash p_1:u_1 \vdash N_1: v) \nonumber \\
       P_i, R_i, \Sigma_i &= \M(R_{i-1}, X;\Gamma \vdash p_i:u_i \vdash N_i: v) \nonumber \\
                  \Sigma' &= \bigcup_{i,j \leq n} (\Sigma_i \cap \Sigma_{j}) \nonumber\\
                                                  Q &= \text{Un}(\Gamma|_{\Sigma'}) \cup \{\text{Weaken}(p_i, u_i, \Sigma_i)\}
      \end{flalign*}
    \end{minipage}
  \end{framed}
  \caption{Type Inference Algorithm $\mathcal{M}$ (continued)}
  \label{fig:algorithm-m-cont}
\end{figure}

Here is how the naive recursive algorithm works

For Lambda
\begin{enumerate}
\item Get the bound variable
\item Assign a new type for bound variable
\item assign a new type variable for the body
\item Evaluate type of the body and assign it to the body type variable
\item return the type as (type of var) -> (type of body)
\end{enumerate}

Body can be made up of another lambda. In this case the same 5 steps will be triggered
or it is an application of 2 or more variables
In case of application 2 new type variable:
\begin{enumerate}
\item introduce type variables for left expression and right expression
    left expression a type $A \rightarrow B$ right expression gets the type $A$
\item recursively type check both of them
\item return the type of the complete application as $B$ if the type checking in previous step is successfully
\end{enumerate}


In Quill there are 2 kinds of lambdas:
\begin{enumerate}
\item Sharing Lambda $\lambda^{\alpha}$
\item Separating Lambda $\lambda^{*}$
\end{enumerate}
This helps us specify if the 2 variables are separated or have sharing
of resources between them.
The church encoding of a sharing pair will be represented as\\
$shPair = \lambda^{*} x \rightarrow \lambda^{\alpha} y \rightarrow \lambda^{*} sh \rightarrow sh\ x\ y$\\
This means that x and y may share resources
A separating pair is represented as\\
$sePair = \lambda^{*} x \rightarrow \lambda^{*}y \rightarrow \lambda^{*}se \rightarrow se\ x\ y$\\
This means that x and y do not share resources.
%By default we may assume that resources are always separating unless explicitly specified
%that they are sharing.

\section{Typing environment}

The typing environment in standard Milner-Damas algorithm
is a pair of identifier and its type.
We need to modify the typing environment so that it describes sharing.
% There can be many different ways of doing it.
In the current implementation we have
extended the typing environment to hold 2 more entities along with the
type of the identifier, a list of list of identifiers --- that describes the sharing of variables,
a scope tag---that identifies if the variable is global in the complete module or local to the definition.
Global variables can be used anywhere in the file or other code file if it is imported
All function names will be defaulted to global scope.
Local variables can be used only after they have been bound in the typing environment.
The new typing environment can be realized as:
\begin{minted}{haskell}
  type Env = Map Id (Type, [[Id]], Scope)
\end{minted}

% how is the list of list of ids help in identifying sharing

% how do you define a closure

% What do you mean by having a break in the closure

% The used field in the type-checker state

\section{Modification to Typechecking Algorithm}

To incorporate the sharing, we have to modify the typechecking algorithm.
The main reason to do that is to avoid adding $Un$ predicates to
shared variables that are not used. Take an example of $fst$ function
that returns the first argument of a shared pair
\begin{verbatim}
fst = \x -> \&y -> x
\end{verbatim}
In this case y should not be assigned an $Un$ predicate because
it is shared with x and x is indeed used.

The type checking algorithm has to be tweaked so that we keep track
of what all variables are shared and which ones are separate.

When we encounter an Alpha Lambda
\begin{enumerate}
\item Get the bound variable
\item Assign a new type for bound variable
\item Assign a new type variable for the body
\item add the variable in a sharing context
\item Evaluate type of the body and assign it to the body type variable
\item return the type as (type of var) -> (type of body)
\end{enumerate}


% The main problem is that we do not know when a sharing variable should be kept in scope
% or removed. In some cases we may need to keep it around for introducing the (>:=) predicates
% Some cases are 2 types:
% 1) The variable is used
% 2) The variable is not used

The type checking calls occur from left to right recursively.
While going down the recursion we keep on adding variables to the environment
We stop recursing at application. where we compute whether we have complete sharing to assign ShFun or SeFun.

While folding out of of the recursion we do 2 things:
1) keep track of the used variables (including implicitly used variables due to sharing)
2) generate new goals
   a) depending on whether the the introduced variable was used
      or its sharing member was used. Assign Un predicates and weaken if it is not used at all
   b) introduce lesser-restricted predicates
3) Generate other new assumptions

We cannot determine when to get rid of the complete bunch.
\begin{verbatim}
\z -> \*x -> \&y -> y
\end{verbatim}
hence, when we are folding out of the final recursive but 1 call ie. for Lambda bound variable x


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku.tex"
%%% End:
