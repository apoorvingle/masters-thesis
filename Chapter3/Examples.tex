\chapter{Programming in \qub{}}\label{chp:qub-programming}
In this chapter, we illustrate using examples how \qub{} is different
from other functional languages and how a powerful type system based on logic of \BI
would be used to track resources. The examples show how the resources use
can be tracked at compile time and resource leaks can be avoided.

\section{File Handles}\label{sec:file-handle-example}
In modern programming languages resources such as files are treated as normal variables.
It is the programmer's responsibility to check that that files are not closed twice
and that there are no files that remain open when the program exits. This seemingly trivial
responsibility becomes tedious and error prone as soon as the programming logic gets complex.
Modern functional languages such as Haskell enforces the file input and output to be wrapped in a IO Monad.
This is more declarative than imperative languages, but the type system is not powerful enough
to detect whether a file handle is closed twice or is not closed at all.
Consider the type signatures for functions for file handling shown in \cref{fig:file-handling-function}. We explicitly
return the file resource i.e. \mintinline{haskell}{f}. A simple program in Haskell that opens a file and reads
a line from it and then closes the file handle using this flavor of file handling functions is shown in \cref{fig:file-read-close}.

\begin{figure}[h]
  \begin{framed}
    \begin{minted}[linenos]{haskell}
openFile :: FilePath -> IO FileHandle
closeFile :: FileHandle -> IO ()
readLine :: FileHandle -> IO (String, FileHandle)
writeFile :: String -> FileHandle -> IO ((), FileHandle)
    \end{minted}
  \end{framed}
  \caption{File Handling Functions}
  \label{fig:file-handling-function}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    \begin{minted}[linenos]{haskell}
do f  <- openFile "sample.txt"
   (s, f)  <- readLine f
   () <- closeFile f
    \end{minted}
  \end{framed}
  \caption{Reading from a file in Haskell}
  \label{fig:file-read-close}
\end{figure}

Consider an incorrect version of a program where the file handle is closed twice after reading a line from it as shown in \cref{fig:file-read-close-2times}.
It may not cause problems in a single threaded environment, but in a multi-threaded environment
the second close may accidently close the file handle that may have been reused in the background by another thread.
When another thread tries to write on this closed file handle, it would throw an exception.
Haskell's type system would happily accept this program but it might generate a runtime exception.
\begin{figure}[h]
  \begin{framed}
    \begin{minted}[linenos]{haskell}
do f  <- openFile "sample.txt"
   (s, f)  <- readLine f
   () <- closeFile f
   () <- closeFile f
    \end{minted}
  \end{framed}
  \caption{Reading from a File and Closing it Twice}
  \label{fig:file-read-close-2times}
\end{figure}

Apple's goto fail bug that appeared in iOS 7.0 and caused a security vulnerability in 2012 is a similar example of closing the file twice.
The code snippet that caused the SSL/TLS handshake to be completely skipped looked like in \cref{fig:goto-fail}.
The cases in which the condition is false, the second \mintinline{C}{goto fail;} on line 6 would force the protocol to skip the
steps to be taken after the if-block. This made the system vulnerable to a man-in-middle attack.
\begin{figure}[h]
  \begin{framed}
\begin{minted}[linenos]{C}
...
if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)
    goto fail;
if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
    goto fail;
    goto fail;
if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)
    goto fail;

err = sslRawVerify(...);
...
\end{minted}
  \end{framed}
  \caption{Goto Fail bug}
  \label{fig:goto-fail}
\end{figure}

Another example of incorrect way of using file handle is by not closing the file handle after using it shown in \cref{fig:file-read-noclose}.
In a short lived process, when the program exits, file handles that are not closed are freed by the operating system.
But if it is a long running process it would run out of file handles and the whole process would crash with an error that
it cannot open any more file handles. Abnormal exit from the process would interfere in the write process
and the operating system would close the file handle without waiting for the buffer to be completely
written on the file system.
\begin{figure}[h]
  \begin{framed}
    \begin{minted}[linenos]{haskell}
do f <- openFile "sample.txt"
   (s, f)  <- readLine f
   return s
    \end{minted}
  \end{framed}
  \caption{Reading from a File and Not Closing File Handle}
  \label{fig:file-read-noclose}
\end{figure}

We take a deeper dive into this problem by inspecting the desugared version of the ``do'' notation.
Both the programs would be translated into bind ($>>=$) operations . Recall that type signature of bind function is given as
\mintinline{haskell}{(>>=) :: (Monad m) => m t -> (t -> m u) -> m u}. Desugared version of \cref{fig:file-read-close-2times}
is shown in \cref{fig:file-read-close-2times-desugared} and the desugared version of \cref{fig:file-read-noclose} is shown in \cref{fig:file-read-noclose-desugared}.

\begin{figure}[h]
\begin{framed}
\begin{minted}[linenos]{haskell}
(>>=) (openFile "sample.txt" ReadMode) (\f ->
       >>= (closeFile f) (\(s, f) -> return s)
\end{minted}
  \end{framed}
  \caption{Reading from a File in Haskell and Not Closing It}
  \label{fig:file-read-noclose-desugared}
\end{figure}

\begin{figure}[h]
  \begin{framed}
    \begin{minted}[escapeinside=||,mathescape=true, linenos]{haskell}
(>>=|$_1$|) (openFile "sample.txt") (\f ->
            (>>=|$_2$|) (readFile f) (\(s, f) ->
                        (>>=|$_3$|) (close f) (\_ -> closeFile f)))
    \end{minted}
  \end{framed}
  \caption{Reading from a File in Haskell and Closing Twice}
  \label{fig:file-read-close-2times-desugared}
\end{figure}

In both the cases described above, the well typed looking program should be red flagged by the compiler as it would
cause problems at runtime. To solve this problem, we introduce the % concept of unrestricted type similar to Quill,
% and
concept of sharing and separation of resources from the logic of \BI{} in \qub. The type $\rightarrow$ now
has to be specified as either shared ($\shimp$) or separated ($\sepimp$). In \qub{} program code, we will use
\mintinline{haskell}{-*>} to mean $\sepimp$ and \mintinline{haskell}{-&>} to mean $\shimp$.
The file handling functions would have slightly different type signatures in \qub{} as shown in \cref{fig:qub-file-handling-functions} to accommodate
the new function implication flavors. Similarly, the bind operation will also be typed differently as shown below as the resources of the function are
separate from its arguments. % The arrow \mintinline{haskell}{-!*>} means that the function itself is unrestricted, i.e. it does not contain
% any resources, and it does not share resources with its argument.

\begin{figure}[h]
  \begin{framed}
    \begin{minted}[linenos]{haskell}
openFile :: FilePath -*> IO FileHandle
closeFile :: FileHandle -*> IO ()
readLine :: FileHandle -*> IO (String, FileHandle)
writeFile :: String -*> FileHandle -*> IO ((), FileHandle)

(>>=) :: (Monad m) => m t -*> (t -*> m u) -*> m u
    \end{minted}
  \end{framed}
  \caption{File Handling and Bind Function Type Signatures in \qub{}}
  \label{fig:qub-file-handling-functions}
\end{figure}

We now consider the types for the two faulty programs previously described with respect to \qub{}.
In \cref{fig:qub-close-file-twice} we see that the first \mintinline[escapeinside=||,mathescape=true]{haskell}{(>>=|$_1$|)}
and second bind \mintinline[escapeinside=||,mathescape=true]{haskell}{(>>=|$_2$|)} functions would have appropriate types
where each argument is separate from the the function. The file handing functions
return a new binding for the file resource \HaskellF{f}. However, we notice that the third bind operation
\mintinline[escapeinside=||,mathescape=true]{haskell}{(>>=|$_3$|)} would have a problem. It  would be typed as
\mintinline{haskell}{IO () -*> (() -*> IO ()) -&> IO ()}\\
as both the arguments share the file variable \HaskellF{f} which would be a type error
as the bind operation should have a type signature of \mintinline{haskell}{IO () -*> (() -*> IO ()) -*> IO ()}.
This mismatch in the types would be caught statically during the type checking phase of compilation.

\begin{figure}[h]
\begin{framed}
\begin{minted}[escapeinside=||,mathescape=true, linenos]{haskell}
(>>=|$_1$|) (openFile "sample.txt") (\f ->
            (>>=|$_2$|) (readFile f) (\(s, f) ->
                        (>>=|$_3$|) (close f) (\_ -> closeFile f)))


(>>=|$_1$|):: IO FileHandle -*> (FileHandle -*> IO ()) -*> IO ()
(>>=|$_1$|) (openFile "sample.txt" ReadMode) (\f -> ...)

(>>=|$_2$|) :: IO FileHandle
            -*> (FileHandle -*> IO (String, Filehandle))
            -*> IO (String, FileHandle)}
(>>=|$_2$|) (readLine f) (\(s,f) -> ... )

(>>=|$_3$|) :: IO () -*> (() -*> IO ()) -&> IO ()
(>>=|$_3$|) (closeFile f) (\_ -> closeFile f)}
\end{minted}
\end{framed}
\caption{Closing file twice in \qub{}}
\label{fig:qub-close-file-twice}
\end{figure}

We also have the concept of unrestricted types similar to Quill. A type that contains no resources, or which is implicitly
copied or dropped in the program is tagged as an unrestriced type. In the second faulty program,
shown in \cref{fig:file-read-noclose-desugared} the file handle \HaskellF{f} is not closed.
It is declared but not used in its scope. This would force the file handle to be be tagged as an unrestricted type by the \qub{} type checker.
This is a violation of our assumption that resources cannot be of the unrestricted type. Thus
the program would not type check due to mismatch of the file handle type to be inferred as unrestricted.

To summarize, \qub{} has two kinds of program objects---restricted and unrestricted---and two kinds of functions---sharing and separating.
Each type in \qub{} can be of these two kinds.

\section{Exception handling}
We expand on the file handling scenario and consider the code that can throw runtime exceptions.
The motivation to do so lies in the fact that memory leaks are caused because of runtime
exceptions where the part of code that is responsible to clean up resources or in this case
closing the file is skipped due to an alternate execution path. In Haskell, error handing is done using \HaskellF{MonadError}.
The type class definition is shown in \cref{fig:haskell-monaderror}. \HaskellF{throwError} is used inside a monadic context to initiate
exception processing and \HaskellF{catchError} is used to handle a previously thrown error and return
to a normal execution.

\begin{figure}[h]
  \begin{framed}
\begin{minted}[linenos=true, mathescape=true]{haskell}
class Monad m => MonadError e m | m -> e where
    throwError :: e -> m a
    catchError :: m a -> (e -> m a) -> m a
\end{minted}
  \end{framed}
  \caption{Haskell's MonadError Typeclass}
  \label{fig:haskell-monaderror}
\end{figure}

\noindent
A common way of handling error in Haskell is shown in \cref{fig:haskell-error-handling}.
We use the same file handling API as defined previously in \cref{fig:file-handling-function}
In normal code execution path, the first line of the file will be returned after closing the file.
In case of a runtime error, say \HaskellF{readLine f} throws an error, the \HaskellF{catchError} function will
invoke the handler function and return an appropriate error message. We notice that in case of an error the file handle \HaskellF{f}
is never closed and will cause a resource leak. The Haskell type system has no way to detect this memory leak.

\begin{figure}[h]
  \begin{framed}
\begin{minted}[linenos=true, escapeinside=||, mathescape=true]{haskell}
do f <- openFile "sample.txt"
   ((s, f)  <- readLine f
    let c = caps s
    () <- closeFile f
    return $ Right c) `catchError` (\_ ->
                             return $ Left "Error in reading file")
\end{minted}
  \end{framed}
  \caption{Handling Errors in Haskell}
  \label{fig:haskell-error-handling}
\end{figure}

In \qub{} the \HaskellF{onExcept} function would have a sharing arrow between the two arguments.
This will force the type checker to ensure that the file handle is indeed closed by performing
the error handing actions in the second argument of \HaskellF{onExcept}.
\HaskellF{IO} that does not fail or throw exceptions, and \HaskellF{IOF} that can fail and throw exceptions.

For a concrete example we will assume that \HaskellF{readLine} can throw an exception during runtime, where
it might fail to read a line due to the file mode being used has incorrect permissions.
For the sake of simplicity \HaskellF{closeFile} does not throw exceptions. \HaskellF{openFile} throwing
an exception would not be a problem as there would be no resource leak in that case. A sample code block
is shown in \cref{fig:qub-file-exceptions}.

% \HaskellF{onExcept} accepts a code that can fail and executes the second
% parameter only if the actual code throws an exception. The \HaskellF{onExcept} gives a chance
% to clean up resources in a systematic way. It may convert a code that can fail to a code
% that does not fail by using \HaskellF{catch} function, or it may re throw the exception after
% cleaning up the resources.

% In the exceptionless execution path in \cref{fig:file-exceptions}, a single line would be read from the file and its uppercased
% version would be returned after closing it. If suppose, an exception is thrown by \HaskellF{readLine}
% the \HaskellF{onExcept} would close the filehandle. Notice that \HaskellF{onExcept}
% shares the context with the file readline code, thus the appropriate file handle would be closed and
% we would not have any memory leak.

\begin{figure}[h]
  \begin{framed}
    \begin{minted}[linenos]{haskell}
openFile :: FilePath -*> Mode -*> IO FileHandle
closeFile :: FileHandle -*> IO ()
readFile :: FileHandle -*> IOF (String, FileHandle)
writeFile :: String -*> FileHandle -*> IOF ((), FileHandle)

throw :: Exception -*> IO a
catch :: IOF a -*> (Exception -> IO a) -&> IO a

onExcept :: IOF a -*> IOF () -&> IOF a
m `onExcept` n = m `catch` (\e -> n >> throw e)

readFromFile :: FilePath -*> IO (Either String String)
readFromFile fpath =
do fh  <- openFile fpath ReadMode
   ((s, fh)  <- readLine fh
   let l = caps s
   () <- close fh
   return $ Right l) `onExcept` (do () <- closeFile fh)
                     `catch` (\e ->
                                 return $ Left "Could not read file")
    \end{minted}
  \end{framed}
  \caption{Exception Handling in Files}
  \label{fig:qub-file-exceptions}
\end{figure}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis-ku"
%%% End:
